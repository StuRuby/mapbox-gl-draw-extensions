!function(t) {
    if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = t();
    else if ("function" == typeof define && define.amd)
        define([], t);
    else {
        var e;
        e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this,
        e.edit = t()
    }
}(function() {
    var t;
    return function t(e, n, i) {
        function r(s, a) {
            if (!n[s]) {
                if (!e[s]) {
                    var u = "function" == typeof require && require;
                    if (!a && u)
                        return u(s, !0);
                    if (o)
                        return o(s, !0);
                    var l = new Error("Cannot find module '" + s + "'");
                    throw l.code = "MODULE_NOT_FOUND",
                    l
                }
                var c = n[s] = {
                    exports: {}
                };
                e[s][0].call(c.exports, function(t) {
                    var n = e[s][1][t];
                    return r(n || t)
                }, c, c.exports, t, e, n, i)
            }
            return n[s].exports
        }
        for (var o = "function" == typeof require && require, s = 0; s < i.length; s++)
            r(i[s]);
        return r
    }({
        1: [function(t, e, n) {
            function i(t) {
                var e, n = 0;
                switch (t.type) {
                case "Polygon":
                    return r(t.coordinates);
                case "MultiPolygon":
                    for (e = 0; e < t.coordinates.length; e++)
                        n += r(t.coordinates[e]);
                    return n;
                case "Point":
                case "MultiPoint":
                case "LineString":
                case "MultiLineString":
                    return 0;
                case "GeometryCollection":
                    for (e = 0; e < t.geometries.length; e++)
                        n += i(t.geometries[e]);
                    return n
                }
            }
            function r(t) {
                var e = 0;
                if (t && t.length > 0) {
                    e += Math.abs(o(t[0]));
                    for (var n = 1; n < t.length; n++)
                        e -= Math.abs(o(t[n]))
                }
                return e
            }
            function o(t) {
                var e, n, i, r, o, u, l, c = 0, h = t.length;
                if (h > 2) {
                    for (l = 0; l < h; l++)
                        l === h - 2 ? (r = h - 2,
                        o = h - 1,
                        u = 0) : l === h - 1 ? (r = h - 1,
                        o = 0,
                        u = 1) : (r = l,
                        o = l + 1,
                        u = l + 2),
                        e = t[r],
                        n = t[o],
                        i = t[u],
                        c += (s(i[0]) - s(e[0])) * Math.sin(s(n[1]));
                    c = c * a.RADIUS * a.RADIUS / 2
                }
                return c
            }
            function s(t) {
                return t * Math.PI / 180
            }
            var a = t("wgs84");
            e.exports.geometry = i,
            e.exports.ring = o
        }
        , {
            wgs84: 60
        }],
        2: [function(t, e, n) {
            function i(t) {
                if (!t || !t.type)
                    return null;
                var e = r[t.type];
                return e ? "geometry" === e ? {
                    type: "FeatureCollection",
                    features: [{
                        type: "Feature",
                        properties: {},
                        geometry: t
                    }]
                } : "feature" === e ? {
                    type: "FeatureCollection",
                    features: [t]
                } : "featurecollection" === e ? t : void 0 : null
            }
            e.exports = i;
            var r = {
                Point: "geometry",
                MultiPoint: "geometry",
                LineString: "geometry",
                MultiLineString: "geometry",
                Polygon: "geometry",
                MultiPolygon: "geometry",
                GeometryCollection: "geometry",
                Feature: "feature",
                FeatureCollection: "featurecollection"
            }
        }
        , {}],
        3: [function(t, e, n) {
            function i(t, e) {
                var n, i = [];
                if ("object" == typeof t)
                    n = t;
                else {
                    if ("string" != typeof t)
                        return [{
                            message: "Expected string or object as input",
                            line: 0
                        }];
                    try {
                        n = r.parse(t)
                    } catch (t) {
                        var s = t.message.match(/line (\d+)/)
                          , a = parseInt(s[1], 10);
                        return [{
                            line: a - 1,
                            message: t.message,
                            error: t
                        }]
                    }
                }
                return i = i.concat(o.hint(n, e))
            }
            var r = t("jsonlint-lines")
              , o = t("./object");
            e.exports.hint = i
        }
        , {
            "./object": 4,
            "jsonlint-lines": 52
        }],
        4: [function(t, e, n) {
            function i(t, e) {
                function n(t) {
                    if (e && !1 === e.noDuplicateMembers || !t.__duplicateProperties__ || x.push({
                        message: "An object contained duplicate members, making parsing ambigous: " + t.__duplicateProperties__.join(", "),
                        line: t.__line__
                    }),
                    !o(t, "type", "string"))
                        if (w[t.type])
                            t && w[t.type](t);
                        else {
                            var n = _[t.type.toLowerCase()];
                            void 0 !== n ? x.push({
                                message: "Expected " + n + " but got " + t.type + " (case sensitive)",
                                line: t.__line__
                            }) : x.push({
                                message: "The type " + t.type + " is unknown",
                                line: t.__line__
                            })
                        }
                }
                function i(t, e) {
                    return t.every(function(t) {
                        return null !== t && typeof t === e
                    })
                }
                function o(t, e, n) {
                    if (void 0 === t[e])
                        return x.push({
                            message: '"' + e + '" member required',
                            line: t.__line__
                        });
                    if ("array" === n) {
                        if (!Array.isArray(t[e]))
                            return x.push({
                                message: '"' + e + '" member should be an array, but is an ' + typeof t[e] + " instead",
                                line: t.__line__
                            })
                    } else {
                        if ("object" === n && t[e] && "Object" !== t[e].constructor.name)
                            return x.push({
                                message: '"' + e + '" member should be ' + n + ", but is an " + t[e].constructor.name + " instead",
                                line: t.__line__
                            });
                        if (n && typeof t[e] !== n)
                            return x.push({
                                message: '"' + e + '" member should be ' + n + ", but is an " + typeof t[e] + " instead",
                                line: t.__line__
                            })
                    }
                }
                function s(t) {
                    if (l(t),
                    c(t),
                    void 0 !== t.properties && x.push({
                        message: 'FeatureCollection object cannot contain a "properties" member',
                        line: t.__line__
                    }),
                    void 0 !== t.coordinates && x.push({
                        message: 'FeatureCollection object cannot contain a "coordinates" member',
                        line: t.__line__
                    }),
                    !o(t, "features", "array")) {
                        if (!i(t.features, "object"))
                            return x.push({
                                message: "Every feature must be an object",
                                line: t.__line__
                            });
                        t.features.forEach(E)
                    }
                }
                function a(t, n) {
                    if (!Array.isArray(t))
                        return x.push({
                            message: "position should be an array, is a " + typeof t + " instead",
                            line: t.__line__ || n
                        });
                    if (t.length < 2)
                        return x.push({
                            message: "position must have 2 or more elements",
                            line: t.__line__ || n
                        });
                    if (t.length > 3)
                        return x.push({
                            message: "position should not have more than 3 elements",
                            level: "message",
                            line: t.__line__ || n
                        });
                    if (!i(t, "number"))
                        return x.push({
                            message: "each element in a position must be a number",
                            line: t.__line__ || n
                        });
                    if (e && e.precisionWarning) {
                        if (I === N)
                            return I += 1,
                            x.push({
                                message: "truncated warnings: we've encountered coordinate precision warning " + N + " times, no more warnings will be reported",
                                level: "message",
                                line: t.__line__ || n
                            });
                        I < N && t.forEach(function(e) {
                            var i = 0
                              , r = String(e).split(".")[1];
                            if (void 0 !== r && (i = r.length),
                            i > C)
                                return I += 1,
                                x.push({
                                    message: "precision of coordinates should be reduced",
                                    level: "message",
                                    line: t.__line__ || n
                                })
                        })
                    }
                }
                function u(t, e, n, i) {
                    if (void 0 === i && void 0 !== t.__line__ && (i = t.__line__),
                    0 === n)
                        return a(t, i);
                    if (1 === n && e)
                        if ("LinearRing" === e) {
                            if (!Array.isArray(t[t.length - 1]))
                                return x.push({
                                    message: "a number was found where a coordinate array should have been found: this needs to be nested more deeply",
                                    line: i
                                }),
                                !0;
                            if (t.length < 4 && x.push({
                                message: "a LinearRing of coordinates needs to have four or more positions",
                                line: i
                            }),
                            t.length && (t[t.length - 1].length !== t[0].length || !t[t.length - 1].every(function(e, n) {
                                return t[0][n] === e
                            })))
                                return x.push({
                                    message: "the first and last positions in a LinearRing of coordinates must be the same",
                                    line: i
                                }),
                                !0
                        } else if ("Line" === e && t.length < 2)
                            return x.push({
                                message: "a line needs to have two or more coordinates to be valid",
                                line: i
                            });
                    if (Array.isArray(t)) {
                        return t.map(function(t) {
                            return u(t, e, n - 1, t.__line__ || i)
                        }).some(function(t) {
                            return t
                        })
                    }
                    x.push({
                        message: "a number was found where a coordinate array should have been found: this needs to be nested more deeply",
                        line: i
                    })
                }
                function l(t) {
                    if (t.crs) {
                        "object" == typeof t.crs && t.crs.properties && "urn:ogc:def:crs:OGC:1.3:CRS84" === t.crs.properties.name ? x.push({
                            message: "old-style crs member is not recommended, this object is equivalent to the default and should be removed",
                            line: t.__line__
                        }) : x.push({
                            message: "old-style crs member is not recommended",
                            line: t.__line__
                        })
                    }
                }
                function c(t) {
                    if (t.bbox)
                        return Array.isArray(t.bbox) ? (i(t.bbox, "number") || x.push({
                            message: "each element in a bbox member must be a number",
                            line: t.bbox.__line__
                        }),
                        4 !== t.bbox.length && 6 !== t.bbox.length && x.push({
                            message: "bbox must contain 4 elements (for 2D) or 6 elements (for 3D)",
                            line: t.bbox.__line__
                        }),
                        x.length) : void x.push({
                            message: "bbox member must be an array of numbers, but is a " + typeof t.bbox,
                            line: t.__line__
                        })
                }
                function h(t) {
                    void 0 !== t.properties && x.push({
                        message: 'geometry object cannot contain a "properties" member',
                        line: t.__line__
                    }),
                    void 0 !== t.geometry && x.push({
                        message: 'geometry object cannot contain a "geometry" member',
                        line: t.__line__
                    }),
                    void 0 !== t.features && x.push({
                        message: 'geometry object cannot contain a "features" member',
                        line: t.__line__
                    })
                }
                function f(t) {
                    l(t),
                    c(t),
                    h(t),
                    o(t, "coordinates", "array") || a(t.coordinates)
                }
                function d(t) {
                    l(t),
                    c(t),
                    o(t, "coordinates", "array") || u(t.coordinates, "LinearRing", 2) || r(t, x)
                }
                function g(t) {
                    l(t),
                    c(t),
                    o(t, "coordinates", "array") || u(t.coordinates, "LinearRing", 3) || r(t, x)
                }
                function p(t) {
                    l(t),
                    c(t),
                    o(t, "coordinates", "array") || u(t.coordinates, "Line", 1)
                }
                function m(t) {
                    l(t),
                    c(t),
                    o(t, "coordinates", "array") || u(t.coordinates, "Line", 2)
                }
                function y(t) {
                    l(t),
                    c(t),
                    o(t, "coordinates", "array") || u(t.coordinates, "", 1)
                }
                function v(t) {
                    l(t),
                    c(t),
                    o(t, "geometries", "array") || (i(t.geometries, "object") || x.push({
                        message: "The geometries array in a GeometryCollection must contain only geometry objects",
                        line: t.__line__
                    }),
                    1 === t.geometries.length && x.push({
                        message: "GeometryCollection with a single geometry should be avoided in favor of single part or a single object of multi-part type",
                        line: t.geometries.__line__
                    }),
                    t.geometries.forEach(function(e) {
                        e && ("GeometryCollection" === e.type && x.push({
                            message: "GeometryCollection should avoid nested geometry collections",
                            line: t.geometries.__line__
                        }),
                        n(e))
                    }))
                }
                function E(t) {
                    l(t),
                    c(t),
                    void 0 !== t.id && "string" != typeof t.id && "number" != typeof t.id && x.push({
                        message: 'Feature "id" member must have a string or number value',
                        line: t.__line__
                    }),
                    void 0 !== t.features && x.push({
                        message: 'Feature object cannot contain a "features" member',
                        line: t.__line__
                    }),
                    void 0 !== t.coordinates && x.push({
                        message: 'Feature object cannot contain a "coordinates" member',
                        line: t.__line__
                    }),
                    "Feature" !== t.type && x.push({
                        message: "GeoJSON features must have a type=feature member",
                        line: t.__line__
                    }),
                    o(t, "properties", "object"),
                    o(t, "geometry", "object") || t.geometry && n(t.geometry)
                }
                var x = []
                  , I = 0
                  , N = 10
                  , C = 6
                  , w = {
                    Point: f,
                    Feature: E,
                    MultiPoint: y,
                    LineString: p,
                    MultiLineString: m,
                    FeatureCollection: s,
                    GeometryCollection: v,
                    Polygon: d,
                    MultiPolygon: g
                }
                  , _ = Object.keys(w).reduce(function(t, e) {
                    return t[e.toLowerCase()] = e,
                    t
                }, {});
                return "object" != typeof t || null === t || void 0 === t ? (x.push({
                    message: "The root of a GeoJSON object must be an object.",
                    line: 0
                }),
                x) : (n(t),
                x.forEach(function(t) {
                    ({}).hasOwnProperty.call(t, "line") && void 0 === t.line && delete t.line
                }),
                x)
            }
            var r = t("./rhr");
            e.exports.hint = i
        }
        , {
            "./rhr": 5
        }],
        5: [function(t, e, n) {
            function i(t) {
                return t * Math.PI / 180
            }
            function r(t) {
                var e = 0;
                if (t.length > 2)
                    for (var n, r, o = 0; o < t.length - 1; o++)
                        n = t[o],
                        r = t[o + 1],
                        e += i(r[0] - n[0]) * (2 + Math.sin(i(n[1])) + Math.sin(i(r[1])));
                return e >= 0
            }
            function o(t) {
                if (t && t.length > 0) {
                    if (r(t[0]))
                        return !1;
                    if (!t.slice(1, t.length).every(r))
                        return !1
                }
                return !0
            }
            function s(t) {
                return "Polygon" === t.type ? o(t.coordinates) : "MultiPolygon" === t.type ? t.coordinates.every(o) : void 0
            }
            e.exports = function(t, e) {
                s(t) || e.push({
                    message: "Polygons and MultiPolygons should follow the right-hand rule",
                    level: "message",
                    line: t.__line__
                })
            }
        }
        , {}],
        6: [function(t, e, n) {
            var i = t("@turf/helpers").polygon;
            e.exports = function(t) {
                var e = [t[0], t[1]]
                  , n = [t[0], t[3]]
                  , r = [t[2], t[3]]
                  , o = [t[2], t[1]];
                return i([[e, o, r, n, e]])
            }
        }
        , {
            "@turf/helpers": 19
        }],
        7: [function(t, e, n) {
            var i = t("@turf/meta").coordEach;
            e.exports = function(t) {
                var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                return i(t, function(t) {
                    e[0] > t[0] && (e[0] = t[0]),
                    e[1] > t[1] && (e[1] = t[1]),
                    e[2] < t[0] && (e[2] = t[0]),
                    e[3] < t[1] && (e[3] = t[1])
                }),
                e
            }
        }
        , {
            "@turf/meta": 8
        }],
        8: [function(t, e, n) {
            function i(t, e, n) {
                var r, o, s, a, u, l, c, h, f, d, g = 0, p = 0, m = "FeatureCollection" === t.type, y = "Feature" === t.type, v = m ? t.features.length : 1;
                for (r = 0; r < v; r++)
                    for (f = m ? t.features[r].geometry : y ? t.geometry : t,
                    d = "GeometryCollection" === f.type,
                    c = d ? f.geometries.length : 1,
                    a = 0; a < c; a++)
                        if (l = d ? f.geometries[a] : f,
                        h = l.coordinates,
                        g = !n || "Polygon" !== l.type && "MultiPolygon" !== l.type ? 0 : 1,
                        "Point" === l.type)
                            e(h, p),
                            p++;
                        else if ("LineString" === l.type || "MultiPoint" === l.type)
                            for (o = 0; o < h.length; o++)
                                e(h[o], p),
                                p++;
                        else if ("Polygon" === l.type || "MultiLineString" === l.type)
                            for (o = 0; o < h.length; o++)
                                for (s = 0; s < h[o].length - g; s++)
                                    e(h[o][s], p),
                                    p++;
                        else if ("MultiPolygon" === l.type)
                            for (o = 0; o < h.length; o++)
                                for (s = 0; s < h[o].length; s++)
                                    for (u = 0; u < h[o][s].length - g; u++)
                                        e(h[o][s][u], p),
                                        p++;
                        else {
                            if ("GeometryCollection" !== l.type)
                                throw new Error("Unknown Geometry Type");
                            for (o = 0; o < l.geometries.length; o++)
                                i(l.geometries[o], e, n)
                        }
            }
            function r(t, e, n, r) {
                var o = n;
                return i(t, function(t, i) {
                    o = 0 === i && void 0 === n ? t : e(o, t, i)
                }, r),
                o
            }
            function o(t, e) {
                var n;
                switch (t.type) {
                case "FeatureCollection":
                    for (n = 0; n < t.features.length; n++)
                        e(t.features[n].properties, n);
                    break;
                case "Feature":
                    e(t.properties, 0)
                }
            }
            function s(t, e, n) {
                var i = n;
                return o(t, function(t, r) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r)
                }),
                i
            }
            function a(t, e) {
                if ("Feature" === t.type)
                    e(t, 0);
                else if ("FeatureCollection" === t.type)
                    for (var n = 0; n < t.features.length; n++)
                        e(t.features[n], n)
            }
            function u(t, e, n) {
                var i = n;
                return a(t, function(t, r) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r)
                }),
                i
            }
            function l(t) {
                var e = [];
                return i(t, function(t) {
                    e.push(t)
                }),
                e
            }
            function c(t, e) {
                var n, i, r, o, s, a, u, l = 0, c = "FeatureCollection" === t.type, h = "Feature" === t.type, f = c ? t.features.length : 1;
                for (n = 0; n < f; n++)
                    for (a = c ? t.features[n].geometry : h ? t.geometry : t,
                    u = "GeometryCollection" === a.type,
                    s = u ? a.geometries.length : 1,
                    r = 0; r < s; r++)
                        if (o = u ? a.geometries[r] : a,
                        "Point" === o.type || "LineString" === o.type || "MultiPoint" === o.type || "Polygon" === o.type || "MultiLineString" === o.type || "MultiPolygon" === o.type)
                            e(o, l),
                            l++;
                        else {
                            if ("GeometryCollection" !== o.type)
                                throw new Error("Unknown Geometry Type");
                            for (i = 0; i < o.geometries.length; i++)
                                e(o.geometries[i], l),
                                l++
                        }
            }
            function h(t, e, n) {
                var i = n;
                return c(t, function(t, r) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r)
                }),
                i
            }
            e.exports.coordEach = i,
            e.exports.coordReduce = r,
            e.exports.propEach = o,
            e.exports.propReduce = s,
            e.exports.featureEach = a,
            e.exports.featureReduce = u,
            e.exports.coordAll = l,
            e.exports.geomEach = c,
            e.exports.geomReduce = h
        }
        , {}],
        9: [function(t, e, n) {
            function i(t, e, n) {
                if (!0 === n)
                    return r(t, e);
                var i = Math.PI / 180
                  , s = 180 / Math.PI
                  , a = o(t)
                  , u = o(e)
                  , l = i * a[0]
                  , c = i * u[0]
                  , h = i * a[1]
                  , f = i * u[1]
                  , d = Math.sin(c - l) * Math.cos(f)
                  , g = Math.cos(h) * Math.sin(f) - Math.sin(h) * Math.cos(f) * Math.cos(c - l);
                return s * Math.atan2(d, g)
            }
            function r(t, e) {
                var n = i(e, t);
                return n = (n + 180) % 360
            }
            var o = t("@turf/invariant").getCoord;
            e.exports = i
        }
        , {
            "@turf/invariant": 22
        }],
        10: [function(t, e, n) {
            var i = t("@turf/helpers").lineString
              , r = t("./spline.js");
            e.exports = function(t, e, n) {
                for (var o = [], s = new r({
                    points: t.geometry.coordinates.map(function(t) {
                        return {
                            x: t[0],
                            y: t[1]
                        }
                    }),
                    duration: e,
                    sharpness: n
                }), a = 0; a < s.duration; a += 10) {
                    var u = s.pos(a);
                    Math.floor(a / 100) % 2 == 0 && o.push([u.x, u.y])
                }
                return i(o, t.properties)
            }
        }
        , {
            "./spline.js": 11,
            "@turf/helpers": 19
        }],
        11: [function(t, e, n) {
            var i = function(t) {
                this.points = t.points || [],
                this.duration = t.duration || 1e4,
                this.sharpness = t.sharpness || .85,
                this.centers = [],
                this.controls = [],
                this.stepLength = t.stepLength || 60,
                this.length = this.points.length,
                this.delay = 0;
                for (var e = 0; e < this.length; e++)
                    this.points[e].z = this.points[e].z || 0;
                for (var e = 0; e < this.length - 1; e++) {
                    var n = this.points[e]
                      , i = this.points[e + 1];
                    this.centers.push({
                        x: (n.x + i.x) / 2,
                        y: (n.y + i.y) / 2,
                        z: (n.z + i.z) / 2
                    })
                }
                this.controls.push([this.points[0], this.points[0]]);
                for (var e = 0; e < this.centers.length - 1; e++) {
                    var n = this.centers[e]
                      , i = this.centers[e + 1]
                      , r = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2
                      , o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2
                      , s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;
                    this.controls.push([{
                        x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + r),
                        y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o),
                        z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s)
                    }, {
                        x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + r),
                        y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o),
                        z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s)
                    }])
                }
                return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]),
                this.steps = this.cacheSteps(this.stepLength),
                this
            };
            i.prototype.cacheSteps = function(t) {
                var e = []
                  , n = this.pos(0);
                e.push(0);
                for (var i = 0; i < this.duration; i += 10) {
                    var r = this.pos(i);
                    Math.sqrt((r.x - n.x) * (r.x - n.x) + (r.y - n.y) * (r.y - n.y) + (r.z - n.z) * (r.z - n.z)) > t && (e.push(i),
                    n = r)
                }
                return e
            }
            ,
            i.prototype.vector = function(t) {
                var e = this.pos(t + 10)
                  , n = this.pos(t - 10);
                return {
                    angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14,
                    speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z))
                }
            }
            ,
            i.prototype.pos = function(t) {
                var e = t - this.delay;
                e < 0 && (e = 0),
                e > this.duration && (e = this.duration - 1);
                var n = e / this.duration;
                if (n >= 1)
                    return this.points[this.length - 1];
                var i = Math.floor((this.points.length - 1) * n)
                  , r = (this.length - 1) * n - i;
                return function(t, e, n, i, r) {
                    var o = function(t) {
                        var e = t * t;
                        return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)]
                    }(t);
                    return {
                        x: r.x * o[0] + i.x * o[1] + n.x * o[2] + e.x * o[3],
                        y: r.y * o[0] + i.y * o[1] + n.y * o[2] + e.y * o[3],
                        z: r.z * o[0] + i.z * o[1] + n.z * o[2] + e.z * o[3]
                    }
                }(r, this.points[i], this.controls[i][1], this.controls[i + 1][0], this.points[i + 1])
            }
            ,
            e.exports = i
        }
        , {}],
        12: [function(t, e, n) {
            var i = t("@turf/destination")
              , r = t("@turf/helpers").polygon;
            e.exports = function(t, e, n, o, s) {
                if (!t)
                    throw new Error("center is required");
                if (!e)
                    throw new Error("radius is required");
                n = n || 64,
                s = s || t.properties || {};
                for (var a = [], u = 0; u < n; u++)
                    a.push(i(t, e, 360 * u / n, o).geometry.coordinates);
                return a.push(a[0]),
                r([a], s)
            }
        }
        , {
            "@turf/destination": 13,
            "@turf/helpers": 14
        }],
        13: [function(t, e, n) {
            var i = t("@turf/invariant").getCoord
              , r = t("@turf/helpers")
              , o = r.point
              , s = r.distanceToRadians;
            e.exports = function(t, e, n, r) {
                var a = Math.PI / 180
                  , u = 180 / Math.PI
                  , l = i(t)
                  , c = a * l[0]
                  , h = a * l[1]
                  , f = a * n
                  , d = s(e, r)
                  , g = Math.asin(Math.sin(h) * Math.cos(d) + Math.cos(h) * Math.sin(d) * Math.cos(f))
                  , p = c + Math.atan2(Math.sin(f) * Math.sin(d) * Math.cos(h), Math.cos(d) - Math.sin(h) * Math.sin(g));
                return o([u * p, u * g])
            }
        }
        , {
            "@turf/helpers": 14,
            "@turf/invariant": 15
        }],
        14: [function(t, e, n) {
            function i(t, e, n, i) {
                if (void 0 === t)
                    throw new Error("geometry is required");
                if (e && e.constructor !== Object)
                    throw new Error("properties must be an Object");
                var r = {
                    type: "Feature",
                    properties: e || {},
                    geometry: t
                };
                if (n) {
                    if (4 !== n.length)
                        throw new Error("bbox must be an Array of 4 numbers");
                    r.bbox = n
                }
                return i && (r.id = i),
                r
            }
            function r(t, e, n) {
                if (!t)
                    throw new Error("type is required");
                if (!e)
                    throw new Error("coordinates is required");
                if (!Array.isArray(e))
                    throw new Error("coordinates must be an Array");
                var i;
                switch (t) {
                case "Point":
                    i = o(e).geometry;
                    break;
                case "LineString":
                    i = a(e).geometry;
                    break;
                case "Polygon":
                    i = s(e).geometry;
                    break;
                case "MultiPoint":
                    i = c(e).geometry;
                    break;
                case "MultiLineString":
                    i = l(e).geometry;
                    break;
                case "MultiPolygon":
                    i = h(e).geometry;
                    break;
                default:
                    throw new Error(t + " is invalid")
                }
                if (n) {
                    if (4 !== n.length)
                        throw new Error("bbox must be an Array of 4 numbers");
                    i.bbox = n
                }
                return i
            }
            function o(t, e, n, r) {
                if (!t)
                    throw new Error("No coordinates passed");
                if (void 0 === t.length)
                    throw new Error("Coordinates must be an array");
                if (t.length < 2)
                    throw new Error("Coordinates must be at least 2 numbers long");
                if ("number" != typeof t[0] || "number" != typeof t[1])
                    throw new Error("Coordinates must contain numbers");
                return i({
                    type: "Point",
                    coordinates: t
                }, e, n, r)
            }
            function s(t, e, n, r) {
                if (!t)
                    throw new Error("No coordinates passed");
                for (var o = 0; o < t.length; o++) {
                    var s = t[o];
                    if (s.length < 4)
                        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                    for (var a = 0; a < s[s.length - 1].length; a++)
                        if (s[s.length - 1][a] !== s[0][a])
                            throw new Error("First and last Position are not equivalent.")
                }
                return i({
                    type: "Polygon",
                    coordinates: t
                }, e, n, r)
            }
            function a(t, e, n, r) {
                if (!t)
                    throw new Error("No coordinates passed");
                if (t.length < 2)
                    throw new Error("Coordinates must be an array of two or more positions");
                return i({
                    type: "LineString",
                    coordinates: t
                }, e, n, r)
            }
            function u(t, e) {
                if (!t)
                    throw new Error("No features passed");
                if (!Array.isArray(t))
                    throw new Error("features must be an Array");
                var n = {
                    type: "FeatureCollection",
                    features: t
                };
                return e && (n.bbox = e),
                n
            }
            function l(t, e, n, r) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiLineString",
                    coordinates: t
                }, e, n, r)
            }
            function c(t, e, n, r) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiPoint",
                    coordinates: t
                }, e, n, r)
            }
            function h(t, e, n, r) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiPolygon",
                    coordinates: t
                }, e, n, r)
            }
            function f(t, e, n, r) {
                if (!t)
                    throw new Error("geometries is required");
                if (!Array.isArray(t))
                    throw new Error("geometries must be an Array");
                return i({
                    type: "GeometryCollection",
                    geometries: t
                }, e, n, r)
            }
            function d(t, e) {
                if (void 0 === t || null === t || isNaN(t))
                    throw new Error("num is required");
                if (e && !(e >= 0))
                    throw new Error("precision must be a positive number");
                var n = Math.pow(10, e || 0);
                return Math.round(t * n) / n
            }
            function g(t, e) {
                if (void 0 === t || null === t)
                    throw new Error("radians is required");
                var n = N[e || "kilometers"];
                if (!n)
                    throw new Error("units is invalid");
                return t * n
            }
            function p(t, e) {
                if (void 0 === t || null === t)
                    throw new Error("distance is required");
                var n = N[e || "kilometers"];
                if (!n)
                    throw new Error("units is invalid");
                return t / n
            }
            function m(t, e) {
                return v(p(t, e))
            }
            function y(t) {
                if (null === t || void 0 === t)
                    throw new Error("bearing is required");
                var e = t % 360;
                return e < 0 && (e += 360),
                e
            }
            function v(t) {
                if (null === t || void 0 === t)
                    throw new Error("radians is required");
                return t % (2 * Math.PI) * 180 / Math.PI
            }
            function E(t) {
                if (null === t || void 0 === t)
                    throw new Error("degrees is required");
                return t % 360 * Math.PI / 180
            }
            function x(t, e, n) {
                if (null === t || void 0 === t)
                    throw new Error("distance is required");
                if (!(t >= 0))
                    throw new Error("distance must be a positive number");
                return g(p(t, e), n || "kilometers")
            }
            function I(t, e, n) {
                if (null === t || void 0 === t)
                    throw new Error("area is required");
                if (!(t >= 0))
                    throw new Error("area must be a positive number");
                var i = C[e || "meters"];
                if (!i)
                    throw new Error("invalid original units");
                var r = C[n || "kilometers"];
                if (!r)
                    throw new Error("invalid final units");
                return t / i * r
            }
            var N = {
                miles: 3960,
                nauticalmiles: 3441.145,
                degrees: 57.2957795,
                radians: 1,
                inches: 250905600,
                yards: 6969600,
                meters: 6373e3,
                metres: 6373e3,
                centimeters: 6373e5,
                centimetres: 6373e5,
                kilometers: 6373,
                kilometres: 6373,
                feet: 20908792.65
            }
              , C = {
                kilometers: 1e-6,
                kilometres: 1e-6,
                meters: 1,
                metres: 1,
                centimetres: 1e4,
                millimeter: 1e6,
                acres: 247105e-9,
                miles: 3.86e-7,
                yards: 1.195990046,
                feet: 10.763910417,
                inches: 1550.003100006
            };
            e.exports = {
                feature: i,
                geometry: r,
                featureCollection: u,
                geometryCollection: f,
                point: o,
                multiPoint: c,
                lineString: a,
                multiLineString: l,
                polygon: s,
                multiPolygon: h,
                radiansToDistance: g,
                distanceToRadians: p,
                distanceToDegrees: m,
                radians2degrees: v,
                degrees2radians: E,
                bearingToAngle: y,
                convertDistance: x,
                convertArea: I,
                round: d
            }
        }
        , {}],
        15: [function(t, e, n) {
            function i(t) {
                if (!t)
                    throw new Error("obj is required");
                var e = r(t);
                if (e.length > 1 && "number" == typeof e[0] && "number" == typeof e[1])
                    return e;
                throw new Error("Coordinate is not a valid Point")
            }
            function r(t) {
                if (!t)
                    throw new Error("obj is required");
                var e;
                if (t.length ? e = t : t.coordinates ? e = t.coordinates : t.geometry && t.geometry.coordinates && (e = t.geometry.coordinates),
                e)
                    return o(e),
                    e;
                throw new Error("No valid coordinates")
            }
            function o(t) {
                if (t.length > 1 && "number" == typeof t[0] && "number" == typeof t[1])
                    return !0;
                if (Array.isArray(t[0]) && t[0].length)
                    return o(t[0]);
                throw new Error("coordinates must only contain numbers")
            }
            function s(t, e, n) {
                if (!e || !n)
                    throw new Error("type and name required");
                if (!t || t.type !== e)
                    throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
            }
            function a(t, e, n) {
                if (!t)
                    throw new Error("No feature passed");
                if (!n)
                    throw new Error(".featureOf() requires a name");
                if (!t || "Feature" !== t.type || !t.geometry)
                    throw new Error("Invalid input to " + n + ", Feature with geometry required");
                if (!t.geometry || t.geometry.type !== e)
                    throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
            }
            function u(t, e, n) {
                if (!t)
                    throw new Error("No featureCollection passed");
                if (!n)
                    throw new Error(".collectionOf() requires a name");
                if (!t || "FeatureCollection" !== t.type)
                    throw new Error("Invalid input to " + n + ", FeatureCollection required");
                for (var i = 0; i < t.features.length; i++) {
                    var r = t.features[i];
                    if (!r || "Feature" !== r.type || !r.geometry)
                        throw new Error("Invalid input to " + n + ", Feature with geometry required");
                    if (!r.geometry || r.geometry.type !== e)
                        throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + r.geometry.type)
                }
            }
            function l(t) {
                if (!t)
                    throw new Error("geojson is required");
                if (void 0 !== t.geometry)
                    return t.geometry;
                if (t.coordinates || t.geometries)
                    return t;
                throw new Error("geojson must be a valid Feature or Geometry Object")
            }
            function c(t) {
                if (!t)
                    throw new Error("geojson is required");
                var e = l(t);
                if (e)
                    return e.type
            }
            e.exports = {
                geojsonType: s,
                collectionOf: u,
                featureOf: a,
                getCoord: i,
                getCoords: r,
                containsNumber: o,
                getGeom: l,
                getGeomType: c
            }
        }
        , {}],
        16: [function(t, e, n) {
            var i = t("@turf/invariant").getCoord
              , r = t("@turf/helpers")
              , o = r.point
              , s = r.distanceToRadians;
            e.exports = function(t, e, n, r) {
                var a = Math.PI / 180
                  , u = 180 / Math.PI
                  , l = i(t)
                  , c = a * l[0]
                  , h = a * l[1]
                  , f = a * n
                  , d = s(e, r)
                  , g = Math.asin(Math.sin(h) * Math.cos(d) + Math.cos(h) * Math.sin(d) * Math.cos(f))
                  , p = c + Math.atan2(Math.sin(f) * Math.sin(d) * Math.cos(h), Math.cos(d) - Math.sin(h) * Math.sin(g));
                return o([u * p, u * g])
            }
        }
        , {
            "@turf/helpers": 19,
            "@turf/invariant": 22
        }],
        17: [function(t, e, n) {
            var i = t("@turf/invariant").getCoord
              , r = t("@turf/helpers").radiansToDistance;
            e.exports = function(t, e, n) {
                var o = Math.PI / 180
                  , s = i(t)
                  , a = i(e)
                  , u = o * (a[1] - s[1])
                  , l = o * (a[0] - s[0])
                  , c = o * s[1]
                  , h = o * a[1]
                  , f = Math.pow(Math.sin(u / 2), 2) + Math.pow(Math.sin(l / 2), 2) * Math.cos(c) * Math.cos(h);
                return r(2 * Math.atan2(Math.sqrt(f), Math.sqrt(1 - f)), n)
            }
        }
        , {
            "@turf/helpers": 19,
            "@turf/invariant": 22
        }],
        18: [function(t, e, n) {
            function i(t) {
                if (!t)
                    throw new Error("geojson is required");
                var e = [];
                return r(t, function(t) {
                    e.push(t)
                }),
                o(e)
            }
            var r = t("@turf/meta").flattenEach
              , o = t("@turf/helpers").featureCollection;
            e.exports = i
        }
        , {
            "@turf/helpers": 19,
            "@turf/meta": 32
        }],
        19: [function(t, e, n) {
            function i(t, e) {
                if (!t)
                    throw new Error("No geometry passed");
                return {
                    type: "Feature",
                    properties: e || {},
                    geometry: t
                }
            }
            function r(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                if (void 0 === t.length)
                    throw new Error("Coordinates must be an array");
                if (t.length < 2)
                    throw new Error("Coordinates must be at least 2 numbers long");
                if ("number" != typeof t[0] || "number" != typeof t[1])
                    throw new Error("Coordinates must contain numbers");
                return i({
                    type: "Point",
                    coordinates: t
                }, e)
            }
            function o(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    if (r.length < 4)
                        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                    for (var o = 0; o < r[r.length - 1].length; o++)
                        if (r[r.length - 1][o] !== r[0][o])
                            throw new Error("First and last Position are not equivalent.")
                }
                return i({
                    type: "Polygon",
                    coordinates: t
                }, e)
            }
            function s(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                if (t.length < 2)
                    throw new Error("Coordinates must be an array of two or more positions");
                return i({
                    type: "LineString",
                    coordinates: t
                }, e)
            }
            function a(t) {
                if (!t)
                    throw new Error("No features passed");
                if (!Array.isArray(t))
                    throw new Error("features must be an Array");
                return {
                    type: "FeatureCollection",
                    features: t
                }
            }
            function u(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiLineString",
                    coordinates: t
                }, e)
            }
            function l(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiPoint",
                    coordinates: t
                }, e)
            }
            function c(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiPolygon",
                    coordinates: t
                }, e)
            }
            function h(t, e) {
                if (!t)
                    throw new Error("geometries is required");
                return i({
                    type: "GeometryCollection",
                    geometries: t
                }, e)
            }
            function f(t, e) {
                if (void 0 === t || null === t || isNaN(t))
                    throw new Error("num is required");
                if (e && !(e >= 0))
                    throw new Error("precision must be a positive number");
                var n = Math.pow(10, e || 0);
                return Math.round(t * n) / n
            }
            function d(t, e) {
                if (void 0 === t || null === t)
                    throw new Error("radians is required");
                var n = I[e || "kilometers"];
                if (!n)
                    throw new Error("units is invalid");
                return t * n
            }
            function g(t, e) {
                if (void 0 === t || null === t)
                    throw new Error("distance is required");
                var n = I[e || "kilometers"];
                if (!n)
                    throw new Error("units is invalid");
                return t / n
            }
            function p(t, e) {
                return y(g(t, e))
            }
            function m(t) {
                if (null === t || void 0 === t)
                    throw new Error("bearing is required");
                var e = t % 360;
                return e < 0 && (e += 360),
                e
            }
            function y(t) {
                if (null === t || void 0 === t)
                    throw new Error("radians is required");
                return t % (2 * Math.PI) * 180 / Math.PI
            }
            function v(t) {
                if (null === t || void 0 === t)
                    throw new Error("degrees is required");
                return t % 360 * Math.PI / 180
            }
            function E(t, e, n) {
                if (null === t || void 0 === t)
                    throw new Error("distance is required");
                if (!(t >= 0))
                    throw new Error("distance must be a positive number");
                return d(g(t, e), n || "kilometers")
            }
            function x(t, e, n) {
                if (null === t || void 0 === t)
                    throw new Error("area is required");
                if (!(t >= 0))
                    throw new Error("area must be a positive number");
                var i = N[e || "meters"];
                if (!i)
                    throw new Error("invalid original units");
                var r = N[n || "kilometers"];
                if (!r)
                    throw new Error("invalid final units");
                return t / i * r
            }
            var I = {
                miles: 3960,
                nauticalmiles: 3441.145,
                degrees: 57.2957795,
                radians: 1,
                inches: 250905600,
                yards: 6969600,
                meters: 6373e3,
                metres: 6373e3,
                centimeters: 6373e5,
                centimetres: 6373e5,
                kilometers: 6373,
                kilometres: 6373,
                feet: 20908792.65
            }
              , N = {
                kilometers: 1e-6,
                kilometres: 1e-6,
                meters: 1,
                metres: 1,
                centimetres: 1e4,
                millimeter: 1e6,
                acres: 247105e-9,
                miles: 3.86e-7,
                yards: 1.195990046,
                feet: 10.763910417,
                inches: 1550.003100006
            };
            e.exports = {
                feature: i,
                featureCollection: a,
                geometryCollection: h,
                point: r,
                multiPoint: l,
                lineString: s,
                multiLineString: u,
                polygon: o,
                multiPolygon: c,
                radiansToDistance: d,
                distanceToRadians: g,
                distanceToDegrees: p,
                radians2degrees: y,
                degrees2radians: v,
                bearingToAngle: m,
                convertDistance: E,
                convertArea: x,
                round: f
            }
        }
        , {}],
        20: [function(t, e, n) {
            var i = t("jsts");
            e.exports = function(t, e) {
                var n, r;
                n = "Feature" === t.type ? t.geometry : t,
                r = "Feature" === e.type ? e.geometry : e;
                var o = new i.io.GeoJSONReader
                  , s = o.read(JSON.stringify(n))
                  , a = o.read(JSON.stringify(r))
                  , u = s.intersection(a);
                if (!u.isEmpty()) {
                    return {
                        type: "Feature",
                        properties: {},
                        geometry: (new i.io.GeoJSONWriter).write(u)
                    }
                }
            }
        }
        , {
            jsts: 21
        }],
        21: [function(e, n, i) {
            !function(e, r) {
                "object" == typeof i && void 0 !== n ? r(i) : "function" == typeof t && t.amd ? t(["exports"], r) : r(e.jsts = e.jsts || {})
            }(this, function(t) {
                "use strict";
                function e(t, e) {
                    for (var n in e)
                        e.hasOwnProperty(n) && (t[n] = e[n])
                }
                function n() {}
                function i() {}
                function r() {}
                function o() {}
                function s() {}
                function a() {}
                function u() {}
                function l(t) {
                    this.name = "RuntimeException",
                    this.message = t,
                    this.stack = (new Error).stack,
                    Error.call(this, t)
                }
                function c(t, e) {
                    t.prototype = Object.create(e.prototype),
                    t.prototype.constructor = t
                }
                function h() {
                    if (0 === arguments.length)
                        l.call(this);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        l.call(this, t)
                    }
                }
                function f() {}
                function d() {
                    if (this.x = null,
                    this.y = null,
                    this.z = null,
                    0 === arguments.length)
                        d.call(this, 0, 0);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        d.call(this, t.x, t.y, t.z)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        d.call(this, e, n, d.NULL_ORDINATE)
                    } else if (3 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2];
                        this.x = i,
                        this.y = r,
                        this.z = o
                    }
                }
                function g() {
                    if (this.dimensionsToTest = 2,
                    0 === arguments.length)
                        g.call(this, 2);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        if (2 !== t && 3 !== t)
                            throw new i("only 2 or 3 dimensions may be specified");
                        this.dimensionsToTest = t
                    }
                }
                function p() {}
                function m() {}
                function y(t) {
                    this.message = t || ""
                }
                function v() {}
                function E(t) {
                    this.message = t || ""
                }
                function x(t) {
                    this.message = t || ""
                }
                function I() {
                    this.array_ = [],
                    arguments[0]instanceof m && this.addAll(arguments[0])
                }
                function N() {
                    if (I.apply(this),
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.ensureCapacity(t.length),
                        this.add(t, !0)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.ensureCapacity(e.length),
                        this.add(e, n)
                    }
                }
                function C() {
                    if (this.minx = null,
                    this.maxx = null,
                    this.miny = null,
                    this.maxy = null,
                    0 === arguments.length)
                        this.init();
                    else if (1 === arguments.length) {
                        if (arguments[0]instanceof d) {
                            var t = arguments[0];
                            this.init(t.x, t.x, t.y, t.y)
                        } else if (arguments[0]instanceof C) {
                            var e = arguments[0];
                            this.init(e)
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1];
                        this.init(n.x, i.x, n.y, i.y)
                    } else if (4 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2]
                          , a = arguments[3];
                        this.init(r, o, s, a)
                    }
                }
                function w() {}
                function _() {
                    w.call(this, "Projective point not representable on the Cartesian plane.")
                }
                function S() {}
                function b(t, e) {
                    return t.interfaces_ && t.interfaces_().indexOf(e) > -1
                }
                function L() {}
                function T(t) {
                    this.str = t
                }
                function R(t) {
                    this.value = t
                }
                function O() {}
                function P() {
                    if (this.hi = 0,
                    this.lo = 0,
                    0 === arguments.length)
                        this.init(0);
                    else if (1 === arguments.length) {
                        if ("number" == typeof arguments[0]) {
                            var t = arguments[0];
                            this.init(t)
                        } else if (arguments[0]instanceof P) {
                            var e = arguments[0];
                            this.init(e)
                        } else if ("string" == typeof arguments[0]) {
                            var n = arguments[0];
                            P.call(this, P.parse(n))
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1];
                        this.init(i, r)
                    }
                }
                function M() {}
                function A() {}
                function D() {}
                function F() {
                    if (this.x = null,
                    this.y = null,
                    this.w = null,
                    0 === arguments.length)
                        this.x = 0,
                        this.y = 0,
                        this.w = 1;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.x = t.x,
                        this.y = t.y,
                        this.w = 1
                    } else if (2 === arguments.length) {
                        if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                            var e = arguments[0]
                              , n = arguments[1];
                            this.x = e,
                            this.y = n,
                            this.w = 1
                        } else if (arguments[0]instanceof F && arguments[1]instanceof F) {
                            var i = arguments[0]
                              , r = arguments[1];
                            this.x = i.y * r.w - r.y * i.w,
                            this.y = r.x * i.w - i.x * r.w,
                            this.w = i.x * r.y - r.x * i.y
                        } else if (arguments[0]instanceof d && arguments[1]instanceof d) {
                            var o = arguments[0]
                              , s = arguments[1];
                            this.x = o.y - s.y,
                            this.y = s.x - o.x,
                            this.w = o.x * s.y - s.x * o.y
                        }
                    } else if (3 === arguments.length) {
                        var a = arguments[0]
                          , u = arguments[1]
                          , l = arguments[2];
                        this.x = a,
                        this.y = u,
                        this.w = l
                    } else if (4 === arguments.length) {
                        var c = arguments[0]
                          , h = arguments[1]
                          , f = arguments[2]
                          , g = arguments[3]
                          , p = c.y - h.y
                          , m = h.x - c.x
                          , y = c.x * h.y - h.x * c.y
                          , v = f.y - g.y
                          , E = g.x - f.x
                          , x = f.x * g.y - g.x * f.y;
                        this.x = m * x - E * y,
                        this.y = v * y - p * x,
                        this.w = p * E - v * m
                    }
                }
                function G() {}
                function k() {}
                function q() {
                    this.envelope = null,
                    this.factory = null,
                    this.SRID = null,
                    this.userData = null;
                    var t = arguments[0];
                    this.factory = t,
                    this.SRID = t.getSRID()
                }
                function B() {}
                function U() {}
                function V() {}
                function z() {}
                function j() {}
                function Y() {}
                function X() {}
                function H() {}
                function W() {}
                function J() {}
                function $() {}
                function K() {}
                function Z() {
                    this.array_ = [],
                    arguments[0]instanceof m && this.addAll(arguments[0])
                }
                function Q(t) {
                    return null == t ? Qo : t.color
                }
                function tt(t) {
                    return null == t ? null : t.parent
                }
                function et(t, e) {
                    null !== t && (t.color = e)
                }
                function nt(t) {
                    return null == t ? null : t.left
                }
                function it(t) {
                    return null == t ? null : t.right
                }
                function rt() {
                    this.root_ = null,
                    this.size_ = 0
                }
                function ot() {}
                function st() {}
                function at() {
                    this.array_ = [],
                    arguments[0]instanceof m && this.addAll(arguments[0])
                }
                function ut() {}
                function lt() {}
                function ct() {}
                function ht() {}
                function ft() {
                    this.geometries = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    if (q.call(this, e),
                    null === t && (t = []),
                    q.hasNullElements(t))
                        throw new i("geometries must not contain null elements");
                    this.geometries = t
                }
                function dt() {
                    var t = arguments[0]
                      , e = arguments[1];
                    ft.call(this, t, e)
                }
                function gt() {
                    if (this.geom = null,
                    this.geomFact = null,
                    this.bnRule = null,
                    this.endpointMap = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        gt.call(this, t, U.MOD2_BOUNDARY_RULE)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.geom = e,
                        this.geomFact = e.getFactory(),
                        this.bnRule = n
                    }
                }
                function pt() {
                    this.count = null
                }
                function mt() {}
                function yt() {}
                function vt() {}
                function Et() {}
                function xt() {}
                function It() {}
                function Nt() {}
                function Ct() {}
                function wt() {
                    this.points = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    q.call(this, e),
                    this.init(t)
                }
                function _t() {}
                function St() {
                    this.coordinates = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    q.call(this, e),
                    this.init(t)
                }
                function bt() {}
                function Lt() {
                    this.shell = null,
                    this.holes = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    if (q.call(this, n),
                    null === t && (t = this.getFactory().createLinearRing()),
                    null === e && (e = []),
                    q.hasNullElements(e))
                        throw new i("holes must not contain null elements");
                    if (t.isEmpty() && q.hasNonEmptyElements(e))
                        throw new i("shell is empty but holes are not");
                    this.shell = t,
                    this.holes = e
                }
                function Tt() {
                    var t = arguments[0]
                      , e = arguments[1];
                    ft.call(this, t, e)
                }
                function Rt() {
                    if (arguments[0]instanceof d && arguments[1]instanceof ne) {
                        var t = arguments[0]
                          , e = arguments[1];
                        Rt.call(this, e.getCoordinateSequenceFactory().create(t), e)
                    } else if (b(arguments[0], A) && arguments[1]instanceof ne) {
                        var n = arguments[0]
                          , i = arguments[1];
                        wt.call(this, n, i),
                        this.validateConstruction()
                    }
                }
                function Ot() {
                    var t = arguments[0]
                      , e = arguments[1];
                    ft.call(this, t, e)
                }
                function Pt() {
                    if (this.factory = null,
                    this.isUserDataCopied = !1,
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.factory = t
                    }
                }
                function Mt() {}
                function At() {}
                function Dt() {}
                function Ft() {}
                function Gt() {
                    if (this.dimension = 3,
                    this.coordinates = null,
                    1 === arguments.length) {
                        if (arguments[0]instanceof Array) {
                            var t = arguments[0];
                            Gt.call(this, t, 3)
                        } else if (Number.isInteger(arguments[0])) {
                            var e = arguments[0];
                            this.coordinates = new Array(e).fill(null);
                            for (var n = 0; n < e; n++)
                                this.coordinates[n] = new d
                        } else if (b(arguments[0], A)) {
                            var i = arguments[0];
                            if (null === i)
                                return this.coordinates = new Array(0).fill(null),
                                null;
                            this.dimension = i.getDimension(),
                            this.coordinates = new Array(i.size()).fill(null);
                            for (var n = 0; n < this.coordinates.length; n++)
                                this.coordinates[n] = i.getCoordinateCopy(n)
                        }
                    } else if (2 === arguments.length)
                        if (arguments[0]instanceof Array && Number.isInteger(arguments[1])) {
                            var r = arguments[0]
                              , o = arguments[1];
                            this.coordinates = r,
                            this.dimension = o,
                            null === r && (this.coordinates = new Array(0).fill(null))
                        } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                            var s = arguments[0]
                              , a = arguments[1];
                            this.coordinates = new Array(s).fill(null),
                            this.dimension = a;
                            for (var n = 0; n < s; n++)
                                this.coordinates[n] = new d
                        }
                }
                function kt() {}
                function qt(t, e) {
                    return t === e || t !== t && e !== e
                }
                function Bt(t) {
                    this.add ? t.forEach(this.add, this) : t.forEach(function(t) {
                        this.set(t[0], t[1])
                    }, this)
                }
                function Ut(t) {
                    return this.has(t) && (this._keys.splice(es, 1),
                    this._values.splice(es, 1),
                    this._itp.forEach(function(t) {
                        es < t[0] && t[0]--
                    })),
                    es > -1
                }
                function Vt(t) {
                    return this.has(t) ? this._values[es] : void 0
                }
                function zt(t, e) {
                    if (this.objectOnly && e !== Object(e))
                        throw new TypeError("Invalid value used as weak collection key");
                    if (e !== e || 0 === e)
                        for (es = t.length; es-- && !qt(t[es], e); )
                            ;
                    else
                        es = t.indexOf(e);
                    return es > -1
                }
                function jt(t) {
                    return zt.call(this, this._keys, t)
                }
                function Yt(t, e) {
                    return this.has(t) ? this._values[es] = e : this._values[this._keys.push(t) - 1] = e,
                    this
                }
                function Xt() {
                    (this._keys || 0).length = this._values.length = 0
                }
                function Ht() {
                    return $t(this._itp, this._keys)
                }
                function Wt() {
                    return $t(this._itp, this._values)
                }
                function Jt() {
                    return $t(this._itp, this._keys, this._values)
                }
                function $t(t, e, n) {
                    var i = [0]
                      , r = !1;
                    return t.push(i),
                    {
                        next: function() {
                            var o, s = i[0];
                            return !r && s < e.length ? (o = n ? [e[s], n[s]] : e[s],
                            i[0]++) : (r = !0,
                            t.splice(t.indexOf(i), 1)),
                            {
                                done: r,
                                value: o
                            }
                        }
                    }
                }
                function Kt() {
                    return this._values.length
                }
                function Zt(t, e) {
                    for (var n = this.entries(); ; ) {
                        var i = n.next();
                        if (i.done)
                            break;
                        t.call(e, i.value[1], i.value[0], this)
                    }
                }
                function Qt() {
                    this.map_ = new rs
                }
                function te() {
                    if (this.modelType = null,
                    this.scale = null,
                    0 === arguments.length)
                        this.modelType = te.FLOATING;
                    else if (1 === arguments.length)
                        if (arguments[0]instanceof ee) {
                            var t = arguments[0];
                            this.modelType = t,
                            t === te.FIXED && this.setScale(1)
                        } else if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            this.modelType = te.FIXED,
                            this.setScale(e)
                        } else if (arguments[0]instanceof te) {
                            var n = arguments[0];
                            this.modelType = n.modelType,
                            this.scale = n.scale
                        }
                }
                function ee() {
                    this.name = null;
                    var t = arguments[0];
                    this.name = t,
                    ee.nameToTypeMap.put(t, this)
                }
                function ne() {
                    if (this.precisionModel = null,
                    this.coordinateSequenceFactory = null,
                    this.SRID = null,
                    0 === arguments.length)
                        ne.call(this, new te, 0);
                    else if (1 === arguments.length) {
                        if (b(arguments[0], G)) {
                            var t = arguments[0];
                            ne.call(this, new te, 0, t)
                        } else if (arguments[0]instanceof te) {
                            var e = arguments[0];
                            ne.call(this, e, 0, ne.getDefaultCoordinateSequenceFactory())
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1];
                        ne.call(this, n, i, ne.getDefaultCoordinateSequenceFactory())
                    } else if (3 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2];
                        this.precisionModel = r,
                        this.coordinateSequenceFactory = s,
                        this.SRID = o
                    }
                }
                function ie(t) {
                    this.geometryFactory = t || new ne
                }
                function re(t) {
                    this.parser = new ie(t)
                }
                function oe() {
                    this.result = null,
                    this.inputLines = Array(2).fill().map(function() {
                        return Array(2)
                    }),
                    this.intPt = new Array(2).fill(null),
                    this.intLineIndex = null,
                    this._isProper = null,
                    this.pa = null,
                    this.pb = null,
                    this.precisionModel = null,
                    this.intPt[0] = new d,
                    this.intPt[1] = new d,
                    this.pa = this.intPt[0],
                    this.pb = this.intPt[1],
                    this.result = 0
                }
                function se() {
                    oe.apply(this)
                }
                function ae() {}
                function ue() {
                    this.p = null,
                    this.crossingCount = 0,
                    this.isPointOnSegment = !1;
                    var t = arguments[0];
                    this.p = t
                }
                function le() {}
                function ce() {
                    if (this.p0 = null,
                    this.p1 = null,
                    0 === arguments.length)
                        ce.call(this, new d, new d);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        ce.call(this, t.p0, t.p1)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.p0 = e,
                        this.p1 = n
                    } else if (4 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2]
                          , s = arguments[3];
                        ce.call(this, new d(i,r), new d(o,s))
                    }
                }
                function he() {
                    if (this.matrix = null,
                    0 === arguments.length)
                        this.matrix = Array(3).fill().map(function() {
                            return Array(3)
                        }),
                        this.setAll(lt.FALSE);
                    else if (1 === arguments.length)
                        if ("string" == typeof arguments[0]) {
                            var t = arguments[0];
                            he.call(this),
                            this.set(t)
                        } else if (arguments[0]instanceof he) {
                            var e = arguments[0];
                            he.call(this),
                            this.matrix[S.INTERIOR][S.INTERIOR] = e.matrix[S.INTERIOR][S.INTERIOR],
                            this.matrix[S.INTERIOR][S.BOUNDARY] = e.matrix[S.INTERIOR][S.BOUNDARY],
                            this.matrix[S.INTERIOR][S.EXTERIOR] = e.matrix[S.INTERIOR][S.EXTERIOR],
                            this.matrix[S.BOUNDARY][S.INTERIOR] = e.matrix[S.BOUNDARY][S.INTERIOR],
                            this.matrix[S.BOUNDARY][S.BOUNDARY] = e.matrix[S.BOUNDARY][S.BOUNDARY],
                            this.matrix[S.BOUNDARY][S.EXTERIOR] = e.matrix[S.BOUNDARY][S.EXTERIOR],
                            this.matrix[S.EXTERIOR][S.INTERIOR] = e.matrix[S.EXTERIOR][S.INTERIOR],
                            this.matrix[S.EXTERIOR][S.BOUNDARY] = e.matrix[S.EXTERIOR][S.BOUNDARY],
                            this.matrix[S.EXTERIOR][S.EXTERIOR] = e.matrix[S.EXTERIOR][S.EXTERIOR]
                        }
                }
                function fe() {
                    this.areaBasePt = null,
                    this.triangleCent3 = new d,
                    this.areasum2 = 0,
                    this.cg3 = new d,
                    this.lineCentSum = new d,
                    this.totalLength = 0,
                    this.ptCount = 0,
                    this.ptCentSum = new d;
                    var t = arguments[0];
                    this.areaBasePt = null,
                    this.add(t)
                }
                function de(t) {
                    this.message = t || ""
                }
                function ge() {
                    this.array_ = []
                }
                function pe() {
                    this.treeSet = new at,
                    this.list = new I
                }
                function me() {
                    if (this.geomFactory = null,
                    this.inputPts = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        me.call(this, me.extractCoordinates(t), t.getFactory())
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.inputPts = pe.filterCoordinates(e),
                        this.geomFactory = n
                    }
                }
                function ye() {
                    this.origin = null;
                    var t = arguments[0];
                    this.origin = t
                }
                function ve() {
                    this.inputGeom = null,
                    this.factory = null,
                    this.pruneEmptyGeometry = !0,
                    this.preserveGeometryCollectionType = !0,
                    this.preserveCollections = !1,
                    this.preserveType = !1
                }
                function Ee() {
                    if (this.snapTolerance = 0,
                    this.srcPts = null,
                    this.seg = new ce,
                    this.allowSnappingToSourceVertices = !1,
                    this._isClosed = !1,
                    arguments[0]instanceof wt && "number" == typeof arguments[1]) {
                        var t = arguments[0]
                          , e = arguments[1];
                        Ee.call(this, t.getCoordinates(), e)
                    } else if (arguments[0]instanceof Array && "number" == typeof arguments[1]) {
                        var n = arguments[0]
                          , i = arguments[1];
                        this.srcPts = n,
                        this._isClosed = Ee.isClosed(n),
                        this.snapTolerance = i
                    }
                }
                function xe() {
                    this.srcGeom = null;
                    var t = arguments[0];
                    this.srcGeom = t
                }
                function Ie() {
                    if (ve.apply(this),
                    this.snapTolerance = null,
                    this.snapPts = null,
                    this.isSelfSnap = !1,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        this.snapTolerance = t,
                        this.snapPts = e
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        this.snapTolerance = n,
                        this.snapPts = i,
                        this.isSelfSnap = r
                    }
                }
                function Ne() {
                    this.isFirst = !0,
                    this.commonMantissaBitsCount = 53,
                    this.commonBits = 0,
                    this.commonSignExp = null
                }
                function Ce() {
                    this.commonCoord = null,
                    this.ccFilter = new we
                }
                function we() {
                    this.commonBitsX = new Ne,
                    this.commonBitsY = new Ne
                }
                function _e() {
                    this.trans = null;
                    var t = arguments[0];
                    this.trans = t
                }
                function Se() {
                    this.parent = null,
                    this.atStart = null,
                    this.max = null,
                    this.index = null,
                    this.subcollectionIterator = null;
                    var t = arguments[0];
                    this.parent = t,
                    this.atStart = !0,
                    this.index = 0,
                    this.max = t.getNumGeometries()
                }
                function be() {
                    if (this.boundaryRule = U.OGC_SFS_BOUNDARY_RULE,
                    this.isIn = null,
                    this.numBoundaries = null,
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        if (null === t)
                            throw new i("Rule must be non-null");
                        this.boundaryRule = t
                    }
                }
                function Le() {}
                function Te() {}
                function Re() {
                    this.pts = null,
                    this.data = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.pts = t,
                    this.data = e
                }
                function Oe() {}
                function Pe() {
                    this.bounds = null,
                    this.item = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.bounds = t,
                    this.item = e
                }
                function Me() {
                    this._size = null,
                    this.items = null,
                    this._size = 0,
                    this.items = new I,
                    this.items.add(null)
                }
                function Ae() {}
                function De() {}
                function Fe() {
                    if (this.childBoundables = new I,
                    this.bounds = null,
                    this.level = null,
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.level = t
                    }
                }
                function Ge() {
                    this.boundable1 = null,
                    this.boundable2 = null,
                    this._distance = null,
                    this.itemDistance = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.boundable1 = t,
                    this.boundable2 = e,
                    this.itemDistance = n,
                    this._distance = this.distance()
                }
                function ke() {
                    if (this.root = null,
                    this.built = !1,
                    this.itemBoundables = new I,
                    this.nodeCapacity = null,
                    0 === arguments.length)
                        ke.call(this, ke.DEFAULT_NODE_CAPACITY);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        f.isTrue(t > 1, "Node capacity must be greater than 1"),
                        this.nodeCapacity = t
                    }
                }
                function qe() {}
                function Be() {}
                function Ue() {
                    if (0 === arguments.length)
                        Ue.call(this, Ue.DEFAULT_NODE_CAPACITY);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        ke.call(this, t)
                    }
                }
                function Ve() {
                    var t = arguments[0];
                    Fe.call(this, t)
                }
                function ze() {}
                function je() {
                    this.segString = null,
                    this.coord = null,
                    this.segmentIndex = null,
                    this.segmentOctant = null,
                    this._isInterior = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2]
                      , i = arguments[3];
                    this.segString = t,
                    this.coord = new d(e),
                    this.segmentIndex = n,
                    this.segmentOctant = i,
                    this._isInterior = !e.equals2D(t.getCoordinate(n))
                }
                function Ye() {
                    this.nodeMap = new rt,
                    this.edge = null;
                    var t = arguments[0];
                    this.edge = t
                }
                function Xe() {
                    this.nodeList = null,
                    this.edge = null,
                    this.nodeIt = null,
                    this.currNode = null,
                    this.nextNode = null,
                    this.currSegIndex = 0;
                    var t = arguments[0];
                    this.nodeList = t,
                    this.edge = t.getEdge(),
                    this.nodeIt = t.iterator(),
                    this.readNextNode()
                }
                function He() {}
                function We() {
                    this.nodeList = new Ye(this),
                    this.pts = null,
                    this.data = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.pts = t,
                    this.data = e
                }
                function Je() {
                    this.tempEnv1 = new C,
                    this.tempEnv2 = new C,
                    this.overlapSeg1 = new ce,
                    this.overlapSeg2 = new ce
                }
                function $e() {
                    this.pts = null,
                    this.start = null,
                    this.end = null,
                    this.env = null,
                    this.context = null,
                    this.id = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2]
                      , i = arguments[3];
                    this.pts = t,
                    this.start = e,
                    this.end = n,
                    this.context = i
                }
                function Ke() {}
                function Ze() {}
                function Qe() {}
                function tn() {
                    if (this.segInt = null,
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setSegmentIntersector(t)
                    }
                }
                function en() {
                    if (this.monoChains = new I,
                    this.index = new Ue,
                    this.idCounter = 0,
                    this.nodedSegStrings = null,
                    this.nOverlaps = 0,
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        tn.call(this, t)
                    }
                }
                function nn() {
                    Je.apply(this),
                    this.si = null;
                    var t = arguments[0];
                    this.si = t
                }
                function rn() {
                    if (this.pt = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        l.call(this, t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        l.call(this, rn.msgWithCoord(e, n)),
                        this.name = "TopologyException",
                        this.pt = new d(n)
                    }
                }
                function on() {}
                function sn() {
                    this.findAllIntersections = !1,
                    this.isCheckEndSegmentsOnly = !1,
                    this.li = null,
                    this.interiorIntersection = null,
                    this.intSegments = null,
                    this.intersections = new I,
                    this.intersectionCount = 0,
                    this.keepIntersections = !0;
                    var t = arguments[0];
                    this.li = t,
                    this.interiorIntersection = null
                }
                function an() {
                    this.li = new se,
                    this.segStrings = null,
                    this.findAllIntersections = !1,
                    this.segInt = null,
                    this._isValid = !0;
                    var t = arguments[0];
                    this.segStrings = t
                }
                function un() {
                    this.nv = null;
                    var t = arguments[0];
                    this.nv = new an(un.toSegmentStrings(t))
                }
                function ln() {
                    this.mapOp = null;
                    var t = arguments[0];
                    this.mapOp = t
                }
                function cn() {}
                function hn() {
                    if (this.location = null,
                    1 === arguments.length) {
                        if (arguments[0]instanceof Array) {
                            var t = arguments[0];
                            this.init(t.length)
                        } else if (Number.isInteger(arguments[0])) {
                            var e = arguments[0];
                            this.init(1),
                            this.location[cn.ON] = e
                        } else if (arguments[0]instanceof hn) {
                            var n = arguments[0];
                            if (this.init(n.location.length),
                            null !== n)
                                for (var i = 0; i < this.location.length; i++)
                                    this.location[i] = n.location[i]
                        }
                    } else if (3 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2];
                        this.init(3),
                        this.location[cn.ON] = r,
                        this.location[cn.LEFT] = o,
                        this.location[cn.RIGHT] = s
                    }
                }
                function fn() {
                    if (this.elt = new Array(2).fill(null),
                    1 === arguments.length) {
                        if (Number.isInteger(arguments[0])) {
                            var t = arguments[0];
                            this.elt[0] = new hn(t),
                            this.elt[1] = new hn(t)
                        } else if (arguments[0]instanceof fn) {
                            var e = arguments[0];
                            this.elt[0] = new hn(e.elt[0]),
                            this.elt[1] = new hn(e.elt[1])
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1];
                        this.elt[0] = new hn(S.NONE),
                        this.elt[1] = new hn(S.NONE),
                        this.elt[n].setLocation(i)
                    } else if (3 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2];
                        this.elt[0] = new hn(r,o,s),
                        this.elt[1] = new hn(r,o,s)
                    } else if (4 === arguments.length) {
                        var a = arguments[0]
                          , u = arguments[1]
                          , l = arguments[2]
                          , c = arguments[3];
                        this.elt[0] = new hn(S.NONE,S.NONE,S.NONE),
                        this.elt[1] = new hn(S.NONE,S.NONE,S.NONE),
                        this.elt[a].setLocations(u, l, c)
                    }
                }
                function dn() {
                    this.startDe = null,
                    this.maxNodeDegree = -1,
                    this.edges = new I,
                    this.pts = new I,
                    this.label = new fn(S.NONE),
                    this.ring = null,
                    this._isHole = null,
                    this.shell = null,
                    this.holes = new I,
                    this.geometryFactory = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.geometryFactory = e,
                    this.computePoints(t),
                    this.computeRing()
                }
                function gn() {
                    var t = arguments[0]
                      , e = arguments[1];
                    dn.call(this, t, e)
                }
                function pn() {
                    var t = arguments[0]
                      , e = arguments[1];
                    dn.call(this, t, e)
                }
                function mn() {
                    if (this.label = null,
                    this._isInResult = !1,
                    this._isCovered = !1,
                    this._isCoveredSet = !1,
                    this._isVisited = !1,
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.label = t
                    }
                }
                function yn() {
                    mn.apply(this),
                    this.coord = null,
                    this.edges = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.coord = t,
                    this.edges = e,
                    this.label = new fn(0,S.NONE)
                }
                function vn() {
                    this.nodeMap = new rt,
                    this.nodeFact = null;
                    var t = arguments[0];
                    this.nodeFact = t
                }
                function En() {
                    if (this.edge = null,
                    this.label = null,
                    this.node = null,
                    this.p0 = null,
                    this.p1 = null,
                    this.dx = null,
                    this.dy = null,
                    this.quadrant = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        this.edge = t
                    } else if (3 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1]
                          , i = arguments[2];
                        En.call(this, e, n, i, null)
                    } else if (4 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2]
                          , a = arguments[3];
                        En.call(this, r),
                        this.init(o, s),
                        this.label = a
                    }
                }
                function xn() {
                    this._isForward = null,
                    this._isInResult = !1,
                    this._isVisited = !1,
                    this.sym = null,
                    this.next = null,
                    this.nextMin = null,
                    this.edgeRing = null,
                    this.minEdgeRing = null,
                    this.depth = [0, -999, -999];
                    var t = arguments[0]
                      , e = arguments[1];
                    if (En.call(this, t),
                    this._isForward = e,
                    e)
                        this.init(t.getCoordinate(0), t.getCoordinate(1));
                    else {
                        var n = t.getNumPoints() - 1;
                        this.init(t.getCoordinate(n), t.getCoordinate(n - 1))
                    }
                    this.computeDirectedLabel()
                }
                function In() {}
                function Nn() {
                    if (this.edges = new I,
                    this.nodes = null,
                    this.edgeEndList = new I,
                    0 === arguments.length)
                        this.nodes = new vn(new In);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.nodes = new vn(t)
                    }
                }
                function Cn() {
                    this.geometryFactory = null,
                    this.shellList = new I;
                    var t = arguments[0];
                    this.geometryFactory = t
                }
                function wn() {
                    this.op = null,
                    this.geometryFactory = null,
                    this.ptLocator = null,
                    this.lineEdgesList = new I,
                    this.resultLineList = new I;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.op = t,
                    this.geometryFactory = e,
                    this.ptLocator = n
                }
                function _n() {
                    this.op = null,
                    this.geometryFactory = null,
                    this.resultPointList = new I;
                    var t = arguments[0]
                      , e = arguments[1];
                    arguments[2],
                    this.op = t,
                    this.geometryFactory = e
                }
                function Sn() {}
                function bn() {
                    this.geom = null;
                    var t = arguments[0];
                    this.geom = t
                }
                function Ln() {
                    this.edgeMap = new rt,
                    this.edgeList = null,
                    this.ptInAreaLocation = [S.NONE, S.NONE]
                }
                function Tn() {
                    Ln.apply(this),
                    this.resultAreaEdgeList = null,
                    this.label = null,
                    this.SCANNING_FOR_INCOMING = 1,
                    this.LINKING_TO_OUTGOING = 2
                }
                function Rn() {
                    In.apply(this)
                }
                function On() {
                    this.mce = null,
                    this.chainIndex = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.mce = t,
                    this.chainIndex = e
                }
                function Pn() {
                    if (this.label = null,
                    this.xValue = null,
                    this.eventType = null,
                    this.insertEvent = null,
                    this.deleteEventIndex = null,
                    this.obj = null,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        this.eventType = Pn.DELETE,
                        this.xValue = t,
                        this.insertEvent = e
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        this.eventType = Pn.INSERT,
                        this.label = n,
                        this.xValue = i,
                        this.obj = r
                    }
                }
                function Mn() {}
                function An() {
                    this._hasIntersection = !1,
                    this.hasProper = !1,
                    this.hasProperInterior = !1,
                    this.properIntersectionPoint = null,
                    this.li = null,
                    this.includeProper = null,
                    this.recordIsolated = null,
                    this.isSelfIntersection = null,
                    this.numIntersections = 0,
                    this.numTests = 0,
                    this.bdyNodes = null,
                    this._isDone = !1,
                    this.isDoneWhenProperInt = !1;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.li = t,
                    this.includeProper = e,
                    this.recordIsolated = n
                }
                function Dn() {
                    Mn.apply(this),
                    this.events = new I,
                    this.nOverlaps = null
                }
                function Fn() {
                    this.min = r.POSITIVE_INFINITY,
                    this.max = r.NEGATIVE_INFINITY
                }
                function Gn() {}
                function kn() {
                    Fn.apply(this),
                    this.item = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.min = t,
                    this.max = e,
                    this.item = n
                }
                function qn() {
                    Fn.apply(this),
                    this.node1 = null,
                    this.node2 = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.node1 = t,
                    this.node2 = e,
                    this.buildExtent(this.node1, this.node2)
                }
                function Bn() {
                    this.leaves = new I,
                    this.root = null,
                    this.level = 0
                }
                function Un() {
                    if (this.lines = null,
                    this.isForcedToLineString = !1,
                    1 === arguments.length) {
                        var t = arguments[0];
                        this.lines = t
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.lines = e,
                        this.isForcedToLineString = n
                    }
                }
                function Vn() {
                    this.items = new I
                }
                function zn() {
                    this.index = null;
                    var t = arguments[0];
                    if (!b(t, bt))
                        throw new i("Argument must be Polygonal");
                    this.index = new Yn(t)
                }
                function jn() {
                    this.counter = null;
                    var t = arguments[0];
                    this.counter = t
                }
                function Yn() {
                    this.index = new Bn;
                    var t = arguments[0];
                    this.init(t)
                }
                function Xn() {
                    this.coord = null,
                    this.segmentIndex = null,
                    this.dist = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.coord = new d(t),
                    this.segmentIndex = e,
                    this.dist = n
                }
                function Hn() {
                    this.nodeMap = new rt,
                    this.edge = null;
                    var t = arguments[0];
                    this.edge = t
                }
                function Wn() {}
                function Jn() {
                    this.e = null,
                    this.pts = null,
                    this.startIndex = null,
                    this.env1 = new C,
                    this.env2 = new C;
                    var t = arguments[0];
                    this.e = t,
                    this.pts = t.getCoordinates();
                    var e = new Wn;
                    this.startIndex = e.getChainStartIndices(this.pts)
                }
                function $n() {
                    this.depth = Array(2).fill().map(function() {
                        return Array(3)
                    });
                    for (var t = 0; t < 2; t++)
                        for (var e = 0; e < 3; e++)
                            this.depth[t][e] = $n.NULL_VALUE
                }
                function Kn() {
                    if (mn.apply(this),
                    this.pts = null,
                    this.env = null,
                    this.eiList = new Hn(this),
                    this.name = null,
                    this.mce = null,
                    this._isIsolated = !0,
                    this.depth = new $n,
                    this.depthDelta = 0,
                    1 === arguments.length) {
                        var t = arguments[0];
                        Kn.call(this, t, null)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.pts = e,
                        this.label = n
                    }
                }
                function Zn() {
                    if (Nn.apply(this),
                    this.parentGeom = null,
                    this.lineEdgeMap = new Qt,
                    this.boundaryNodeRule = null,
                    this.useBoundaryDeterminationRule = !0,
                    this.argIndex = null,
                    this.boundaryNodes = null,
                    this._hasTooFewPoints = !1,
                    this.invalidPoint = null,
                    this.areaPtLocator = null,
                    this.ptLocator = new be,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        Zn.call(this, t, e, U.OGC_SFS_BOUNDARY_RULE)
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        this.argIndex = n,
                        this.parentGeom = i,
                        this.boundaryNodeRule = r,
                        null !== i && this.add(i)
                    }
                }
                function Qn() {
                    if (this.li = new se,
                    this.resultPrecisionModel = null,
                    this.arg = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        this.setComputationPrecision(t.getPrecisionModel()),
                        this.arg = new Array(1).fill(null),
                        this.arg[0] = new Zn(0,t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        Qn.call(this, e, n, U.OGC_SFS_BOUNDARY_RULE)
                    } else if (3 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2];
                        i.getPrecisionModel().compareTo(r.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(r.getPrecisionModel()),
                        this.arg = new Array(2).fill(null),
                        this.arg[0] = new Zn(0,i,o),
                        this.arg[1] = new Zn(1,r,o)
                    }
                }
                function ti() {
                    this.pts = null,
                    this._orientation = null;
                    var t = arguments[0];
                    this.pts = t,
                    this._orientation = ti.orientation(t)
                }
                function ei() {
                    this.edges = new I,
                    this.ocaMap = new rt
                }
                function ni() {
                    this.ptLocator = new be,
                    this.geomFact = null,
                    this.resultGeom = null,
                    this.graph = null,
                    this.edgeList = new ei,
                    this.resultPolyList = new I,
                    this.resultLineList = new I,
                    this.resultPointList = new I;
                    var t = arguments[0]
                      , e = arguments[1];
                    Qn.call(this, t, e),
                    this.graph = new Nn(new Rn),
                    this.geomFact = t.getFactory()
                }
                function ii() {
                    this.geom = new Array(2).fill(null),
                    this.snapTolerance = null,
                    this.cbr = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.geom[0] = t,
                    this.geom[1] = e,
                    this.computeSnapTolerance()
                }
                function ri() {
                    this.geom = new Array(2).fill(null);
                    var t = arguments[0]
                      , e = arguments[1];
                    this.geom[0] = t,
                    this.geom[1] = e
                }
                function oi() {
                    this.factory = null,
                    this.interiorPoint = null,
                    this.maxWidth = 0;
                    var t = arguments[0];
                    this.factory = t.getFactory(),
                    this.add(t)
                }
                function si() {
                    this.poly = null,
                    this.centreY = null,
                    this.hiY = r.MAX_VALUE,
                    this.loY = -r.MAX_VALUE;
                    var t = arguments[0];
                    this.poly = t,
                    this.hiY = t.getEnvelopeInternal().getMaxY(),
                    this.loY = t.getEnvelopeInternal().getMinY(),
                    this.centreY = oi.avg(this.loY, this.hiY)
                }
                function ai() {
                    this.centroid = null,
                    this.minDistance = r.MAX_VALUE,
                    this.interiorPoint = null;
                    var t = arguments[0];
                    this.centroid = t.getCentroid().getCoordinate(),
                    this.addInterior(t),
                    null === this.interiorPoint && this.addEndpoints(t)
                }
                function ui() {
                    this.centroid = null,
                    this.minDistance = r.MAX_VALUE,
                    this.interiorPoint = null;
                    var t = arguments[0];
                    this.centroid = t.getCentroid().getCoordinate(),
                    this.add(t)
                }
                function li() {
                    this.tempEnv1 = new C,
                    this.selectedSegment = new ce
                }
                function ci() {
                    this.items = new I,
                    this.subnode = [null, null]
                }
                function hi() {
                    if (this.min = null,
                    this.max = null,
                    0 === arguments.length)
                        this.min = 0,
                        this.max = 0;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.init(t.min, t.max)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.init(e, n)
                    }
                }
                function fi() {}
                function di(t, e) {
                    var n, i, r, o, s = {
                        32: {
                            d: 127,
                            c: 128,
                            b: 0,
                            a: 0
                        },
                        64: {
                            d: 32752,
                            c: 0,
                            b: 0,
                            a: 0
                        }
                    }, a = {
                        32: 8,
                        64: 11
                    }[t];
                    if (o || (n = e < 0 || 1 / e < 0,
                    isFinite(e) || (o = s[t],
                    n && (o.d += 1 << t / 4 - 1),
                    i = Math.pow(2, a) - 1,
                    r = 0)),
                    !o) {
                        for (i = {
                            32: 127,
                            64: 1023
                        }[t],
                        r = Math.abs(e); r >= 2; )
                            i++,
                            r /= 2;
                        for (; r < 1 && i > 0; )
                            i--,
                            r *= 2;
                        i <= 0 && (r /= 2),
                        32 === t && i > 254 && (o = {
                            d: n ? 255 : 127,
                            c: 128,
                            b: 0,
                            a: 0
                        },
                        i = Math.pow(2, a) - 1,
                        r = 0)
                    }
                    return i
                }
                function gi() {
                    this.pt = 0,
                    this.level = 0,
                    this.interval = null;
                    var t = arguments[0];
                    this.computeKey(t)
                }
                function pi() {
                    ci.apply(this),
                    this.interval = null,
                    this.centre = null,
                    this.level = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.interval = t,
                    this.level = e,
                    this.centre = (t.getMin() + t.getMax()) / 2
                }
                function mi() {}
                function yi() {
                    ci.apply(this)
                }
                function vi() {
                    this.root = null,
                    this.minExtent = 1,
                    this.root = new yi
                }
                function Ei() {}
                function xi() {
                    this.ring = null,
                    this.tree = null,
                    this.crossings = 0,
                    this.interval = new hi;
                    var t = arguments[0];
                    this.ring = t,
                    this.buildIndex()
                }
                function Ii() {
                    li.apply(this),
                    this.mcp = null,
                    this.p = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.mcp = t,
                    this.p = e
                }
                function Ni() {}
                function Ci() {
                    this.p0 = null,
                    this.p1 = null,
                    this.p2 = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.p0 = t,
                    this.p1 = e,
                    this.p2 = n
                }
                function wi() {
                    this.input = null,
                    this.extremalPts = null,
                    this.centre = null,
                    this.radius = 0;
                    var t = arguments[0];
                    this.input = t
                }
                function _i() {
                    if (this.inputGeom = null,
                    this.isConvex = null,
                    this.convexHullPts = null,
                    this.minBaseSeg = new ce,
                    this.minWidthPt = null,
                    this.minPtIndex = null,
                    this.minWidth = 0,
                    1 === arguments.length) {
                        var t = arguments[0];
                        _i.call(this, t, !1)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.inputGeom = e,
                        this.isConvex = n
                    }
                }
                function Si() {
                    this.inputGeom = null,
                    this.distanceTolerance = null;
                    var t = arguments[0];
                    this.inputGeom = t
                }
                function bi() {
                    ve.apply(this),
                    this.distanceTolerance = null;
                    var t = arguments[0];
                    this.distanceTolerance = t
                }
                function Li() {
                    this._orig = null,
                    this._sym = null,
                    this._next = null;
                    var t = arguments[0];
                    this._orig = t
                }
                function Ti() {
                    this._isMarked = !1;
                    var t = arguments[0];
                    Li.call(this, t)
                }
                function Ri() {
                    this.vertexMap = new Qt
                }
                function Oi() {
                    this._isStart = !1;
                    var t = arguments[0];
                    Ti.call(this, t)
                }
                function Pi() {
                    Ri.apply(this)
                }
                function Mi() {
                    this.result = null,
                    this.factory = null,
                    this.graph = null,
                    this.lines = new I,
                    this.nodeEdgeStack = new ge,
                    this.ringStartEdge = null,
                    this.graph = new Pi
                }
                function Ai() {
                    this.items = new I,
                    this.subnode = new Array(4).fill(null)
                }
                function Di() {
                    this.pt = new d,
                    this.level = 0,
                    this.env = null;
                    var t = arguments[0];
                    this.computeKey(t)
                }
                function Fi() {
                    Ai.apply(this),
                    this.env = null,
                    this.centrex = null,
                    this.centrey = null,
                    this.level = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.env = t,
                    this.level = e,
                    this.centrex = (t.getMinX() + t.getMaxX()) / 2,
                    this.centrey = (t.getMinY() + t.getMaxY()) / 2
                }
                function Gi() {
                    Ai.apply(this)
                }
                function ki() {
                    this.root = null,
                    this.minExtent = 1,
                    this.root = new Gi
                }
                function qi(t) {
                    this.geometryFactory = t || new ne
                }
                function Bi(t) {
                    this.geometryFactory = t || new ne,
                    this.precisionModel = this.geometryFactory.getPrecisionModel(),
                    this.parser = new qi(this.geometryFactory)
                }
                function Ui() {
                    this.parser = new qi(this.geometryFactory)
                }
                function Vi(t) {
                    this.geometryFactory = t || new ne,
                    this.precisionModel = this.geometryFactory.getPrecisionModel(),
                    this.parser = new ie(this.geometryFactory)
                }
                function zi(t) {
                    return [t.x, t.y]
                }
                function ji(t, e) {
                    this.geometryFactory = t || new ne,
                    this.ol = e || "undefined" != typeof ol && ol
                }
                function Yi() {
                    if (this.noder = null,
                    this.scaleFactor = null,
                    this.offsetX = null,
                    this.offsetY = null,
                    this.isScaled = !1,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        Yi.call(this, t, e, 0, 0)
                    } else if (4 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1];
                        arguments[2],
                        arguments[3],
                        this.noder = n,
                        this.scaleFactor = i,
                        this.isScaled = !this.isIntegerPrecision()
                    }
                }
                function Xi() {
                    if (this.inputGeom = null,
                    this.isClosedEndpointsInInterior = !0,
                    this.nonSimpleLocation = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        this.inputGeom = t
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.inputGeom = e,
                        this.isClosedEndpointsInInterior = !n.isInBoundary(2)
                    }
                }
                function Hi() {
                    this.pt = null,
                    this.isClosed = null,
                    this.degree = null;
                    var t = arguments[0];
                    this.pt = t,
                    this.isClosed = !1,
                    this.degree = 0
                }
                function Wi() {
                    if (this.quadrantSegments = Wi.DEFAULT_QUADRANT_SEGMENTS,
                    this.endCapStyle = Wi.CAP_ROUND,
                    this.joinStyle = Wi.JOIN_ROUND,
                    this.mitreLimit = Wi.DEFAULT_MITRE_LIMIT,
                    this._isSingleSided = !1,
                    this.simplifyFactor = Wi.DEFAULT_SIMPLIFY_FACTOR,
                    0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.setQuadrantSegments(t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.setQuadrantSegments(e),
                        this.setEndCapStyle(n)
                    } else if (4 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2]
                          , s = arguments[3];
                        this.setQuadrantSegments(i),
                        this.setEndCapStyle(r),
                        this.setJoinStyle(o),
                        this.setMitreLimit(s)
                    }
                }
                function Ji() {
                    this.minIndex = -1,
                    this.minCoord = null,
                    this.minDe = null,
                    this.orientedDe = null
                }
                function $i() {
                    this.array_ = []
                }
                function Ki() {
                    this.finder = null,
                    this.dirEdgeList = new I,
                    this.nodes = new I,
                    this.rightMostCoord = null,
                    this.env = null,
                    this.finder = new Ji
                }
                function Zi() {
                    this.inputLine = null,
                    this.distanceTol = null,
                    this.isDeleted = null,
                    this.angleOrientation = le.COUNTERCLOCKWISE;
                    var t = arguments[0];
                    this.inputLine = t
                }
                function Qi() {
                    this.ptList = null,
                    this.precisionModel = null,
                    this.minimimVertexDistance = 0,
                    this.ptList = new I
                }
                function tr() {
                    this.maxCurveSegmentError = 0,
                    this.filletAngleQuantum = null,
                    this.closingSegLengthFactor = 1,
                    this.segList = null,
                    this.distance = 0,
                    this.precisionModel = null,
                    this.bufParams = null,
                    this.li = null,
                    this.s0 = null,
                    this.s1 = null,
                    this.s2 = null,
                    this.seg0 = new ce,
                    this.seg1 = new ce,
                    this.offset0 = new ce,
                    this.offset1 = new ce,
                    this.side = 0,
                    this._hasNarrowConcaveAngle = !1;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.precisionModel = t,
                    this.bufParams = e,
                    this.li = new se,
                    this.filletAngleQuantum = Math.PI / 2 / e.getQuadrantSegments(),
                    e.getQuadrantSegments() >= 8 && e.getJoinStyle() === Wi.JOIN_ROUND && (this.closingSegLengthFactor = tr.MAX_CLOSING_SEG_LEN_FACTOR),
                    this.init(n)
                }
                function er() {
                    this.distance = 0,
                    this.precisionModel = null,
                    this.bufParams = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.precisionModel = t,
                    this.bufParams = e
                }
                function nr() {
                    this.subgraphs = null,
                    this.seg = new ce,
                    this.cga = new le;
                    var t = arguments[0];
                    this.subgraphs = t
                }
                function ir() {
                    this.upwardSeg = null,
                    this.leftDepth = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.upwardSeg = new ce(t),
                    this.leftDepth = e
                }
                function rr() {
                    this.inputGeom = null,
                    this.distance = null,
                    this.curveBuilder = null,
                    this.curveList = new I;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.inputGeom = t,
                    this.distance = e,
                    this.curveBuilder = n
                }
                function or() {
                    this._hasIntersection = !1,
                    this.hasProper = !1,
                    this.hasProperInterior = !1,
                    this.hasInterior = !1,
                    this.properIntersectionPoint = null,
                    this.li = null,
                    this.isSelfIntersection = null,
                    this.numIntersections = 0,
                    this.numInteriorIntersections = 0,
                    this.numProperIntersections = 0,
                    this.numTests = 0;
                    var t = arguments[0];
                    this.li = t
                }
                function sr() {
                    this.bufParams = null,
                    this.workingPrecisionModel = null,
                    this.workingNoder = null,
                    this.geomFact = null,
                    this.graph = null,
                    this.edgeList = new ei;
                    var t = arguments[0];
                    this.bufParams = t
                }
                function ar() {
                    this.li = new se,
                    this.segStrings = null;
                    var t = arguments[0];
                    this.segStrings = t
                }
                function ur() {
                    this.li = null,
                    this.pt = null,
                    this.originalPt = null,
                    this.ptScaled = null,
                    this.p0Scaled = null,
                    this.p1Scaled = null,
                    this.scaleFactor = null,
                    this.minx = null,
                    this.maxx = null,
                    this.miny = null,
                    this.maxy = null,
                    this.corner = new Array(4).fill(null),
                    this.safeEnv = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    if (this.originalPt = t,
                    this.pt = t,
                    this.scaleFactor = e,
                    this.li = n,
                    e <= 0)
                        throw new i("Scale factor must be non-zero");
                    1 !== e && (this.pt = new d(this.scale(t.x),this.scale(t.y)),
                    this.p0Scaled = new d,
                    this.p1Scaled = new d),
                    this.initCorners(this.pt)
                }
                function lr() {
                    this.index = null;
                    var t = arguments[0];
                    this.index = t
                }
                function cr() {
                    li.apply(this),
                    this.hotPixel = null,
                    this.parentEdge = null,
                    this.hotPixelVertexIndex = null,
                    this._isNodeAdded = !1;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2];
                    this.hotPixel = t,
                    this.parentEdge = e,
                    this.hotPixelVertexIndex = n
                }
                function hr() {
                    this.li = null,
                    this.interiorIntersections = null;
                    var t = arguments[0];
                    this.li = t,
                    this.interiorIntersections = new I
                }
                function fr() {
                    this.pm = null,
                    this.li = null,
                    this.scaleFactor = null,
                    this.noder = null,
                    this.pointSnapper = null,
                    this.nodedSegStrings = null;
                    var t = arguments[0];
                    this.pm = t,
                    this.li = new se,
                    this.li.setPrecisionModel(t),
                    this.scaleFactor = t.getScale()
                }
                function dr() {
                    if (this.argGeom = null,
                    this.distance = null,
                    this.bufParams = new Wi,
                    this.resultGeometry = null,
                    this.saveException = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        this.argGeom = t
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.argGeom = e,
                        this.bufParams = n
                    }
                }
                function gr() {
                    this.comps = null;
                    var t = arguments[0];
                    this.comps = t
                }
                function pr() {
                    if (this.component = null,
                    this.segIndex = null,
                    this.pt = null,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        pr.call(this, t, pr.INSIDE_AREA, e)
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        this.component = n,
                        this.segIndex = i,
                        this.pt = r
                    }
                }
                function mr() {
                    this.pts = null;
                    var t = arguments[0];
                    this.pts = t
                }
                function yr() {
                    this.locations = null;
                    var t = arguments[0];
                    this.locations = t
                }
                function vr() {
                    if (this.geom = null,
                    this.terminateDistance = 0,
                    this.ptLocator = new be,
                    this.minDistanceLocation = null,
                    this.minDistance = r.MAX_VALUE,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        vr.call(this, t, e, 0)
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , o = arguments[2];
                        this.geom = new Array(2).fill(null),
                        this.geom[0] = n,
                        this.geom[1] = i,
                        this.terminateDistance = o
                    }
                }
                function Er() {
                    this.factory = null,
                    this.directedEdges = new I,
                    this.coordinates = null;
                    var t = arguments[0];
                    this.factory = t
                }
                function xr() {
                    this._isMarked = !1,
                    this._isVisited = !1,
                    this.data = null
                }
                function Ir() {
                    xr.apply(this),
                    this.parentEdge = null,
                    this.from = null,
                    this.to = null,
                    this.p0 = null,
                    this.p1 = null,
                    this.sym = null,
                    this.edgeDirection = null,
                    this.quadrant = null,
                    this.angle = null;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2]
                      , i = arguments[3];
                    this.from = t,
                    this.to = e,
                    this.edgeDirection = i,
                    this.p0 = t.getCoordinate(),
                    this.p1 = n;
                    var r = this.p1.x - this.p0.x
                      , o = this.p1.y - this.p0.y;
                    this.quadrant = Ke.quadrant(r, o),
                    this.angle = Math.atan2(o, r)
                }
                function Nr() {
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2]
                      , i = arguments[3];
                    Ir.call(this, t, e, n, i)
                }
                function Cr() {
                    if (xr.apply(this),
                    this.dirEdge = null,
                    0 === arguments.length)
                        ;
                    else if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        this.setDirectedEdges(t, e)
                    }
                }
                function wr() {
                    this.outEdges = new I,
                    this.sorted = !1
                }
                function _r() {
                    if (xr.apply(this),
                    this.pt = null,
                    this.deStar = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        _r.call(this, t, new wr)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.pt = e,
                        this.deStar = n
                    }
                }
                function Sr() {
                    Cr.apply(this),
                    this.line = null;
                    var t = arguments[0];
                    this.line = t
                }
                function br() {
                    this.nodeMap = new rt
                }
                function Lr() {
                    this.edges = new Z,
                    this.dirEdges = new Z,
                    this.nodeMap = new br
                }
                function Tr() {
                    Lr.apply(this)
                }
                function Rr() {
                    this.graph = new Tr,
                    this.mergedLineStrings = null,
                    this.factory = null,
                    this.edgeStrings = null
                }
                function Or() {
                    this.edgeRing = null,
                    this.next = null,
                    this.label = -1;
                    var t = arguments[0]
                      , e = arguments[1]
                      , n = arguments[2]
                      , i = arguments[3];
                    Ir.call(this, t, e, n, i)
                }
                function Pr() {
                    Cr.apply(this),
                    this.line = null;
                    var t = arguments[0];
                    this.line = t
                }
                function Mr() {
                    this.geometryFactory = new ne,
                    this.geomGraph = null,
                    this.disconnectedRingcoord = null;
                    var t = arguments[0];
                    this.geomGraph = t
                }
                function Ar() {}
                function Dr() {
                    if (this.edgeEnds = new I,
                    1 === arguments.length) {
                        var t = arguments[0];
                        Dr.call(this, null, t)
                    } else if (2 === arguments.length) {
                        var e = (arguments[0],
                        arguments[1]);
                        En.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new fn(e.getLabel())),
                        this.insert(e)
                    }
                }
                function Fr() {
                    Ln.apply(this)
                }
                function Gr() {
                    var t = arguments[0]
                      , e = arguments[1];
                    yn.call(this, t, e)
                }
                function kr() {
                    In.apply(this)
                }
                function qr() {
                    this.nodes = new vn(new kr)
                }
                function Br() {
                    this.li = new se,
                    this.geomGraph = null,
                    this.nodeGraph = new qr,
                    this.invalidPoint = null;
                    var t = arguments[0];
                    this.geomGraph = t
                }
                function Ur() {
                    this.graph = null,
                    this.rings = new I,
                    this.totalEnv = new C,
                    this.index = null,
                    this.nestedPt = null;
                    var t = arguments[0];
                    this.graph = t
                }
                function Vr() {
                    if (this.errorType = null,
                    this.pt = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        Vr.call(this, t, null)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.errorType = e,
                        null !== n && (this.pt = n.copy())
                    }
                }
                function zr() {
                    this.parentGeometry = null,
                    this.isSelfTouchingRingFormingHoleValid = !1,
                    this.validErr = null;
                    var t = arguments[0];
                    this.parentGeometry = t
                }
                function jr() {
                    this.factory = null,
                    this.deList = new I,
                    this.lowestEdge = null,
                    this.ring = null,
                    this.ringPts = null,
                    this.holes = null,
                    this.shell = null,
                    this._isHole = null,
                    this._isProcessed = !1,
                    this._isIncludedSet = !1,
                    this._isIncluded = !1;
                    var t = arguments[0];
                    this.factory = t
                }
                function Yr() {}
                function Xr() {
                    Lr.apply(this),
                    this.factory = null;
                    var t = arguments[0];
                    this.factory = t
                }
                function Hr() {
                    if (this.lineStringAdder = new Wr(this),
                    this.graph = null,
                    this.dangles = new I,
                    this.cutEdges = new I,
                    this.invalidRingLines = new I,
                    this.holeList = null,
                    this.shellList = null,
                    this.polyList = null,
                    this.isCheckingRingsValid = !0,
                    this.extractOnlyPolygonal = null,
                    this.geomFactory = null,
                    0 === arguments.length)
                        Hr.call(this, !1);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.extractOnlyPolygonal = t
                    }
                }
                function Wr() {
                    this.p = null;
                    var t = arguments[0];
                    this.p = t
                }
                function Jr() {
                    this.li = new se,
                    this.ptLocator = new be,
                    this.arg = null,
                    this.nodes = new vn(new kr),
                    this.im = null,
                    this.isolatedEdges = new I,
                    this.invalidPoint = null;
                    var t = arguments[0];
                    this.arg = t
                }
                function $r() {
                    this.rectEnv = null;
                    var t = arguments[0];
                    this.rectEnv = t.getEnvelopeInternal()
                }
                function Kr() {
                    this.li = new se,
                    this.rectEnv = null,
                    this.diagUp0 = null,
                    this.diagUp1 = null,
                    this.diagDown0 = null,
                    this.diagDown1 = null;
                    var t = arguments[0];
                    this.rectEnv = t,
                    this.diagUp0 = new d(t.getMinX(),t.getMinY()),
                    this.diagUp1 = new d(t.getMaxX(),t.getMaxY()),
                    this.diagDown0 = new d(t.getMinX(),t.getMaxY()),
                    this.diagDown1 = new d(t.getMaxX(),t.getMinY())
                }
                function Zr() {
                    this._isDone = !1
                }
                function Qr() {
                    this.rectangle = null,
                    this.rectEnv = null;
                    var t = arguments[0];
                    this.rectangle = t,
                    this.rectEnv = t.getEnvelopeInternal()
                }
                function to() {
                    Zr.apply(this),
                    this.rectEnv = null,
                    this._intersects = !1;
                    var t = arguments[0];
                    this.rectEnv = t
                }
                function eo() {
                    Zr.apply(this),
                    this.rectSeq = null,
                    this.rectEnv = null,
                    this._containsPoint = !1;
                    var t = arguments[0];
                    this.rectSeq = t.getExteriorRing().getCoordinateSequence(),
                    this.rectEnv = t.getEnvelopeInternal()
                }
                function no() {
                    Zr.apply(this),
                    this.rectEnv = null,
                    this.rectIntersector = null,
                    this.hasIntersection = !1,
                    this.p0 = new d,
                    this.p1 = new d;
                    var t = arguments[0];
                    this.rectEnv = t.getEnvelopeInternal(),
                    this.rectIntersector = new Kr(this.rectEnv)
                }
                function io() {
                    if (this._relate = null,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        Qn.call(this, t, e),
                        this._relate = new Jr(this.arg)
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        Qn.call(this, n, i, r),
                        this._relate = new Jr(this.arg)
                    }
                }
                function ro() {
                    this.geomFactory = null,
                    this.skipEmpty = !1,
                    this.inputGeoms = null;
                    var t = arguments[0];
                    this.geomFactory = ro.extractFactory(t),
                    this.inputGeoms = t
                }
                function oo() {
                    this.pointGeom = null,
                    this.otherGeom = null,
                    this.geomFact = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.pointGeom = t,
                    this.otherGeom = e,
                    this.geomFact = e.getFactory()
                }
                function so() {
                    this.sortIndex = -1,
                    this.comps = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.sortIndex = t,
                    this.comps = e
                }
                function ao() {
                    this.inputPolys = null,
                    this.geomFactory = null;
                    var t = arguments[0];
                    this.inputPolys = t,
                    null === this.inputPolys && (this.inputPolys = new I)
                }
                function uo() {
                    if (this.polygons = new I,
                    this.lines = new I,
                    this.points = new I,
                    this.geomFact = null,
                    1 === arguments.length) {
                        if (b(arguments[0], m)) {
                            var t = arguments[0];
                            this.extract(t)
                        } else if (arguments[0]instanceof q) {
                            var e = arguments[0];
                            this.extract(e)
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1];
                        this.geomFact = i,
                        this.extract(n)
                    }
                }
                function lo() {
                    Pt.CoordinateOperation.apply(this),
                    this.targetPM = null,
                    this.removeCollapsed = !0;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.targetPM = t,
                    this.removeCollapsed = e
                }
                function co() {
                    this.targetPM = null,
                    this.removeCollapsed = !0,
                    this.changePrecisionModel = !1,
                    this.isPointwise = !1;
                    var t = arguments[0];
                    this.targetPM = t
                }
                function ho() {
                    this.pts = null,
                    this.usePt = null,
                    this.distanceTolerance = null,
                    this.seg = new ce;
                    var t = arguments[0];
                    this.pts = t
                }
                function fo() {
                    this.inputGeom = null,
                    this.distanceTolerance = null,
                    this.isEnsureValidTopology = !0;
                    var t = arguments[0];
                    this.inputGeom = t
                }
                function go() {
                    ve.apply(this),
                    this.isEnsureValidTopology = !0,
                    this.distanceTolerance = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.isEnsureValidTopology = t,
                    this.distanceTolerance = e
                }
                function po() {
                    if (this.parent = null,
                    this.index = null,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        po.call(this, t, e, null, -1)
                    } else if (4 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2]
                          , o = arguments[3];
                        ce.call(this, n, i),
                        this.parent = r,
                        this.index = o
                    }
                }
                function mo() {
                    if (this.parentLine = null,
                    this.segs = null,
                    this.resultSegs = new I,
                    this.minimumSize = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        mo.call(this, t, 2)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.parentLine = e,
                        this.minimumSize = n,
                        this.init()
                    }
                }
                function yo() {
                    this.index = new ki
                }
                function vo() {
                    this.querySeg = null,
                    this.items = new I;
                    var t = arguments[0];
                    this.querySeg = t
                }
                function Eo() {
                    this.li = new se,
                    this.inputIndex = new yo,
                    this.outputIndex = new yo,
                    this.line = null,
                    this.linePts = null,
                    this.distanceTolerance = 0;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.inputIndex = t,
                    this.outputIndex = e
                }
                function xo() {
                    this.inputIndex = new yo,
                    this.outputIndex = new yo,
                    this.distanceTolerance = 0
                }
                function Io() {
                    this.inputGeom = null,
                    this.lineSimplifier = new xo,
                    this.linestringMap = null;
                    var t = arguments[0];
                    this.inputGeom = t
                }
                function No() {
                    ve.apply(this),
                    this.linestringMap = null;
                    var t = arguments[0];
                    this.linestringMap = t
                }
                function Co() {
                    this.tps = null;
                    var t = arguments[0];
                    this.tps = t
                }
                function wo() {
                    this.seg = null,
                    this.segLen = null,
                    this.splitPt = null,
                    this.minimumLen = 0;
                    var t = arguments[0];
                    this.seg = t,
                    this.segLen = t.getLength()
                }
                function _o() {}
                function So() {}
                function bo() {}
                function Lo() {
                    if (this.p = null,
                    1 === arguments.length) {
                        var t = arguments[0];
                        this.p = new d(t)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        this.p = new d(e,n)
                    } else if (3 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2];
                        this.p = new d(i,r,o)
                    }
                }
                function To() {
                    this._isOnConstraint = null,
                    this.constraint = null;
                    var t = arguments[0];
                    Lo.call(this, t)
                }
                function Ro() {
                    this._rot = null,
                    this.vertex = null,
                    this.next = null,
                    this.data = null
                }
                function Oo() {
                    this.subdiv = null,
                    this.isUsingTolerance = !1;
                    var t = arguments[0];
                    this.subdiv = t,
                    this.isUsingTolerance = t.getTolerance() > 0
                }
                function Po() {}
                function Mo() {
                    this.subdiv = null,
                    this.lastEdge = null;
                    var t = arguments[0];
                    this.subdiv = t,
                    this.init()
                }
                function Ao() {
                    if (this.seg = null,
                    1 === arguments.length) {
                        if ("string" == typeof arguments[0]) {
                            var t = arguments[0];
                            l.call(this, t)
                        } else if (arguments[0]instanceof ce) {
                            var e = arguments[0];
                            l.call(this, "Locate failed to converge (at edge: " + e + ").  Possible causes include invalid Subdivision topology or very close sites"),
                            this.seg = new ce(e)
                        }
                    } else if (2 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1];
                        l.call(this, Ao.msgWithSpatial(n, i)),
                        this.seg = new ce(i)
                    }
                }
                function Do() {}
                function Fo() {
                    this.visitedKey = 0,
                    this.quadEdges = new I,
                    this.startingEdge = null,
                    this.tolerance = null,
                    this.edgeCoincidenceTolerance = null,
                    this.frameVertex = new Array(3).fill(null),
                    this.frameEnv = null,
                    this.locator = null,
                    this.seg = new ce,
                    this.triEdges = new Array(3).fill(null);
                    var t = arguments[0]
                      , e = arguments[1];
                    this.tolerance = e,
                    this.edgeCoincidenceTolerance = e / Fo.EDGE_COINCIDENCE_TOL_FACTOR,
                    this.createFrame(t),
                    this.startingEdge = this.initSubdiv(),
                    this.locator = new Mo(this)
                }
                function Go() {}
                function ko() {
                    this.triList = new I
                }
                function qo() {
                    this.triList = new I
                }
                function Bo() {
                    this.coordList = new N,
                    this.triCoords = new I
                }
                function Uo() {
                    if (this.ls = null,
                    this.data = null,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        this.ls = new ce(t,e)
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        this.ls = new ce(n,i),
                        this.data = r
                    } else if (6 === arguments.length) {
                        var o = arguments[0]
                          , s = arguments[1]
                          , a = arguments[2]
                          , u = arguments[3]
                          , l = arguments[4]
                          , c = arguments[5];
                        Uo.call(this, new d(o,s,a), new d(u,l,c))
                    } else if (7 === arguments.length) {
                        var h = arguments[0]
                          , f = arguments[1]
                          , g = arguments[2]
                          , p = arguments[3]
                          , m = arguments[4]
                          , y = arguments[5]
                          , v = arguments[6];
                        Uo.call(this, new d(h,f,g), new d(p,m,y), v)
                    }
                }
                function Vo() {}
                function zo() {
                    if (this.p = null,
                    this.data = null,
                    this.left = null,
                    this.right = null,
                    this.count = null,
                    2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        this.p = new d(t),
                        this.left = null,
                        this.right = null,
                        this.count = 1,
                        this.data = e
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        this.p = new d(n,i),
                        this.left = null,
                        this.right = null,
                        this.count = 1,
                        this.data = r
                    }
                }
                function jo() {
                    if (this.root = null,
                    this.numberOfNodes = null,
                    this.tolerance = null,
                    0 === arguments.length)
                        jo.call(this, 0);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        this.tolerance = t
                    }
                }
                function Yo() {
                    this.tolerance = null,
                    this.matchNode = null,
                    this.matchDist = 0,
                    this.p = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.p = t,
                    this.tolerance = e
                }
                function Xo() {
                    this.initialVertices = null,
                    this.segVertices = null,
                    this.segments = new I,
                    this.subdiv = null,
                    this.incDel = null,
                    this.convexHull = null,
                    this.splitFinder = new So,
                    this.kdt = null,
                    this.vertexFactory = null,
                    this.computeAreaEnv = null,
                    this.splitPt = null,
                    this.tolerance = null;
                    var t = arguments[0]
                      , e = arguments[1];
                    this.initialVertices = new I(t),
                    this.tolerance = e,
                    this.kdt = new jo(e)
                }
                function Ho() {
                    this.siteCoords = null,
                    this.tolerance = 0,
                    this.subdiv = null
                }
                function Wo() {
                    this.siteCoords = null,
                    this.constraintLines = null,
                    this.tolerance = 0,
                    this.subdiv = null,
                    this.constraintVertexMap = new rt
                }
                function Jo() {
                    this.siteCoords = null,
                    this.tolerance = 0,
                    this.subdiv = null,
                    this.clipEnv = null,
                    this.diagramEnv = null
                }
                function $o() {}
                "fill"in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
                    configurable: !0,
                    value: function(t) {
                        if (void 0 === this || null === this)
                            throw new TypeError(this + " is not an object");
                        var e = Object(this)
                          , n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0
                          , i = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
                        i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);
                        var r = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;
                        for (r = r < 0 ? Math.max(n + arguments[2], 0) : Math.min(r, n); i < r; )
                            e[i] = t,
                            ++i;
                        return e
                    },
                    writable: !0
                }),
                Number.isFinite = Number.isFinite || function(t) {
                    return "number" == typeof t && isFinite(t)
                }
                ,
                Number.isInteger = Number.isInteger || function(t) {
                    return "number" == typeof t && isFinite(t) && Math.floor(t) === t
                }
                ,
                Number.parseFloat = Number.parseFloat || parseFloat,
                Number.isNaN = Number.isNaN || function(t) {
                    return t !== t
                }
                ,
                Math.trunc = Math.trunc || function(t) {
                    return t < 0 ? Math.ceil(t) : Math.floor(t)
                }
                ,
                e(n.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return n
                    }
                }),
                n.equalsWithTolerance = function(t, e, n) {
                    return Math.abs(t - e) <= n
                }
                ,
                r.isNaN = function(t) {
                    return Number.isNaN(t)
                }
                ,
                r.doubleToLongBits = function(t) {
                    return t
                }
                ,
                r.longBitsToDouble = function(t) {
                    return t
                }
                ,
                r.isInfinite = function(t) {
                    return !Number.isFinite(t)
                }
                ,
                r.MAX_VALUE = Number.MAX_VALUE,
                l.prototype = Object.create(Error.prototype),
                l.prototype.constructor = Error,
                c(h, l),
                e(h.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return h
                    }
                }),
                e(f.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return f
                    }
                }),
                f.shouldNeverReachHere = function() {
                    if (0 === arguments.length)
                        f.shouldNeverReachHere(null);
                    else if (1 === arguments.length) {
                        var t = arguments[0];
                        throw new h("Should never reach here" + (null !== t ? ": " + t : ""))
                    }
                }
                ,
                f.isTrue = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        f.isTrue(t, null)
                    } else if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        if (!e)
                            throw null === n ? new h : new h(n)
                    }
                }
                ,
                f.equals = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        f.equals(t, e, null)
                    } else if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        if (!i.equals(n))
                            throw new h("Expected " + n + " but encountered " + i + (null !== r ? ": " + r : ""))
                    }
                }
                ,
                e(d.prototype, {
                    setOrdinate: function(t, e) {
                        switch (t) {
                        case d.X:
                            this.x = e;
                            break;
                        case d.Y:
                            this.y = e;
                            break;
                        case d.Z:
                            this.z = e;
                            break;
                        default:
                            throw new i("Invalid ordinate index: " + t)
                        }
                    },
                    equals2D: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.x === t.x && this.y === t.y
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , i = arguments[1];
                            return !!n.equalsWithTolerance(this.x, e.x, i) && !!n.equalsWithTolerance(this.y, e.y, i)
                        }
                    },
                    getOrdinate: function(t) {
                        switch (t) {
                        case d.X:
                            return this.x;
                        case d.Y:
                            return this.y;
                        case d.Z:
                            return this.z
                        }
                        throw new i("Invalid ordinate index: " + t)
                    },
                    equals3D: function(t) {
                        return this.x === t.x && this.y === t.y && (this.z === t.z || r.isNaN(this.z) && r.isNaN(t.z))
                    },
                    equals: function(t) {
                        return t instanceof d && this.equals2D(t)
                    },
                    equalInZ: function(t, e) {
                        return n.equalsWithTolerance(this.z, t.z, e)
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
                    },
                    clone: function() {
                        try {
                            return null
                        } catch (t) {
                            if (t instanceof CloneNotSupportedException)
                                return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),
                                null;
                            throw t
                        }
                    },
                    copy: function() {
                        return new d(this)
                    },
                    toString: function() {
                        return "(" + this.x + ", " + this.y + ", " + this.z + ")"
                    },
                    distance3D: function(t) {
                        var e = this.x - t.x
                          , n = this.y - t.y
                          , i = this.z - t.z;
                        return Math.sqrt(e * e + n * n + i * i)
                    },
                    distance: function(t) {
                        var e = this.x - t.x
                          , n = this.y - t.y;
                        return Math.sqrt(e * e + n * n)
                    },
                    hashCode: function() {
                        var t = 17;
                        return t = 37 * t + d.hashCode(this.x),
                        t = 37 * t + d.hashCode(this.y)
                    },
                    setCoordinate: function(t) {
                        this.x = t.x,
                        this.y = t.y,
                        this.z = t.z
                    },
                    interfaces_: function() {
                        return [o, s, u]
                    },
                    getClass: function() {
                        return d
                    }
                }),
                d.hashCode = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0]
                          , e = r.doubleToLongBits(t);
                        return Math.trunc(e ^ e >>> 32)
                    }
                }
                ,
                e(g.prototype, {
                    compare: function(t, e) {
                        var n = t
                          , i = e
                          , r = g.compare(n.x, i.x);
                        if (0 !== r)
                            return r;
                        var o = g.compare(n.y, i.y);
                        return 0 !== o ? o : this.dimensionsToTest <= 2 ? 0 : g.compare(n.z, i.z)
                    },
                    interfaces_: function() {
                        return [a]
                    },
                    getClass: function() {
                        return g
                    }
                }),
                g.compare = function(t, e) {
                    return t < e ? -1 : t > e ? 1 : r.isNaN(t) ? r.isNaN(e) ? 0 : -1 : r.isNaN(e) ? 1 : 0
                }
                ,
                d.DimensionalComparator = g,
                d.serialVersionUID = 0x5cbf2c235c7e5800,
                d.NULL_ORDINATE = r.NaN,
                d.X = 0,
                d.Y = 1,
                d.Z = 2,
                p.prototype.hasNext = function() {}
                ,
                p.prototype.next = function() {}
                ,
                p.prototype.remove = function() {}
                ,
                m.prototype.add = function() {}
                ,
                m.prototype.addAll = function() {}
                ,
                m.prototype.isEmpty = function() {}
                ,
                m.prototype.iterator = function() {}
                ,
                m.prototype.size = function() {}
                ,
                m.prototype.toArray = function() {}
                ,
                m.prototype.remove = function() {}
                ,
                y.prototype = new Error,
                y.prototype.name = "IndexOutOfBoundsException",
                v.prototype = Object.create(m.prototype),
                v.prototype.constructor = v,
                v.prototype.get = function() {}
                ,
                v.prototype.set = function() {}
                ,
                v.prototype.isEmpty = function() {}
                ,
                E.prototype = new Error,
                E.prototype.name = "NoSuchElementException",
                x.prototype = new Error,
                x.prototype.name = "OperationNotSupported",
                I.prototype = Object.create(v.prototype),
                I.prototype.constructor = I,
                I.prototype.ensureCapacity = function() {}
                ,
                I.prototype.interfaces_ = function() {
                    return [v, m]
                }
                ,
                I.prototype.add = function(t) {
                    return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]),
                    !0
                }
                ,
                I.prototype.clear = function() {
                    this.array_ = []
                }
                ,
                I.prototype.addAll = function(t) {
                    for (var e = t.iterator(); e.hasNext(); )
                        this.add(e.next());
                    return !0
                }
                ,
                I.prototype.set = function(t, e) {
                    var n = this.array_[t];
                    return this.array_[t] = e,
                    n
                }
                ,
                I.prototype.iterator = function() {
                    return new Ko(this)
                }
                ,
                I.prototype.get = function(t) {
                    if (t < 0 || t >= this.size())
                        throw new y;
                    return this.array_[t]
                }
                ,
                I.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                }
                ,
                I.prototype.size = function() {
                    return this.array_.length
                }
                ,
                I.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                        t.push(this.array_[e]);
                    return t
                }
                ,
                I.prototype.remove = function(t) {
                    for (var e = !1, n = 0, i = this.array_.length; n < i; n++)
                        if (this.array_[n] === t) {
                            this.array_.splice(n, 1),
                            e = !0;
                            break
                        }
                    return e
                }
                ;
                var Ko = function(t) {
                    this.arrayList_ = t,
                    this.position_ = 0
                };
                Ko.prototype.next = function() {
                    if (this.position_ === this.arrayList_.size())
                        throw new E;
                    return this.arrayList_.get(this.position_++)
                }
                ,
                Ko.prototype.hasNext = function() {
                    return this.position_ < this.arrayList_.size()
                }
                ,
                Ko.prototype.set = function(t) {
                    return this.arrayList_.set(this.position_ - 1, t)
                }
                ,
                Ko.prototype.remove = function() {
                    this.arrayList_.remove(this.arrayList_.get(this.position_))
                }
                ,
                c(N, I),
                e(N.prototype, {
                    getCoordinate: function(t) {
                        return this.get(t)
                    },
                    addAll: function() {
                        if (2 === arguments.length) {
                            for (var t = arguments[0], e = arguments[1], n = !1, i = t.iterator(); i.hasNext(); )
                                this.add(i.next(), e),
                                n = !0;
                            return n
                        }
                        return I.prototype.addAll.apply(this, arguments)
                    },
                    clone: function() {
                        for (var t = I.prototype.clone.call(this), e = 0; e < this.size(); e++)
                            t.add(e, this.get(e).copy());
                        return t
                    },
                    toCoordinateArray: function() {
                        return this.toArray(N.coordArrayType)
                    },
                    add: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            I.prototype.add.call(this, t)
                        } else if (2 === arguments.length) {
                            if (arguments[0]instanceof Array && "boolean" == typeof arguments[1]) {
                                var e = arguments[0]
                                  , n = arguments[1];
                                return this.add(e, n, !0),
                                !0
                            }
                            if (arguments[0]instanceof d && "boolean" == typeof arguments[1]) {
                                var i = arguments[0]
                                  , r = arguments[1];
                                if (!r && this.size() >= 1) {
                                    var o = this.get(this.size() - 1);
                                    if (o.equals2D(i))
                                        return null
                                }
                                I.prototype.add.call(this, i)
                            } else if (arguments[0]instanceof Object && "boolean" == typeof arguments[1]) {
                                var s = arguments[0]
                                  , a = arguments[1];
                                return this.add(s, a),
                                !0
                            }
                        } else if (3 === arguments.length) {
                            if ("boolean" == typeof arguments[2] && arguments[0]instanceof Array && "boolean" == typeof arguments[1]) {
                                var u = arguments[0]
                                  , l = arguments[1]
                                  , c = arguments[2];
                                if (c)
                                    for (var h = 0; h < u.length; h++)
                                        this.add(u[h], l);
                                else
                                    for (var h = u.length - 1; h >= 0; h--)
                                        this.add(u[h], l);
                                return !0
                            }
                            if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1]instanceof d) {
                                var f = arguments[0]
                                  , g = arguments[1]
                                  , p = arguments[2];
                                if (!p) {
                                    var m = this.size();
                                    if (m > 0) {
                                        if (f > 0) {
                                            var y = this.get(f - 1);
                                            if (y.equals2D(g))
                                                return null
                                        }
                                        if (f < m) {
                                            var v = this.get(f);
                                            if (v.equals2D(g))
                                                return null
                                        }
                                    }
                                }
                                I.prototype.add.call(this, f, g)
                            }
                        } else if (4 === arguments.length) {
                            var E = arguments[0]
                              , x = arguments[1]
                              , N = arguments[2]
                              , C = arguments[3]
                              , w = 1;
                            N > C && (w = -1);
                            for (var h = N; h !== C; h += w)
                                this.add(E[h], x);
                            return !0
                        }
                    },
                    closeRing: function() {
                        this.size() > 0 && this.add(new d(this.get(0)), !1)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return N
                    }
                }),
                N.coordArrayType = new Array(0).fill(null),
                e(C.prototype, {
                    getArea: function() {
                        return this.getWidth() * this.getHeight()
                    },
                    equals: function(t) {
                        if (!(t instanceof C))
                            return !1;
                        var e = t;
                        return this.isNull() ? e.isNull() : this.maxx === e.getMaxX() && this.maxy === e.getMaxY() && this.minx === e.getMinX() && this.miny === e.getMinY()
                    },
                    intersection: function(t) {
                        if (this.isNull() || t.isNull() || !this.intersects(t))
                            return new C;
                        var e = this.minx > t.minx ? this.minx : t.minx
                          , n = this.miny > t.miny ? this.miny : t.miny;
                        return new C(e,this.maxx < t.maxx ? this.maxx : t.maxx,n,this.maxy < t.maxy ? this.maxy : t.maxy)
                    },
                    isNull: function() {
                        return this.maxx < this.minx
                    },
                    getMaxX: function() {
                        return this.maxx
                    },
                    covers: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof d) {
                                var t = arguments[0];
                                return this.covers(t.x, t.y)
                            }
                            if (arguments[0]instanceof C) {
                                var e = arguments[0];
                                return !this.isNull() && !e.isNull() && e.getMinX() >= this.minx && e.getMaxX() <= this.maxx && e.getMinY() >= this.miny && e.getMaxY() <= this.maxy
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            return !this.isNull() && n >= this.minx && n <= this.maxx && i >= this.miny && i <= this.maxy
                        }
                    },
                    intersects: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof C) {
                                var t = arguments[0];
                                return !this.isNull() && !t.isNull() && !(t.minx > this.maxx || t.maxx < this.minx || t.miny > this.maxy || t.maxy < this.miny)
                            }
                            if (arguments[0]instanceof d) {
                                var e = arguments[0];
                                return this.intersects(e.x, e.y)
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            return !this.isNull() && !(n > this.maxx || n < this.minx || i > this.maxy || i < this.miny)
                        }
                    },
                    getMinY: function() {
                        return this.miny
                    },
                    getMinX: function() {
                        return this.minx
                    },
                    expandToInclude: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof d) {
                                var t = arguments[0];
                                this.expandToInclude(t.x, t.y)
                            } else if (arguments[0]instanceof C) {
                                var e = arguments[0];
                                if (e.isNull())
                                    return null;
                                this.isNull() ? (this.minx = e.getMinX(),
                                this.maxx = e.getMaxX(),
                                this.miny = e.getMinY(),
                                this.maxy = e.getMaxY()) : (e.minx < this.minx && (this.minx = e.minx),
                                e.maxx > this.maxx && (this.maxx = e.maxx),
                                e.miny < this.miny && (this.miny = e.miny),
                                e.maxy > this.maxy && (this.maxy = e.maxy))
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            this.isNull() ? (this.minx = n,
                            this.maxx = n,
                            this.miny = i,
                            this.maxy = i) : (n < this.minx && (this.minx = n),
                            n > this.maxx && (this.maxx = n),
                            i < this.miny && (this.miny = i),
                            i > this.maxy && (this.maxy = i))
                        }
                    },
                    minExtent: function() {
                        if (this.isNull())
                            return 0;
                        var t = this.getWidth()
                          , e = this.getHeight();
                        return t < e ? t : e
                    },
                    getWidth: function() {
                        return this.isNull() ? 0 : this.maxx - this.minx
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this.minx < e.minx ? -1 : this.minx > e.minx ? 1 : this.miny < e.miny ? -1 : this.miny > e.miny ? 1 : this.maxx < e.maxx ? -1 : this.maxx > e.maxx ? 1 : this.maxy < e.maxy ? -1 : this.maxy > e.maxy ? 1 : 0
                    },
                    translate: function(t, e) {
                        return this.isNull() ? null : void this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
                    },
                    toString: function() {
                        return "Env[" + this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]"
                    },
                    setToNull: function() {
                        this.minx = 0,
                        this.maxx = -1,
                        this.miny = 0,
                        this.maxy = -1
                    },
                    getHeight: function() {
                        return this.isNull() ? 0 : this.maxy - this.miny
                    },
                    maxExtent: function() {
                        if (this.isNull())
                            return 0;
                        var t = this.getWidth()
                          , e = this.getHeight();
                        return t > e ? t : e
                    },
                    expandBy: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.expandBy(t, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            if (this.isNull())
                                return null;
                            this.minx -= e,
                            this.maxx += e,
                            this.miny -= n,
                            this.maxy += n,
                            (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull()
                        }
                    },
                    contains: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof C) {
                                var t = arguments[0];
                                return this.covers(t)
                            }
                            if (arguments[0]instanceof d) {
                                var e = arguments[0];
                                return this.covers(e)
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            return this.covers(n, i)
                        }
                    },
                    centre: function() {
                        return this.isNull() ? null : new d((this.getMinX() + this.getMaxX()) / 2,(this.getMinY() + this.getMaxY()) / 2)
                    },
                    init: function() {
                        if (0 === arguments.length)
                            this.setToNull();
                        else if (1 === arguments.length) {
                            if (arguments[0]instanceof d) {
                                var t = arguments[0];
                                this.init(t.x, t.x, t.y, t.y)
                            } else if (arguments[0]instanceof C) {
                                var e = arguments[0];
                                this.minx = e.minx,
                                this.maxx = e.maxx,
                                this.miny = e.miny,
                                this.maxy = e.maxy
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            this.init(n.x, i.x, n.y, i.y)
                        } else if (4 === arguments.length) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = arguments[2]
                              , a = arguments[3];
                            r < o ? (this.minx = r,
                            this.maxx = o) : (this.minx = o,
                            this.maxx = r),
                            s < a ? (this.miny = s,
                            this.maxy = a) : (this.miny = a,
                            this.maxy = s)
                        }
                    },
                    getMaxY: function() {
                        return this.maxy
                    },
                    distance: function(t) {
                        if (this.intersects(t))
                            return 0;
                        var e = 0;
                        this.maxx < t.minx ? e = t.minx - this.maxx : this.minx > t.maxx && (e = this.minx - t.maxx);
                        var n = 0;
                        return this.maxy < t.miny ? n = t.miny - this.maxy : this.miny > t.maxy && (n = this.miny - t.maxy),
                        0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
                    },
                    hashCode: function() {
                        var t = 17;
                        return t = 37 * t + d.hashCode(this.minx),
                        t = 37 * t + d.hashCode(this.maxx),
                        t = 37 * t + d.hashCode(this.miny),
                        t = 37 * t + d.hashCode(this.maxy)
                    },
                    interfaces_: function() {
                        return [o, u]
                    },
                    getClass: function() {
                        return C
                    }
                }),
                C.intersects = function() {
                    if (3 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = arguments[2];
                        return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y)
                    }
                    if (4 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2]
                          , s = arguments[3]
                          , a = Math.min(o.x, s.x)
                          , u = Math.max(o.x, s.x)
                          , l = Math.min(i.x, r.x)
                          , c = Math.max(i.x, r.x);
                        return !(l > u || c < a || (a = Math.min(o.y, s.y),
                        u = Math.max(o.y, s.y),
                        l = Math.min(i.y, r.y),
                        c = Math.max(i.y, r.y),
                        l > u || c < a))
                    }
                }
                ,
                C.serialVersionUID = 0x51845cd552189800,
                c(_, w),
                e(_.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return _
                    }
                }),
                e(S.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return S
                    }
                }),
                S.toLocationSymbol = function(t) {
                    switch (t) {
                    case S.EXTERIOR:
                        return "e";
                    case S.BOUNDARY:
                        return "b";
                    case S.INTERIOR:
                        return "i";
                    case S.NONE:
                        return "-"
                    }
                    throw new i("Unknown location value: " + t)
                }
                ,
                S.INTERIOR = 0,
                S.BOUNDARY = 1,
                S.EXTERIOR = 2,
                S.NONE = -1,
                e(L.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return L
                    }
                }),
                L.log10 = function(t) {
                    var e = Math.log(t);
                    return r.isInfinite(e) ? e : r.isNaN(e) ? e : e / L.LOG_10
                }
                ,
                L.min = function(t, e, n, i) {
                    var r = t;
                    return e < r && (r = e),
                    n < r && (r = n),
                    i < r && (r = i),
                    r
                }
                ,
                L.clamp = function() {
                    if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = arguments[2];
                        return t < e ? e : t > n ? n : t
                    }
                    if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2];
                        return i < r ? r : i > o ? o : i
                    }
                }
                ,
                L.wrap = function(t, e) {
                    return t < 0 ? e - -t % e : t % e
                }
                ,
                L.max = function() {
                    if (3 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = arguments[2]
                          , i = t;
                        return e > i && (i = e),
                        n > i && (i = n),
                        i
                    }
                    if (4 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2]
                          , a = arguments[3]
                          , i = r;
                        return o > i && (i = o),
                        s > i && (i = s),
                        a > i && (i = a),
                        i
                    }
                }
                ,
                L.average = function(t, e) {
                    return (t + e) / 2
                }
                ,
                L.LOG_10 = Math.log(10),
                T.prototype.append = function(t) {
                    this.str += t
                }
                ,
                T.prototype.setCharAt = function(t, e) {
                    this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
                }
                ,
                T.prototype.toString = function(t) {
                    return this.str
                }
                ,
                R.prototype.intValue = function() {
                    return this.value
                }
                ,
                R.prototype.compareTo = function(t) {
                    return this.value < t ? -1 : this.value > t ? 1 : 0
                }
                ,
                R.isNaN = function(t) {
                    return Number.isNaN(t)
                }
                ,
                O.isWhitespace = function(t) {
                    return t <= 32 && t >= 0 || 127 == t
                }
                ,
                O.toUpperCase = function(t) {
                    return t.toUpperCase()
                }
                ,
                e(P.prototype, {
                    le: function(t) {
                        return this.hi < t.hi || this.hi === t.hi && this.lo <= t.lo
                    },
                    extractSignificantDigits: function(t, e) {
                        var n = this.abs()
                          , i = P.magnitude(n.hi)
                          , r = P.TEN.pow(i);
                        n = n.divide(r),
                        n.gt(P.TEN) ? (n = n.divide(P.TEN),
                        i += 1) : n.lt(P.ONE) && (n = n.multiply(P.TEN),
                        i -= 1);
                        for (var o = i + 1, s = new T, a = P.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {
                            t && u === o && s.append(".");
                            var l = Math.trunc(n.hi);
                            if (l < 0)
                                break;
                            var c = !1
                              , h = 0;
                            l > 9 ? (c = !0,
                            h = "9") : h = "0" + l,
                            s.append(h),
                            n = n.subtract(P.valueOf(l)).multiply(P.TEN),
                            c && n.selfAdd(P.TEN);
                            var f = !0
                              , d = P.magnitude(n.hi);
                            if (d < 0 && Math.abs(d) >= a - u && (f = !1),
                            !f)
                                break
                        }
                        return e[0] = i,
                        s.toString()
                    },
                    sqr: function() {
                        return this.multiply(this)
                    },
                    doubleValue: function() {
                        return this.hi + this.lo
                    },
                    subtract: function() {
                        if (arguments[0]instanceof P) {
                            var t = arguments[0];
                            return this.add(t.negate())
                        }
                        if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            return this.add(-e)
                        }
                    },
                    equals: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.hi === t.hi && this.lo === t.lo
                        }
                    },
                    isZero: function() {
                        return 0 === this.hi && 0 === this.lo
                    },
                    selfSubtract: function() {
                        if (arguments[0]instanceof P) {
                            var t = arguments[0];
                            return this.isNaN() ? this : this.selfAdd(-t.hi, -t.lo)
                        }
                        if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            return this.isNaN() ? this : this.selfAdd(-e, 0)
                        }
                    },
                    getSpecialNumberString: function() {
                        return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
                    },
                    min: function(t) {
                        return this.le(t) ? this : t
                    },
                    selfDivide: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof P) {
                                var t = arguments[0];
                                return this.selfDivide(t.hi, t.lo)
                            }
                            if ("number" == typeof arguments[0]) {
                                var e = arguments[0];
                                return this.selfDivide(e, 0)
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = null
                              , o = null
                              , s = null
                              , a = null
                              , u = null
                              , l = null
                              , c = null
                              , h = null;
                            return u = this.hi / n,
                            l = P.SPLIT * u,
                            r = l - u,
                            h = P.SPLIT * n,
                            r = l - r,
                            o = u - r,
                            s = h - n,
                            c = u * n,
                            s = h - s,
                            a = n - s,
                            h = r * s - c + r * a + o * s + o * a,
                            l = (this.hi - c - h + this.lo - u * i) / n,
                            h = u + l,
                            this.hi = h,
                            this.lo = u - h + l,
                            this
                        }
                    },
                    dump: function() {
                        return "DD<" + this.hi + ", " + this.lo + ">"
                    },
                    divide: function() {
                        if (arguments[0]instanceof P) {
                            var t = arguments[0]
                              , e = null
                              , n = null
                              , i = null
                              , o = null
                              , s = null
                              , a = null
                              , u = null
                              , l = null;
                            s = this.hi / t.hi,
                            a = P.SPLIT * s,
                            e = a - s,
                            l = P.SPLIT * t.hi,
                            e = a - e,
                            n = s - e,
                            i = l - t.hi,
                            u = s * t.hi,
                            i = l - i,
                            o = t.hi - i,
                            l = e * i - u + e * o + n * i + n * o,
                            a = (this.hi - u - l + this.lo - s * t.lo) / t.hi,
                            l = s + a;
                            return new P(l,s - l + a)
                        }
                        if ("number" == typeof arguments[0]) {
                            var c = arguments[0];
                            return r.isNaN(c) ? P.createNaN() : P.copy(this).selfDivide(c, 0)
                        }
                    },
                    ge: function(t) {
                        return this.hi > t.hi || this.hi === t.hi && this.lo >= t.lo
                    },
                    pow: function(t) {
                        if (0 === t)
                            return P.valueOf(1);
                        var e = new P(this)
                          , n = P.valueOf(1)
                          , i = Math.abs(t);
                        if (i > 1)
                            for (; i > 0; )
                                i % 2 == 1 && n.selfMultiply(e),
                                (i /= 2) > 0 && (e = e.sqr());
                        else
                            n = e;
                        return t < 0 ? n.reciprocal() : n
                    },
                    ceil: function() {
                        if (this.isNaN())
                            return P.NaN;
                        var t = Math.ceil(this.hi)
                          , e = 0;
                        return t === this.hi && (e = Math.ceil(this.lo)),
                        new P(t,e)
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.hi < e.hi ? -1 : this.hi > e.hi ? 1 : this.lo < e.lo ? -1 : this.lo > e.lo ? 1 : 0
                    },
                    rint: function() {
                        return this.isNaN() ? this : this.add(.5).floor()
                    },
                    setValue: function() {
                        if (arguments[0]instanceof P) {
                            var t = arguments[0];
                            return this.init(t),
                            this
                        }
                        if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            return this.init(e),
                            this
                        }
                    },
                    max: function(t) {
                        return this.ge(t) ? this : t
                    },
                    sqrt: function() {
                        if (this.isZero())
                            return P.valueOf(0);
                        if (this.isNegative())
                            return P.NaN;
                        var t = 1 / Math.sqrt(this.hi)
                          , e = this.hi * t
                          , n = P.valueOf(e)
                          , i = this.subtract(n.sqr())
                          , r = i.hi * (.5 * t);
                        return n.add(r)
                    },
                    selfAdd: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof P) {
                                var t = arguments[0];
                                return this.selfAdd(t.hi, t.lo)
                            }
                            if ("number" == typeof arguments[0]) {
                                var e = arguments[0]
                                  , n = null
                                  , i = null
                                  , r = null
                                  , o = null
                                  , s = null
                                  , a = null;
                                return r = this.hi + e,
                                s = r - this.hi,
                                o = r - s,
                                o = e - s + (this.hi - o),
                                a = o + this.lo,
                                n = r + a,
                                i = a + (r - n),
                                this.hi = n + i,
                                this.lo = i + (n - this.hi),
                                this
                            }
                        } else if (2 === arguments.length) {
                            var u = arguments[0]
                              , l = arguments[1]
                              , n = null
                              , i = null
                              , c = null
                              , h = null
                              , r = null
                              , o = null
                              , s = null
                              , a = null;
                            r = this.hi + u,
                            c = this.lo + l,
                            s = r - this.hi,
                            a = c - this.lo,
                            o = r - s,
                            h = c - a,
                            o = u - s + (this.hi - o),
                            h = l - a + (this.lo - h),
                            s = o + c,
                            n = r + s,
                            i = s + (r - n),
                            s = h + i;
                            var f = n + s
                              , d = s + (n - f);
                            return this.hi = f,
                            this.lo = d,
                            this
                        }
                    },
                    selfMultiply: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof P) {
                                var t = arguments[0];
                                return this.selfMultiply(t.hi, t.lo)
                            }
                            if ("number" == typeof arguments[0]) {
                                var e = arguments[0];
                                return this.selfMultiply(e, 0)
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = null
                              , o = null
                              , s = null
                              , a = null
                              , u = null
                              , l = null;
                            u = P.SPLIT * this.hi,
                            r = u - this.hi,
                            l = P.SPLIT * n,
                            r = u - r,
                            o = this.hi - r,
                            s = l - n,
                            u = this.hi * n,
                            s = l - s,
                            a = n - s,
                            l = r * s - u + r * a + o * s + o * a + (this.hi * i + this.lo * n);
                            var c = u + l;
                            r = u - c;
                            var h = l + r;
                            return this.hi = c,
                            this.lo = h,
                            this
                        }
                    },
                    selfSqr: function() {
                        return this.selfMultiply(this)
                    },
                    floor: function() {
                        if (this.isNaN())
                            return P.NaN;
                        var t = Math.floor(this.hi)
                          , e = 0;
                        return t === this.hi && (e = Math.floor(this.lo)),
                        new P(t,e)
                    },
                    negate: function() {
                        return this.isNaN() ? this : new P(-this.hi,-this.lo)
                    },
                    clone: function() {
                        try {
                            return null
                        } catch (t) {
                            if (t instanceof CloneNotSupportedException)
                                return null;
                            throw t
                        }
                    },
                    multiply: function() {
                        if (arguments[0]instanceof P) {
                            var t = arguments[0];
                            return t.isNaN() ? P.createNaN() : P.copy(this).selfMultiply(t)
                        }
                        if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            return r.isNaN(e) ? P.createNaN() : P.copy(this).selfMultiply(e, 0)
                        }
                    },
                    isNaN: function() {
                        return r.isNaN(this.hi)
                    },
                    intValue: function() {
                        return Math.trunc(this.hi)
                    },
                    toString: function() {
                        var t = P.magnitude(this.hi);
                        return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation()
                    },
                    toStandardNotation: function() {
                        var t = this.getSpecialNumberString();
                        if (null !== t)
                            return t;
                        var e = new Array(1).fill(null)
                          , n = this.extractSignificantDigits(!0, e)
                          , i = e[0] + 1
                          , r = n;
                        if ("." === n.charAt(0))
                            r = "0" + n;
                        else if (i < 0)
                            r = "0." + P.stringOfChar("0", -i) + n;
                        else if (-1 === n.indexOf(".")) {
                            var o = i - n.length
                              , s = P.stringOfChar("0", o);
                            r = n + s + ".0"
                        }
                        return this.isNegative() ? "-" + r : r
                    },
                    reciprocal: function() {
                        var t = null
                          , e = null
                          , n = null
                          , i = null
                          , r = null
                          , o = null
                          , s = null
                          , a = null;
                        r = 1 / this.hi,
                        o = P.SPLIT * r,
                        t = o - r,
                        a = P.SPLIT * this.hi,
                        t = o - t,
                        e = r - t,
                        n = a - this.hi,
                        s = r * this.hi,
                        n = a - n,
                        i = this.hi - n,
                        a = t * n - s + t * i + e * n + e * i,
                        o = (1 - s - a - r * this.lo) / this.hi;
                        var u = r + o;
                        return new P(u,r - u + o)
                    },
                    toSciNotation: function() {
                        if (this.isZero())
                            return P.SCI_NOT_ZERO;
                        var t = this.getSpecialNumberString();
                        if (null !== t)
                            return t;
                        var e = new Array(1).fill(null)
                          , n = this.extractSignificantDigits(!1, e)
                          , i = P.SCI_NOT_EXPONENT_CHAR + e[0];
                        if ("0" === n.charAt(0))
                            throw new IllegalStateException("Found leading zero: " + n);
                        var r = "";
                        n.length > 1 && (r = n.substring(1));
                        var o = n.charAt(0) + "." + r;
                        return this.isNegative() ? "-" + o + i : o + i
                    },
                    abs: function() {
                        return this.isNaN() ? P.NaN : this.isNegative() ? this.negate() : new P(this)
                    },
                    isPositive: function() {
                        return this.hi > 0 || 0 === this.hi && this.lo > 0
                    },
                    lt: function(t) {
                        return this.hi < t.hi || this.hi === t.hi && this.lo < t.lo
                    },
                    add: function() {
                        if (arguments[0]instanceof P) {
                            var t = arguments[0];
                            return P.copy(this).selfAdd(t)
                        }
                        if ("number" == typeof arguments[0]) {
                            var e = arguments[0];
                            return P.copy(this).selfAdd(e)
                        }
                    },
                    init: function() {
                        if (1 === arguments.length) {
                            if ("number" == typeof arguments[0]) {
                                var t = arguments[0];
                                this.hi = t,
                                this.lo = 0
                            } else if (arguments[0]instanceof P) {
                                var e = arguments[0];
                                this.hi = e.hi,
                                this.lo = e.lo
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            this.hi = n,
                            this.lo = i
                        }
                    },
                    gt: function(t) {
                        return this.hi > t.hi || this.hi === t.hi && this.lo > t.lo
                    },
                    isNegative: function() {
                        return this.hi < 0 || 0 === this.hi && this.lo < 0
                    },
                    trunc: function() {
                        return this.isNaN() ? P.NaN : this.isPositive() ? this.floor() : this.ceil()
                    },
                    signum: function() {
                        return this.hi > 0 ? 1 : this.hi < 0 ? -1 : this.lo > 0 ? 1 : this.lo < 0 ? -1 : 0
                    },
                    interfaces_: function() {
                        return [u, o, s]
                    },
                    getClass: function() {
                        return P
                    }
                }),
                P.sqr = function(t) {
                    return P.valueOf(t).selfMultiply(t)
                }
                ,
                P.valueOf = function() {
                    if ("string" == typeof arguments[0]) {
                        var t = arguments[0];
                        return P.parse(t)
                    }
                    if ("number" == typeof arguments[0]) {
                        return new P(arguments[0])
                    }
                }
                ,
                P.sqrt = function(t) {
                    return P.valueOf(t).sqrt()
                }
                ,
                P.parse = function(t) {
                    for (var e = 0, n = t.length; O.isWhitespace(t.charAt(e)); )
                        e++;
                    var i = !1;
                    if (e < n) {
                        var r = t.charAt(e);
                        "-" !== r && "+" !== r || (e++,
                        "-" === r && (i = !0))
                    }
                    for (var o = new P, s = 0, a = 0, u = 0; !(e >= n); ) {
                        var l = t.charAt(e);
                        if (e++,
                        O.isDigit(l)) {
                            var c = l - "0";
                            o.selfMultiply(P.TEN),
                            o.selfAdd(c),
                            s++
                        } else {
                            if ("." !== l) {
                                if ("e" === l || "E" === l) {
                                    var h = t.substring(e);
                                    try {
                                        u = R.parseInt(h)
                                    } catch (e) {
                                        throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + h + " in string " + t) : e
                                    }
                                    break
                                }
                                throw new NumberFormatException("Unexpected character '" + l + "' at position " + e + " in string " + t)
                            }
                            a = s
                        }
                    }
                    var f = o
                      , d = s - a - u;
                    if (0 === d)
                        f = o;
                    else if (d > 0) {
                        var g = P.TEN.pow(d);
                        f = o.divide(g)
                    } else if (d < 0) {
                        var g = P.TEN.pow(-d);
                        f = o.multiply(g)
                    }
                    return i ? f.negate() : f
                }
                ,
                P.createNaN = function() {
                    return new P(r.NaN,r.NaN)
                }
                ,
                P.copy = function(t) {
                    return new P(t)
                }
                ,
                P.magnitude = function(t) {
                    var e = Math.abs(t)
                      , n = Math.log(e) / Math.log(10)
                      , i = Math.trunc(Math.floor(n));
                    return 10 * Math.pow(10, i) <= e && (i += 1),
                    i
                }
                ,
                P.stringOfChar = function(t, e) {
                    for (var n = new T, i = 0; i < e; i++)
                        n.append(t);
                    return n.toString()
                }
                ,
                P.PI = new P(3.141592653589793,1.2246467991473532e-16),
                P.TWO_PI = new P(6.283185307179586,2.4492935982947064e-16),
                P.PI_2 = new P(1.5707963267948966,6.123233995736766e-17),
                P.E = new P(2.718281828459045,1.4456468917292502e-16),
                P.NaN = new P(r.NaN,r.NaN),
                P.EPS = 1.23259516440783e-32,
                P.SPLIT = 134217729,
                P.MAX_PRINT_DIGITS = 32,
                P.TEN = P.valueOf(10),
                P.ONE = P.valueOf(1),
                P.SCI_NOT_EXPONENT_CHAR = "E",
                P.SCI_NOT_ZERO = "0.0E0",
                e(M.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return M
                    }
                }),
                M.orientationIndex = function(t, e, n) {
                    var i = M.orientationIndexFilter(t, e, n);
                    if (i <= 1)
                        return i;
                    var r = P.valueOf(e.x).selfAdd(-t.x)
                      , o = P.valueOf(e.y).selfAdd(-t.y)
                      , s = P.valueOf(n.x).selfAdd(-e.x)
                      , a = P.valueOf(n.y).selfAdd(-e.y);
                    return r.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum()
                }
                ,
                M.signOfDet2x2 = function(t, e, n, i) {
                    return t.multiply(i).selfSubtract(e.multiply(n)).signum()
                }
                ,
                M.intersection = function(t, e, n, i) {
                    var r = P.valueOf(i.y).selfSubtract(n.y).selfMultiply(P.valueOf(e.x).selfSubtract(t.x))
                      , o = P.valueOf(i.x).selfSubtract(n.x).selfMultiply(P.valueOf(e.y).selfSubtract(t.y))
                      , s = r.subtract(o)
                      , a = P.valueOf(i.x).selfSubtract(n.x).selfMultiply(P.valueOf(t.y).selfSubtract(n.y))
                      , u = P.valueOf(i.y).selfSubtract(n.y).selfMultiply(P.valueOf(t.x).selfSubtract(n.x))
                      , l = a.subtract(u)
                      , c = l.selfDivide(s).doubleValue()
                      , h = P.valueOf(t.x).selfAdd(P.valueOf(e.x).selfSubtract(t.x).selfMultiply(c)).doubleValue()
                      , f = P.valueOf(e.x).selfSubtract(t.x).selfMultiply(P.valueOf(t.y).selfSubtract(n.y))
                      , g = P.valueOf(e.y).selfSubtract(t.y).selfMultiply(P.valueOf(t.x).selfSubtract(n.x))
                      , p = f.subtract(g)
                      , m = p.selfDivide(s).doubleValue();
                    return new d(h,P.valueOf(n.y).selfAdd(P.valueOf(i.y).selfSubtract(n.y).selfMultiply(m)).doubleValue())
                }
                ,
                M.orientationIndexFilter = function(t, e, n) {
                    var i = null
                      , r = (t.x - n.x) * (e.y - n.y)
                      , o = (t.y - n.y) * (e.x - n.x)
                      , s = r - o;
                    if (r > 0) {
                        if (o <= 0)
                            return M.signum(s);
                        i = r + o
                    } else {
                        if (!(r < 0))
                            return M.signum(s);
                        if (o >= 0)
                            return M.signum(s);
                        i = -r - o
                    }
                    var a = M.DP_SAFE_EPSILON * i;
                    return s >= a || -s >= a ? M.signum(s) : 2
                }
                ,
                M.signum = function(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }
                ,
                M.DP_SAFE_EPSILON = 1e-15,
                e(A.prototype, {
                    setOrdinate: function(t, e, n) {},
                    size: function() {},
                    getOrdinate: function(t, e) {},
                    getCoordinate: function() {
                        1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0],
                        arguments[1])
                    },
                    getCoordinateCopy: function(t) {},
                    getDimension: function() {},
                    getX: function(t) {},
                    clone: function() {},
                    expandEnvelope: function(t) {},
                    copy: function() {},
                    getY: function(t) {},
                    toCoordinateArray: function() {},
                    interfaces_: function() {
                        return [s]
                    },
                    getClass: function() {
                        return A
                    }
                }),
                A.X = 0,
                A.Y = 1,
                A.Z = 2,
                A.M = 3,
                D.arraycopy = function(t, e, n, i, r) {
                    for (var o = 0, s = e; s < e + r; s++)
                        n[i + o] = t[s],
                        o++
                }
                ,
                D.getProperty = function(t) {
                    return {
                        "line.separator": "\n"
                    }[t]
                }
                ,
                e(F.prototype, {
                    getY: function() {
                        var t = this.y / this.w;
                        if (r.isNaN(t) || r.isInfinite(t))
                            throw new _;
                        return t
                    },
                    getX: function() {
                        var t = this.x / this.w;
                        if (r.isNaN(t) || r.isInfinite(t))
                            throw new _;
                        return t
                    },
                    getCoordinate: function() {
                        var t = new d;
                        return t.x = this.getX(),
                        t.y = this.getY(),
                        t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return F
                    }
                }),
                F.intersection = function(t, e, n, i) {
                    var o = t.y - e.y
                      , s = e.x - t.x
                      , a = t.x * e.y - e.x * t.y
                      , u = n.y - i.y
                      , l = i.x - n.x
                      , c = n.x * i.y - i.x * n.y
                      , h = s * c - l * a
                      , f = u * a - o * c
                      , g = o * l - u * s
                      , p = h / g
                      , m = f / g;
                    if (r.isNaN(p) || r.isInfinite(p) || r.isNaN(m) || r.isInfinite(m))
                        throw new _;
                    return new d(p,m)
                }
                ,
                e(G.prototype, {
                    create: function() {
                        1 === arguments.length ? arguments[0]instanceof Array ? arguments[0] : b(arguments[0], A) && arguments[0] : 2 === arguments.length && (arguments[0],
                        arguments[1])
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return G
                    }
                }),
                e(k.prototype, {
                    filter: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return k
                    }
                }),
                e(q.prototype, {
                    isGeometryCollection: function() {
                        return this.getSortIndex() === q.SORTINDEX_GEOMETRYCOLLECTION
                    },
                    getFactory: function() {
                        return this.factory
                    },
                    getGeometryN: function(t) {
                        return this
                    },
                    getArea: function() {
                        return 0
                    },
                    isRectangle: function() {
                        return !1
                    },
                    equals: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof q) {
                                var t = arguments[0];
                                return null !== t && this.equalsTopo(t)
                            }
                            if (arguments[0]instanceof Object) {
                                var e = arguments[0];
                                if (!(e instanceof q))
                                    return !1;
                                var n = e;
                                return this.equalsExact(n)
                            }
                        }
                    },
                    equalsExact: function(t) {
                        return this === t || this.equalsExact(t, 0)
                    },
                    geometryChanged: function() {
                        this.apply(q.geometryChangedFilter)
                    },
                    geometryChangedAction: function() {
                        this.envelope = null
                    },
                    equalsNorm: function(t) {
                        return null !== t && this.norm().equalsExact(t.norm())
                    },
                    getLength: function() {
                        return 0
                    },
                    getNumGeometries: function() {
                        return 1
                    },
                    compareTo: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = t;
                            return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t)
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , e = n;
                            return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(n, i)
                        }
                    },
                    getUserData: function() {
                        return this.userData
                    },
                    getSRID: function() {
                        return this.SRID
                    },
                    getEnvelope: function() {
                        return this.getFactory().toGeometry(this.getEnvelopeInternal())
                    },
                    checkNotGeometryCollection: function(t) {
                        if (t.getSortIndex() === q.SORTINDEX_GEOMETRYCOLLECTION)
                            throw new i("This method does not support GeometryCollection arguments")
                    },
                    equal: function(t, e, n) {
                        return 0 === n ? t.equals(e) : t.distance(e) <= n
                    },
                    norm: function() {
                        var t = this.copy();
                        return t.normalize(),
                        t
                    },
                    getPrecisionModel: function() {
                        return this.factory.getPrecisionModel()
                    },
                    getEnvelopeInternal: function() {
                        return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()),
                        new C(this.envelope)
                    },
                    setSRID: function(t) {
                        this.SRID = t
                    },
                    setUserData: function(t) {
                        this.userData = t
                    },
                    compare: function(t, e) {
                        for (var n = t.iterator(), i = e.iterator(); n.hasNext() && i.hasNext(); ) {
                            var r = n.next()
                              , o = i.next()
                              , s = r.compareTo(o);
                            if (0 !== s)
                                return s
                        }
                        return n.hasNext() ? 1 : i.hasNext() ? -1 : 0
                    },
                    hashCode: function() {
                        return this.getEnvelopeInternal().hashCode()
                    },
                    isGeometryCollectionOrDerived: function() {
                        return this.getSortIndex() === q.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === q.SORTINDEX_MULTIPOINT || this.getSortIndex() === q.SORTINDEX_MULTILINESTRING || this.getSortIndex() === q.SORTINDEX_MULTIPOLYGON
                    },
                    interfaces_: function() {
                        return [s, o, u]
                    },
                    getClass: function() {
                        return q
                    }
                }),
                q.hasNonEmptyElements = function(t) {
                    for (var e = 0; e < t.length; e++)
                        if (!t[e].isEmpty())
                            return !0;
                    return !1
                }
                ,
                q.hasNullElements = function(t) {
                    for (var e = 0; e < t.length; e++)
                        if (null === t[e])
                            return !0;
                    return !1
                }
                ,
                q.serialVersionUID = 0x799ea46522854c00,
                q.SORTINDEX_POINT = 0,
                q.SORTINDEX_MULTIPOINT = 1,
                q.SORTINDEX_LINESTRING = 2,
                q.SORTINDEX_LINEARRING = 3,
                q.SORTINDEX_MULTILINESTRING = 4,
                q.SORTINDEX_POLYGON = 5,
                q.SORTINDEX_MULTIPOLYGON = 6,
                q.SORTINDEX_GEOMETRYCOLLECTION = 7,
                q.geometryChangedFilter = {
                    interfaces_: function() {
                        return [k]
                    },
                    filter: function(t) {
                        t.geometryChangedAction()
                    }
                },
                e(B.prototype, {
                    filter: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return B
                    }
                }),
                e(U.prototype, {
                    isInBoundary: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return U
                    }
                }),
                e(V.prototype, {
                    isInBoundary: function(t) {
                        return t % 2 == 1
                    },
                    interfaces_: function() {
                        return [U]
                    },
                    getClass: function() {
                        return V
                    }
                }),
                e(z.prototype, {
                    isInBoundary: function(t) {
                        return t > 0
                    },
                    interfaces_: function() {
                        return [U]
                    },
                    getClass: function() {
                        return z
                    }
                }),
                e(j.prototype, {
                    isInBoundary: function(t) {
                        return t > 1
                    },
                    interfaces_: function() {
                        return [U]
                    },
                    getClass: function() {
                        return j
                    }
                }),
                e(Y.prototype, {
                    isInBoundary: function(t) {
                        return 1 === t
                    },
                    interfaces_: function() {
                        return [U]
                    },
                    getClass: function() {
                        return Y
                    }
                }),
                U.Mod2BoundaryNodeRule = V,
                U.EndPointBoundaryNodeRule = z,
                U.MultiValentEndPointBoundaryNodeRule = j,
                U.MonoValentEndPointBoundaryNodeRule = Y,
                U.MOD2_BOUNDARY_RULE = new V,
                U.ENDPOINT_BOUNDARY_RULE = new z,
                U.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new j,
                U.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new Y,
                U.OGC_SFS_BOUNDARY_RULE = U.MOD2_BOUNDARY_RULE,
                e(X.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return X
                    }
                }),
                X.isRing = function(t) {
                    return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]))
                }
                ,
                X.ptNotInList = function(t, e) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        if (X.indexOf(i, e) < 0)
                            return i
                    }
                    return null
                }
                ,
                X.scroll = function(t, e) {
                    var n = X.indexOf(e, t);
                    if (n < 0)
                        return null;
                    var i = new Array(t.length).fill(null);
                    D.arraycopy(t, n, i, 0, t.length - n),
                    D.arraycopy(t, 0, i, t.length - n, n),
                    D.arraycopy(i, 0, t, 0, t.length)
                }
                ,
                X.equals = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        if (t === e)
                            return !0;
                        if (null === t || null === e)
                            return !1;
                        if (t.length !== e.length)
                            return !1;
                        for (var n = 0; n < t.length; n++)
                            if (!t[n].equals(e[n]))
                                return !1;
                        return !0
                    }
                    if (3 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2];
                        if (i === r)
                            return !0;
                        if (null === i || null === r)
                            return !1;
                        if (i.length !== r.length)
                            return !1;
                        for (var n = 0; n < i.length; n++)
                            if (0 !== o.compare(i[n], r[n]))
                                return !1;
                        return !0
                    }
                }
                ,
                X.intersection = function(t, e) {
                    for (var n = new N, i = 0; i < t.length; i++)
                        e.intersects(t[i]) && n.add(t[i], !0);
                    return n.toCoordinateArray()
                }
                ,
                X.hasRepeatedPoints = function(t) {
                    for (var e = 1; e < t.length; e++)
                        if (t[e - 1].equals(t[e]))
                            return !0;
                    return !1
                }
                ,
                X.removeRepeatedPoints = function(t) {
                    return X.hasRepeatedPoints(t) ? new N(t,!1).toCoordinateArray() : t
                }
                ,
                X.reverse = function(t) {
                    for (var e = t.length - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++) {
                        var r = t[i];
                        t[i] = t[e - i],
                        t[e - i] = r
                    }
                }
                ,
                X.removeNull = function(t) {
                    for (var e = 0, n = 0; n < t.length; n++)
                        null !== t[n] && e++;
                    var i = new Array(e).fill(null);
                    if (0 === e)
                        return i;
                    for (var r = 0, n = 0; n < t.length; n++)
                        null !== t[n] && (i[r++] = t[n]);
                    return i
                }
                ,
                X.copyDeep = function() {
                    if (1 === arguments.length) {
                        for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++)
                            e[n] = new d(t[n]);
                        return e
                    }
                    if (5 === arguments.length)
                        for (var i = arguments[0], r = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], n = 0; n < a; n++)
                            o[s + n] = new d(i[r + n])
                }
                ,
                X.isEqualReversed = function(t, e) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n]
                          , r = e[t.length - n - 1];
                        if (0 !== i.compareTo(r))
                            return !1
                    }
                    return !0
                }
                ,
                X.envelope = function(t) {
                    for (var e = new C, n = 0; n < t.length; n++)
                        e.expandToInclude(t[n]);
                    return e
                }
                ,
                X.toCoordinateArray = function(t) {
                    return t.toArray(X.coordArrayType)
                }
                ,
                X.atLeastNCoordinatesOrNothing = function(t, e) {
                    return e.length >= t ? e : []
                }
                ,
                X.indexOf = function(t, e) {
                    for (var n = 0; n < e.length; n++)
                        if (t.equals(e[n]))
                            return n;
                    return -1
                }
                ,
                X.increasingDirection = function(t) {
                    for (var e = 0; e < Math.trunc(t.length / 2); e++) {
                        var n = t.length - 1 - e
                          , i = t[e].compareTo(t[n]);
                        if (0 !== i)
                            return i
                    }
                    return 1
                }
                ,
                X.compare = function(t, e) {
                    for (var n = 0; n < t.length && n < e.length; ) {
                        var i = t[n].compareTo(e[n]);
                        if (0 !== i)
                            return i;
                        n++
                    }
                    return n < e.length ? -1 : n < t.length ? 1 : 0
                }
                ,
                X.minCoordinate = function(t) {
                    for (var e = null, n = 0; n < t.length; n++)
                        (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);
                    return e
                }
                ,
                X.extract = function(t, e, n) {
                    e = L.clamp(e, 0, t.length),
                    n = L.clamp(n, -1, t.length);
                    var i = n - e + 1;
                    n < 0 && (i = 0),
                    e >= t.length && (i = 0),
                    n < e && (i = 0);
                    var r = new Array(i).fill(null);
                    if (0 === i)
                        return r;
                    for (var o = 0, s = e; s <= n; s++)
                        r[o++] = t[s];
                    return r
                }
                ,
                e(H.prototype, {
                    compare: function(t, e) {
                        var n = t
                          , i = e;
                        return X.compare(n, i)
                    },
                    interfaces_: function() {
                        return [a]
                    },
                    getClass: function() {
                        return H
                    }
                }),
                e(W.prototype, {
                    compare: function(t, e) {
                        var n = t
                          , i = e;
                        if (n.length < i.length)
                            return -1;
                        if (n.length > i.length)
                            return 1;
                        if (0 === n.length)
                            return 0;
                        var r = X.compare(n, i);
                        return X.isEqualReversed(n, i) ? 0 : r
                    },
                    OLDcompare: function(t, e) {
                        var n = t
                          , i = e;
                        if (n.length < i.length)
                            return -1;
                        if (n.length > i.length)
                            return 1;
                        if (0 === n.length)
                            return 0;
                        for (var r = X.increasingDirection(n), o = X.increasingDirection(i), s = r > 0 ? 0 : n.length - 1, a = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {
                            var l = n[s].compareTo(i[a]);
                            if (0 !== l)
                                return l;
                            s += r,
                            a += o
                        }
                        return 0
                    },
                    interfaces_: function() {
                        return [a]
                    },
                    getClass: function() {
                        return W
                    }
                }),
                X.ForwardComparator = H,
                X.BidirectionalComparator = W,
                X.coordArrayType = new Array(0).fill(null),
                J.prototype.get = function() {}
                ,
                J.prototype.put = function() {}
                ,
                J.prototype.size = function() {}
                ,
                J.prototype.values = function() {}
                ,
                J.prototype.entrySet = function() {}
                ,
                $.prototype = new J,
                K.prototype = new m,
                K.prototype.contains = function() {}
                ,
                Z.prototype = new K,
                Z.prototype.contains = function(t) {
                    for (var e = 0, n = this.array_.length; e < n; e++) {
                        if (this.array_[e] === t)
                            return !0
                    }
                    return !1
                }
                ,
                Z.prototype.add = function(t) {
                    return !this.contains(t) && (this.array_.push(t),
                    !0)
                }
                ,
                Z.prototype.addAll = function(t) {
                    for (var e = t.iterator(); e.hasNext(); )
                        this.add(e.next());
                    return !0
                }
                ,
                Z.prototype.remove = function(t) {
                    throw new javascript.util.OperationNotSupported
                }
                ,
                Z.prototype.size = function() {
                    return this.array_.length
                }
                ,
                Z.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                }
                ,
                Z.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                        t.push(this.array_[e]);
                    return t
                }
                ,
                Z.prototype.iterator = function() {
                    return new Zo(this)
                }
                ;
                var Zo = function(t) {
                    this.hashSet_ = t,
                    this.position_ = 0
                };
                Zo.prototype.next = function() {
                    if (this.position_ === this.hashSet_.size())
                        throw new E;
                    return this.hashSet_.array_[this.position_++]
                }
                ,
                Zo.prototype.hasNext = function() {
                    return this.position_ < this.hashSet_.size()
                }
                ,
                Zo.prototype.remove = function() {
                    throw new x
                }
                ;
                var Qo = 0;
                rt.prototype = new $,
                rt.prototype.get = function(t) {
                    for (var e = this.root_; null !== e; ) {
                        var n = t.compareTo(e.key);
                        if (n < 0)
                            e = e.left;
                        else {
                            if (!(n > 0))
                                return e.value;
                            e = e.right
                        }
                    }
                    return null
                }
                ,
                rt.prototype.put = function(t, e) {
                    if (null === this.root_)
                        return this.root_ = {
                            key: t,
                            value: e,
                            left: null,
                            right: null,
                            parent: null,
                            color: Qo,
                            getValue: function() {
                                return this.value
                            },
                            getKey: function() {
                                return this.key
                            }
                        },
                        this.size_ = 1,
                        null;
                    var n, i, r = this.root_;
                    do {
                        if (n = r,
                        (i = t.compareTo(r.key)) < 0)
                            r = r.left;
                        else {
                            if (!(i > 0)) {
                                var o = r.value;
                                return r.value = e,
                                o
                            }
                            r = r.right
                        }
                    } while (null !== r);var s = {
                        key: t,
                        left: null,
                        right: null,
                        value: e,
                        parent: n,
                        color: Qo,
                        getValue: function() {
                            return this.value
                        },
                        getKey: function() {
                            return this.key
                        }
                    };
                    return i < 0 ? n.left = s : n.right = s,
                    this.fixAfterInsertion(s),
                    this.size_++,
                    null
                }
                ,
                rt.prototype.fixAfterInsertion = function(t) {
                    for (t.color = 1; null != t && t != this.root_ && 1 == t.parent.color; )
                        if (tt(t) == nt(tt(tt(t)))) {
                            var e = it(tt(tt(t)));
                            1 == Q(e) ? (et(tt(t), Qo),
                            et(e, Qo),
                            et(tt(tt(t)), 1),
                            t = tt(tt(t))) : (t == it(tt(t)) && (t = tt(t),
                            this.rotateLeft(t)),
                            et(tt(t), Qo),
                            et(tt(tt(t)), 1),
                            this.rotateRight(tt(tt(t))))
                        } else {
                            var e = nt(tt(tt(t)));
                            1 == Q(e) ? (et(tt(t), Qo),
                            et(e, Qo),
                            et(tt(tt(t)), 1),
                            t = tt(tt(t))) : (t == nt(tt(t)) && (t = tt(t),
                            this.rotateRight(t)),
                            et(tt(t), Qo),
                            et(tt(tt(t)), 1),
                            this.rotateLeft(tt(tt(t))))
                        }
                    this.root_.color = Qo
                }
                ,
                rt.prototype.values = function() {
                    var t = new I
                      , e = this.getFirstEntry();
                    if (null !== e)
                        for (t.add(e.value); null !== (e = rt.successor(e)); )
                            t.add(e.value);
                    return t
                }
                ,
                rt.prototype.entrySet = function() {
                    var t = new Z
                      , e = this.getFirstEntry();
                    if (null !== e)
                        for (t.add(e); null !== (e = rt.successor(e)); )
                            t.add(e);
                    return t
                }
                ,
                rt.prototype.rotateLeft = function(t) {
                    if (null != t) {
                        var e = t.right;
                        t.right = e.left,
                        null != e.left && (e.left.parent = t),
                        e.parent = t.parent,
                        null == t.parent ? this.root_ = e : t.parent.left == t ? t.parent.left = e : t.parent.right = e,
                        e.left = t,
                        t.parent = e
                    }
                }
                ,
                rt.prototype.rotateRight = function(t) {
                    if (null != t) {
                        var e = t.left;
                        t.left = e.right,
                        null != e.right && (e.right.parent = t),
                        e.parent = t.parent,
                        null == t.parent ? this.root_ = e : t.parent.right == t ? t.parent.right = e : t.parent.left = e,
                        e.right = t,
                        t.parent = e
                    }
                }
                ,
                rt.prototype.getFirstEntry = function() {
                    var t = this.root_;
                    if (null != t)
                        for (; null != t.left; )
                            t = t.left;
                    return t
                }
                ,
                rt.successor = function(t) {
                    if (null === t)
                        return null;
                    if (null !== t.right) {
                        for (var e = t.right; null !== e.left; )
                            e = e.left;
                        return e
                    }
                    for (var e = t.parent, n = t; null !== e && n === e.right; )
                        n = e,
                        e = e.parent;
                    return e
                }
                ,
                rt.prototype.size = function() {
                    return this.size_
                }
                ,
                e(ot.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ot
                    }
                }),
                st.prototype = new K,
                at.prototype = new st,
                at.prototype.contains = function(t) {
                    for (var e = 0, n = this.array_.length; e < n; e++) {
                        if (0 === this.array_[e].compareTo(t))
                            return !0
                    }
                    return !1
                }
                ,
                at.prototype.add = function(t) {
                    if (this.contains(t))
                        return !1;
                    for (var e = 0, n = this.array_.length; e < n; e++) {
                        if (1 === this.array_[e].compareTo(t))
                            return this.array_.splice(e, 0, t),
                            !0
                    }
                    return this.array_.push(t),
                    !0
                }
                ,
                at.prototype.addAll = function(t) {
                    for (var e = t.iterator(); e.hasNext(); )
                        this.add(e.next());
                    return !0
                }
                ,
                at.prototype.remove = function(t) {
                    throw new x
                }
                ,
                at.prototype.size = function() {
                    return this.array_.length
                }
                ,
                at.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                }
                ,
                at.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                        t.push(this.array_[e]);
                    return t
                }
                ,
                at.prototype.iterator = function() {
                    return new ts(this)
                }
                ;
                var ts = function(t) {
                    this.treeSet_ = t,
                    this.position_ = 0
                };
                ts.prototype.next = function() {
                    if (this.position_ === this.treeSet_.size())
                        throw new E;
                    return this.treeSet_.array_[this.position_++]
                }
                ,
                ts.prototype.hasNext = function() {
                    return this.position_ < this.treeSet_.size()
                }
                ,
                ts.prototype.remove = function() {
                    throw new x
                }
                ,
                ut.sort = function() {
                    var t, e, n, i, r = arguments[0];
                    if (1 === arguments.length)
                        return i = function(t, e) {
                            return t.compareTo(e)
                        }
                        ,
                        void r.sort(i);
                    if (2 === arguments.length)
                        n = arguments[1],
                        i = function(t, e) {
                            return n.compare(t, e)
                        }
                        ,
                        r.sort(i);
                    else {
                        if (3 === arguments.length) {
                            e = r.slice(arguments[1], arguments[2]),
                            e.sort();
                            var o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length));
                            for (r.splice(0, r.length),
                            t = 0; t < o.length; t++)
                                r.push(o[t]);
                            return
                        }
                        if (4 === arguments.length) {
                            for (e = r.slice(arguments[1], arguments[2]),
                            n = arguments[3],
                            i = function(t, e) {
                                return n.compare(t, e)
                            }
                            ,
                            e.sort(i),
                            o = r.slice(0, arguments[1]).concat(e, r.slice(arguments[2], r.length)),
                            r.splice(0, r.length),
                            t = 0; t < o.length; t++)
                                r.push(o[t]);
                            return
                        }
                    }
                }
                ,
                ut.asList = function(t) {
                    for (var e = new I, n = 0, i = t.length; n < i; n++)
                        e.add(t[n]);
                    return e
                }
                ,
                e(lt.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return lt
                    }
                }),
                lt.toDimensionSymbol = function(t) {
                    switch (t) {
                    case lt.FALSE:
                        return lt.SYM_FALSE;
                    case lt.TRUE:
                        return lt.SYM_TRUE;
                    case lt.DONTCARE:
                        return lt.SYM_DONTCARE;
                    case lt.P:
                        return lt.SYM_P;
                    case lt.L:
                        return lt.SYM_L;
                    case lt.A:
                        return lt.SYM_A
                    }
                    throw new i("Unknown dimension value: " + t)
                }
                ,
                lt.toDimensionValue = function(t) {
                    switch (O.toUpperCase(t)) {
                    case lt.SYM_FALSE:
                        return lt.FALSE;
                    case lt.SYM_TRUE:
                        return lt.TRUE;
                    case lt.SYM_DONTCARE:
                        return lt.DONTCARE;
                    case lt.SYM_P:
                        return lt.P;
                    case lt.SYM_L:
                        return lt.L;
                    case lt.SYM_A:
                        return lt.A
                    }
                    throw new i("Unknown dimension symbol: " + t)
                }
                ,
                lt.P = 0,
                lt.L = 1,
                lt.A = 2,
                lt.FALSE = -1,
                lt.TRUE = -2,
                lt.DONTCARE = -3,
                lt.SYM_FALSE = "F",
                lt.SYM_TRUE = "T",
                lt.SYM_DONTCARE = "*",
                lt.SYM_P = "0",
                lt.SYM_L = "1",
                lt.SYM_A = "2",
                e(ct.prototype, {
                    filter: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ct
                    }
                }),
                e(ht.prototype, {
                    filter: function(t, e) {},
                    isDone: function() {},
                    isGeometryChanged: function() {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ht
                    }
                }),
                c(ft, q),
                e(ft.prototype, {
                    computeEnvelopeInternal: function() {
                        for (var t = new C, e = 0; e < this.geometries.length; e++)
                            t.expandToInclude(this.geometries[e].getEnvelopeInternal());
                        return t
                    },
                    getGeometryN: function(t) {
                        return this.geometries[t]
                    },
                    getSortIndex: function() {
                        return q.SORTINDEX_GEOMETRYCOLLECTION
                    },
                    getCoordinates: function() {
                        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this.geometries.length; n++)
                            for (var i = this.geometries[n].getCoordinates(), r = 0; r < i.length; r++)
                                e++,
                                t[e] = i[r];
                        return t
                    },
                    getArea: function() {
                        for (var t = 0, e = 0; e < this.geometries.length; e++)
                            t += this.geometries[e].getArea();
                        return t
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            if (!this.isEquivalentClass(t))
                                return !1;
                            var n = t;
                            if (this.geometries.length !== n.geometries.length)
                                return !1;
                            for (var i = 0; i < this.geometries.length; i++)
                                if (!this.geometries[i].equalsExact(n.geometries[i], e))
                                    return !1;
                            return !0
                        }
                        return q.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() {
                        for (var t = 0; t < this.geometries.length; t++)
                            this.geometries[t].normalize();
                        ut.sort(this.geometries)
                    },
                    getCoordinate: function() {
                        return this.isEmpty() ? null : this.geometries[0].getCoordinate()
                    },
                    getBoundaryDimension: function() {
                        for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++)
                            t = Math.max(t, this.geometries[e].getBoundaryDimension());
                        return t
                    },
                    getDimension: function() {
                        for (var t = lt.FALSE, e = 0; e < this.geometries.length; e++)
                            t = Math.max(t, this.geometries[e].getDimension());
                        return t
                    },
                    getLength: function() {
                        for (var t = 0, e = 0; e < this.geometries.length; e++)
                            t += this.geometries[e].getLength();
                        return t
                    },
                    getNumPoints: function() {
                        for (var t = 0, e = 0; e < this.geometries.length; e++)
                            t += this.geometries[e].getNumPoints();
                        return t
                    },
                    getNumGeometries: function() {
                        return this.geometries.length
                    },
                    reverse: function() {
                        for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++)
                            e[n] = this.geometries[n].reverse();
                        return this.getFactory().createGeometryCollection(e)
                    },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = new at(ut.asList(this.geometries))
                              , n = new at(ut.asList(t.geometries));
                            return this.compare(e, n)
                        }
                        if (2 === arguments.length) {
                            for (var i = arguments[0], r = arguments[1], o = i, s = this.getNumGeometries(), a = o.getNumGeometries(), u = 0; u < s && u < a; ) {
                                var l = this.getGeometryN(u)
                                  , c = o.getGeometryN(u)
                                  , h = l.compareToSameClass(c, r);
                                if (0 !== h)
                                    return h;
                                u++
                            }
                            return u < s ? 1 : u < a ? -1 : 0
                        }
                    },
                    apply: function() {
                        if (b(arguments[0], B))
                            for (var t = arguments[0], e = 0; e < this.geometries.length; e++)
                                this.geometries[e].apply(t);
                        else if (b(arguments[0], ht)) {
                            var n = arguments[0];
                            if (0 === this.geometries.length)
                                return null;
                            for (var e = 0; e < this.geometries.length && (this.geometries[e].apply(n),
                            !n.isDone()); e++)
                                ;
                            n.isGeometryChanged() && this.geometryChanged()
                        } else if (b(arguments[0], ct)) {
                            var i = arguments[0];
                            i.filter(this);
                            for (var e = 0; e < this.geometries.length; e++)
                                this.geometries[e].apply(i)
                        } else if (b(arguments[0], k)) {
                            var r = arguments[0];
                            r.filter(this);
                            for (var e = 0; e < this.geometries.length; e++)
                                this.geometries[e].apply(r)
                        }
                    },
                    getBoundary: function() {
                        return this.checkNotGeometryCollection(this),
                        f.shouldNeverReachHere(),
                        null
                    },
                    clone: function() {
                        var t = q.prototype.clone.call(this);
                        t.geometries = new Array(this.geometries.length).fill(null);
                        for (var e = 0; e < this.geometries.length; e++)
                            t.geometries[e] = this.geometries[e].clone();
                        return t
                    },
                    getGeometryType: function() {
                        return "GeometryCollection"
                    },
                    copy: function() {
                        for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++)
                            t[e] = this.geometries[e].copy();
                        return new ft(t,this.factory)
                    },
                    isEmpty: function() {
                        for (var t = 0; t < this.geometries.length; t++)
                            if (!this.geometries[t].isEmpty())
                                return !1;
                        return !0
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ft
                    }
                }),
                ft.serialVersionUID = -0x4f07bcb1f857d800,
                c(dt, ft),
                e(dt.prototype, {
                    getSortIndex: function() {
                        return q.SORTINDEX_MULTILINESTRING
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return !!this.isEquivalentClass(t) && ft.prototype.equalsExact.call(this, t, e)
                        }
                        return ft.prototype.equalsExact.apply(this, arguments)
                    },
                    getBoundaryDimension: function() {
                        return this.isClosed() ? lt.FALSE : 0
                    },
                    isClosed: function() {
                        if (this.isEmpty())
                            return !1;
                        for (var t = 0; t < this.geometries.length; t++)
                            if (!this.geometries[t].isClosed())
                                return !1;
                        return !0
                    },
                    getDimension: function() {
                        return 1
                    },
                    reverse: function() {
                        for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++)
                            e[t - 1 - n] = this.geometries[n].reverse();
                        return this.getFactory().createMultiLineString(e)
                    },
                    getBoundary: function() {
                        return new gt(this).getBoundary()
                    },
                    getGeometryType: function() {
                        return "MultiLineString"
                    },
                    copy: function() {
                        for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++)
                            t[e] = this.geometries[e].copy();
                        return new dt(t,this.factory)
                    },
                    interfaces_: function() {
                        return [ot]
                    },
                    getClass: function() {
                        return dt
                    }
                }),
                dt.serialVersionUID = 0x7155d2ab4afa8000,
                e(gt.prototype, {
                    boundaryMultiLineString: function(t) {
                        if (this.geom.isEmpty())
                            return this.getEmptyMultiPoint();
                        var e = this.computeBoundaryCoordinates(t);
                        return 1 === e.length ? this.geomFact.createPoint(e[0]) : this.geomFact.createMultiPointFromCoords(e)
                    },
                    getBoundary: function() {
                        return this.geom instanceof wt ? this.boundaryLineString(this.geom) : this.geom instanceof dt ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary()
                    },
                    boundaryLineString: function(t) {
                        if (this.geom.isEmpty())
                            return this.getEmptyMultiPoint();
                        if (t.isClosed()) {
                            return this.bnRule.isInBoundary(2) ? t.getStartPoint() : this.geomFact.createMultiPoint()
                        }
                        return this.geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
                    },
                    getEmptyMultiPoint: function() {
                        return this.geomFact.createMultiPoint()
                    },
                    computeBoundaryCoordinates: function(t) {
                        var e = new I;
                        this.endpointMap = new rt;
                        for (var n = 0; n < t.getNumGeometries(); n++) {
                            var i = t.getGeometryN(n);
                            0 !== i.getNumPoints() && (this.addEndpoint(i.getCoordinateN(0)),
                            this.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)))
                        }
                        for (var r = this.endpointMap.entrySet().iterator(); r.hasNext(); ) {
                            var o = r.next()
                              , s = o.getValue()
                              , a = s.count;
                            this.bnRule.isInBoundary(a) && e.add(o.getKey())
                        }
                        return X.toCoordinateArray(e)
                    },
                    addEndpoint: function(t) {
                        var e = this.endpointMap.get(t);
                        null === e && (e = new pt,
                        this.endpointMap.put(t, e)),
                        e.count++
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return gt
                    }
                }),
                gt.getBoundary = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0]
                          , e = new gt(t);
                        return e.getBoundary()
                    }
                    if (2 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , e = new gt(n,i);
                        return e.getBoundary()
                    }
                }
                ,
                e(pt.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return pt
                    }
                }),
                e(Nt.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Nt
                    }
                }),
                Nt.chars = function(t, e) {
                    for (var n = new Array(e).fill(null), i = 0; i < e; i++)
                        n[i] = t;
                    return new String(n)
                }
                ,
                Nt.getStackTrace = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0]
                          , e = new Et
                          , n = new mt(e);
                        return t.printStackTrace(n),
                        e.toString()
                    }
                    if (2 === arguments.length) {
                        for (var i = arguments[0], r = arguments[1], o = "", s = new yt(Nt.getStackTrace(i)), a = new It(s), u = 0; u < r; u++)
                            try {
                                o += a.readLine() + Nt.NEWLINE
                            } catch (t) {
                                if (!(t instanceof xt))
                                    throw t;
                                f.shouldNeverReachHere()
                            }
                        return o
                    }
                }
                ,
                Nt.split = function(t, e) {
                    for (var n = e.length, i = new I, r = "" + t, o = r.indexOf(e); o >= 0; ) {
                        var s = r.substring(0, o);
                        i.add(s),
                        r = r.substring(o + n),
                        o = r.indexOf(e)
                    }
                    r.length > 0 && i.add(r);
                    for (var a = new Array(i.size()).fill(null), u = 0; u < a.length; u++)
                        a[u] = i.get(u);
                    return a
                }
                ,
                Nt.toString = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Nt.SIMPLE_ORDINATE_FORMAT.format(t)
                    }
                }
                ,
                Nt.spaces = function(t) {
                    return Nt.chars(" ", t)
                }
                ,
                Nt.NEWLINE = D.getProperty("line.separator"),
                Nt.SIMPLE_ORDINATE_FORMAT = new vt("0.#"),
                e(Ct.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ct
                    }
                }),
                Ct.copyCoord = function(t, e, n, i) {
                    for (var r = Math.min(t.getDimension(), n.getDimension()), o = 0; o < r; o++)
                        n.setOrdinate(i, o, t.getOrdinate(e, o))
                }
                ,
                Ct.isRing = function(t) {
                    var e = t.size();
                    return 0 === e || !(e <= 3) && t.getOrdinate(0, A.X) === t.getOrdinate(e - 1, A.X) && t.getOrdinate(0, A.Y) === t.getOrdinate(e - 1, A.Y)
                }
                ,
                Ct.isEqual = function(t, e) {
                    var n = t.size();
                    if (n !== e.size())
                        return !1;
                    for (var i = Math.min(t.getDimension(), e.getDimension()), o = 0; o < n; o++)
                        for (var s = 0; s < i; s++) {
                            var a = t.getOrdinate(o, s)
                              , u = e.getOrdinate(o, s);
                            if (!(t.getOrdinate(o, s) === e.getOrdinate(o, s) || r.isNaN(a) && r.isNaN(u)))
                                return !1
                        }
                    return !0
                }
                ,
                Ct.extend = function(t, e, n) {
                    var i = t.create(n, e.getDimension())
                      , r = e.size();
                    if (Ct.copy(e, 0, i, 0, r),
                    r > 0)
                        for (var o = r; o < n; o++)
                            Ct.copy(e, r - 1, i, o, 1);
                    return i
                }
                ,
                Ct.reverse = function(t) {
                    for (var e = t.size() - 1, n = Math.trunc(e / 2), i = 0; i <= n; i++)
                        Ct.swap(t, i, e - i)
                }
                ,
                Ct.swap = function(t, e, n) {
                    if (e === n)
                        return null;
                    for (var i = 0; i < t.getDimension(); i++) {
                        var r = t.getOrdinate(e, i);
                        t.setOrdinate(e, i, t.getOrdinate(n, i)),
                        t.setOrdinate(n, i, r)
                    }
                }
                ,
                Ct.copy = function(t, e, n, i, r) {
                    for (var o = 0; o < r; o++)
                        Ct.copyCoord(t, e + o, n, i + o)
                }
                ,
                Ct.toString = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0]
                          , e = t.size();
                        if (0 === e)
                            return "()";
                        var n = t.getDimension()
                          , i = new T;
                        i.append("(");
                        for (var r = 0; r < e; r++) {
                            r > 0 && i.append(" ");
                            for (var o = 0; o < n; o++)
                                o > 0 && i.append(","),
                                i.append(Nt.toString(t.getOrdinate(r, o)))
                        }
                        return i.append(")"),
                        i.toString()
                    }
                }
                ,
                Ct.ensureValidRing = function(t, e) {
                    var n = e.size();
                    return 0 === n ? e : n <= 3 ? Ct.createClosedRing(t, e, 4) : e.getOrdinate(0, A.X) === e.getOrdinate(n - 1, A.X) && e.getOrdinate(0, A.Y) === e.getOrdinate(n - 1, A.Y) ? e : Ct.createClosedRing(t, e, n + 1)
                }
                ,
                Ct.createClosedRing = function(t, e, n) {
                    var i = t.create(n, e.getDimension())
                      , r = e.size();
                    Ct.copy(e, 0, i, 0, r);
                    for (var o = r; o < n; o++)
                        Ct.copy(e, 0, i, o, 1);
                    return i
                }
                ,
                c(wt, q),
                e(wt.prototype, {
                    computeEnvelopeInternal: function() {
                        return this.isEmpty() ? new C : this.points.expandEnvelope(new C)
                    },
                    isRing: function() {
                        return this.isClosed() && this.isSimple()
                    },
                    getSortIndex: function() {
                        return q.SORTINDEX_LINESTRING
                    },
                    getCoordinates: function() {
                        return this.points.toCoordinateArray()
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            if (!this.isEquivalentClass(t))
                                return !1;
                            var n = t;
                            if (this.points.size() !== n.points.size())
                                return !1;
                            for (var i = 0; i < this.points.size(); i++)
                                if (!this.equal(this.points.getCoordinate(i), n.points.getCoordinate(i), e))
                                    return !1;
                            return !0
                        }
                        return q.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() {
                        for (var t = 0; t < Math.trunc(this.points.size() / 2); t++) {
                            var e = this.points.size() - 1 - t;
                            if (!this.points.getCoordinate(t).equals(this.points.getCoordinate(e)))
                                return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e)) > 0 && Ct.reverse(this.points),
                                null
                        }
                    },
                    getCoordinate: function() {
                        return this.isEmpty() ? null : this.points.getCoordinate(0)
                    },
                    getBoundaryDimension: function() {
                        return this.isClosed() ? lt.FALSE : 0
                    },
                    isClosed: function() {
                        return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
                    },
                    getEndPoint: function() {
                        return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
                    },
                    getDimension: function() {
                        return 1
                    },
                    getLength: function() {
                        return le.computeLength(this.points)
                    },
                    getNumPoints: function() {
                        return this.points.size()
                    },
                    reverse: function() {
                        var t = this.points.copy();
                        return Ct.reverse(t),
                        this.getFactory().createLineString(t)
                    },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = t, n = 0, i = 0; n < this.points.size() && i < e.points.size(); ) {
                                var r = this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));
                                if (0 !== r)
                                    return r;
                                n++,
                                i++
                            }
                            return n < this.points.size() ? 1 : i < e.points.size() ? -1 : 0
                        }
                        if (2 === arguments.length) {
                            var o = arguments[0]
                              , s = arguments[1]
                              , e = o;
                            return s.compare(this.points, e.points)
                        }
                    },
                    apply: function() {
                        if (b(arguments[0], B))
                            for (var t = arguments[0], e = 0; e < this.points.size(); e++)
                                t.filter(this.points.getCoordinate(e));
                        else if (b(arguments[0], ht)) {
                            var n = arguments[0];
                            if (0 === this.points.size())
                                return null;
                            for (var e = 0; e < this.points.size() && (n.filter(this.points, e),
                            !n.isDone()); e++)
                                ;
                            n.isGeometryChanged() && this.geometryChanged()
                        } else if (b(arguments[0], ct)) {
                            var i = arguments[0];
                            i.filter(this)
                        } else if (b(arguments[0], k)) {
                            var r = arguments[0];
                            r.filter(this)
                        }
                    },
                    getBoundary: function() {
                        return new gt(this).getBoundary()
                    },
                    isEquivalentClass: function(t) {
                        return t instanceof wt
                    },
                    clone: function() {
                        var t = q.prototype.clone.call(this);
                        return t.points = this.points.clone(),
                        t
                    },
                    getCoordinateN: function(t) {
                        return this.points.getCoordinate(t)
                    },
                    getGeometryType: function() {
                        return "LineString"
                    },
                    copy: function() {
                        return new wt(this.points.copy(),this.factory)
                    },
                    getCoordinateSequence: function() {
                        return this.points
                    },
                    isEmpty: function() {
                        return 0 === this.points.size()
                    },
                    init: function(t) {
                        if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])),
                        1 === t.size())
                            throw new i("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
                        this.points = t
                    },
                    isCoordinate: function(t) {
                        for (var e = 0; e < this.points.size(); e++)
                            if (this.points.getCoordinate(e).equals(t))
                                return !0;
                        return !1
                    },
                    getStartPoint: function() {
                        return this.isEmpty() ? null : this.getPointN(0)
                    },
                    getPointN: function(t) {
                        return this.getFactory().createPoint(this.points.getCoordinate(t))
                    },
                    interfaces_: function() {
                        return [ot]
                    },
                    getClass: function() {
                        return wt
                    }
                }),
                wt.serialVersionUID = 0x2b2b51ba435c8e00,
                e(_t.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return _t
                    }
                }),
                c(St, q),
                e(St.prototype, {
                    computeEnvelopeInternal: function() {
                        if (this.isEmpty())
                            return new C;
                        var t = new C;
                        return t.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0)),
                        t
                    },
                    getSortIndex: function() {
                        return q.SORTINDEX_POINT
                    },
                    getCoordinates: function() {
                        return this.isEmpty() ? [] : [this.getCoordinate()]
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e))
                        }
                        return q.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() {},
                    getCoordinate: function() {
                        return 0 !== this.coordinates.size() ? this.coordinates.getCoordinate(0) : null
                    },
                    getBoundaryDimension: function() {
                        return lt.FALSE
                    },
                    getDimension: function() {
                        return 0
                    },
                    getNumPoints: function() {
                        return this.isEmpty() ? 0 : 1
                    },
                    reverse: function() {
                        return this.copy()
                    },
                    getX: function() {
                        if (null === this.getCoordinate())
                            throw new IllegalStateException("getX called on empty Point");
                        return this.getCoordinate().x
                    },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = t;
                            return this.getCoordinate().compareTo(e.getCoordinate())
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , e = n;
                            return i.compare(this.coordinates, e.coordinates)
                        }
                    },
                    apply: function() {
                        if (b(arguments[0], B)) {
                            var t = arguments[0];
                            if (this.isEmpty())
                                return null;
                            t.filter(this.getCoordinate())
                        } else if (b(arguments[0], ht)) {
                            var e = arguments[0];
                            if (this.isEmpty())
                                return null;
                            e.filter(this.coordinates, 0),
                            e.isGeometryChanged() && this.geometryChanged()
                        } else if (b(arguments[0], ct)) {
                            var n = arguments[0];
                            n.filter(this)
                        } else if (b(arguments[0], k)) {
                            var i = arguments[0];
                            i.filter(this)
                        }
                    },
                    getBoundary: function() {
                        return this.getFactory().createGeometryCollection(null)
                    },
                    clone: function() {
                        var t = q.prototype.clone.call(this);
                        return t.coordinates = this.coordinates.clone(),
                        t
                    },
                    getGeometryType: function() {
                        return "Point"
                    },
                    copy: function() {
                        return new St(this.coordinates.copy(),this.factory)
                    },
                    getCoordinateSequence: function() {
                        return this.coordinates
                    },
                    getY: function() {
                        if (null === this.getCoordinate())
                            throw new IllegalStateException("getY called on empty Point");
                        return this.getCoordinate().y
                    },
                    isEmpty: function() {
                        return 0 === this.coordinates.size()
                    },
                    init: function(t) {
                        null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])),
                        f.isTrue(t.size() <= 1),
                        this.coordinates = t
                    },
                    isSimple: function() {
                        return !0
                    },
                    interfaces_: function() {
                        return [_t]
                    },
                    getClass: function() {
                        return St
                    }
                }),
                St.serialVersionUID = 0x44077bad161cbc00,
                e(bt.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return bt
                    }
                }),
                c(Lt, q),
                e(Lt.prototype, {
                    computeEnvelopeInternal: function() {
                        return this.shell.getEnvelopeInternal()
                    },
                    getSortIndex: function() {
                        return q.SORTINDEX_POLYGON
                    },
                    getCoordinates: function() {
                        if (this.isEmpty())
                            return [];
                        for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this.shell.getCoordinates(), i = 0; i < n.length; i++)
                            e++,
                            t[e] = n[i];
                        for (var r = 0; r < this.holes.length; r++)
                            for (var o = this.holes[r].getCoordinates(), s = 0; s < o.length; s++)
                                e++,
                                t[e] = o[s];
                        return t
                    },
                    getArea: function() {
                        var t = 0;
                        t += Math.abs(le.signedArea(this.shell.getCoordinateSequence()));
                        for (var e = 0; e < this.holes.length; e++)
                            t -= Math.abs(le.signedArea(this.holes[e].getCoordinateSequence()));
                        return t
                    },
                    isRectangle: function() {
                        if (0 !== this.getNumInteriorRing())
                            return !1;
                        if (null === this.shell)
                            return !1;
                        if (5 !== this.shell.getNumPoints())
                            return !1;
                        for (var t = this.shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
                            var i = t.getX(n);
                            if (i !== e.getMinX() && i !== e.getMaxX())
                                return !1;
                            var r = t.getY(n);
                            if (r !== e.getMinY() && r !== e.getMaxY())
                                return !1
                        }
                        for (var o = t.getX(0), s = t.getY(0), n = 1; n <= 4; n++) {
                            var i = t.getX(n)
                              , r = t.getY(n);
                            if (i !== o === (r !== s))
                                return !1;
                            o = i,
                            s = r
                        }
                        return !0
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            if (!this.isEquivalentClass(t))
                                return !1;
                            var n = t
                              , i = this.shell
                              , r = n.shell;
                            if (!i.equalsExact(r, e))
                                return !1;
                            if (this.holes.length !== n.holes.length)
                                return !1;
                            for (var o = 0; o < this.holes.length; o++)
                                if (!this.holes[o].equalsExact(n.holes[o], e))
                                    return !1;
                            return !0
                        }
                        return q.prototype.equalsExact.apply(this, arguments)
                    },
                    normalize: function() {
                        if (0 === arguments.length) {
                            this.normalize(this.shell, !0);
                            for (var t = 0; t < this.holes.length; t++)
                                this.normalize(this.holes[t], !1);
                            ut.sort(this.holes)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            if (e.isEmpty())
                                return null;
                            var i = new Array(e.getCoordinates().length - 1).fill(null);
                            D.arraycopy(e.getCoordinates(), 0, i, 0, i.length);
                            var r = X.minCoordinate(e.getCoordinates());
                            X.scroll(i, r),
                            D.arraycopy(i, 0, e.getCoordinates(), 0, i.length),
                            e.getCoordinates()[i.length] = i[0],
                            le.isCCW(e.getCoordinates()) === n && X.reverse(e.getCoordinates())
                        }
                    },
                    getCoordinate: function() {
                        return this.shell.getCoordinate()
                    },
                    getNumInteriorRing: function() {
                        return this.holes.length
                    },
                    getBoundaryDimension: function() {
                        return 1
                    },
                    getDimension: function() {
                        return 2
                    },
                    getLength: function() {
                        var t = 0;
                        t += this.shell.getLength();
                        for (var e = 0; e < this.holes.length; e++)
                            t += this.holes[e].getLength();
                        return t
                    },
                    getNumPoints: function() {
                        for (var t = this.shell.getNumPoints(), e = 0; e < this.holes.length; e++)
                            t += this.holes[e].getNumPoints();
                        return t
                    },
                    reverse: function() {
                        var t = this.copy();
                        t.shell = this.shell.copy().reverse(),
                        t.holes = new Array(this.holes.length).fill(null);
                        for (var e = 0; e < this.holes.length; e++)
                            t.holes[e] = this.holes[e].copy().reverse();
                        return t
                    },
                    convexHull: function() {
                        return this.getExteriorRing().convexHull()
                    },
                    compareToSameClass: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = this.shell
                              , n = t.shell;
                            return e.compareToSameClass(n)
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0]
                              , r = arguments[1]
                              , o = i
                              , e = this.shell
                              , n = o.shell
                              , s = e.compareToSameClass(n, r);
                            if (0 !== s)
                                return s;
                            for (var a = this.getNumInteriorRing(), u = o.getNumInteriorRing(), l = 0; l < a && l < u; ) {
                                var c = this.getInteriorRingN(l)
                                  , h = o.getInteriorRingN(l)
                                  , f = c.compareToSameClass(h, r);
                                if (0 !== f)
                                    return f;
                                l++
                            }
                            return l < a ? 1 : l < u ? -1 : 0
                        }
                    },
                    apply: function() {
                        if (b(arguments[0], B)) {
                            var t = arguments[0];
                            this.shell.apply(t);
                            for (var e = 0; e < this.holes.length; e++)
                                this.holes[e].apply(t)
                        } else if (b(arguments[0], ht)) {
                            var n = arguments[0];
                            if (this.shell.apply(n),
                            !n.isDone())
                                for (var e = 0; e < this.holes.length && (this.holes[e].apply(n),
                                !n.isDone()); e++)
                                    ;
                            n.isGeometryChanged() && this.geometryChanged()
                        } else if (b(arguments[0], ct)) {
                            var i = arguments[0];
                            i.filter(this)
                        } else if (b(arguments[0], k)) {
                            var r = arguments[0];
                            r.filter(this),
                            this.shell.apply(r);
                            for (var e = 0; e < this.holes.length; e++)
                                this.holes[e].apply(r)
                        }
                    },
                    getBoundary: function() {
                        if (this.isEmpty())
                            return this.getFactory().createMultiLineString();
                        var t = new Array(this.holes.length + 1).fill(null);
                        t[0] = this.shell;
                        for (var e = 0; e < this.holes.length; e++)
                            t[e + 1] = this.holes[e];
                        return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
                    },
                    clone: function() {
                        var t = q.prototype.clone.call(this);
                        t.shell = this.shell.clone(),
                        t.holes = new Array(this.holes.length).fill(null);
                        for (var e = 0; e < this.holes.length; e++)
                            t.holes[e] = this.holes[e].clone();
                        return t
                    },
                    getGeometryType: function() {
                        return "Polygon"
                    },
                    copy: function() {
                        for (var t = this.shell.copy(), e = new Array(this.holes.length).fill(null), n = 0; n < e.length; n++)
                            e[n] = this.holes[n].copy();
                        return new Lt(t,e,this.factory)
                    },
                    getExteriorRing: function() {
                        return this.shell
                    },
                    isEmpty: function() {
                        return this.shell.isEmpty()
                    },
                    getInteriorRingN: function(t) {
                        return this.holes[t]
                    },
                    interfaces_: function() {
                        return [bt]
                    },
                    getClass: function() {
                        return Lt
                    }
                }),
                Lt.serialVersionUID = -0x307ffefd8dc97200,
                c(Tt, ft),
                e(Tt.prototype, {
                    getSortIndex: function() {
                        return q.SORTINDEX_MULTIPOINT
                    },
                    isValid: function() {
                        return !0
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return !!this.isEquivalentClass(t) && ft.prototype.equalsExact.call(this, t, e)
                        }
                        return ft.prototype.equalsExact.apply(this, arguments)
                    },
                    getCoordinate: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.geometries[t].getCoordinate()
                        }
                        return ft.prototype.getCoordinate.apply(this, arguments)
                    },
                    getBoundaryDimension: function() {
                        return lt.FALSE
                    },
                    getDimension: function() {
                        return 0
                    },
                    getBoundary: function() {
                        return this.getFactory().createGeometryCollection(null)
                    },
                    getGeometryType: function() {
                        return "MultiPoint"
                    },
                    copy: function() {
                        for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++)
                            t[e] = this.geometries[e].copy();
                        return new Tt(t,this.factory)
                    },
                    interfaces_: function() {
                        return [_t]
                    },
                    getClass: function() {
                        return Tt
                    }
                }),
                Tt.serialVersionUID = -0x6fb1ed4162e0fc00,
                c(Rt, wt),
                e(Rt.prototype, {
                    getSortIndex: function() {
                        return q.SORTINDEX_LINEARRING
                    },
                    getBoundaryDimension: function() {
                        return lt.FALSE
                    },
                    isClosed: function() {
                        return !!this.isEmpty() || wt.prototype.isClosed.call(this)
                    },
                    reverse: function() {
                        var t = this.points.copy();
                        return Ct.reverse(t),
                        this.getFactory().createLinearRing(t)
                    },
                    validateConstruction: function() {
                        if (!this.isEmpty() && !wt.prototype.isClosed.call(this))
                            throw new i("Points of LinearRing do not form a closed linestring");
                        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < Rt.MINIMUM_VALID_SIZE)
                            throw new i("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)")
                    },
                    getGeometryType: function() {
                        return "LinearRing"
                    },
                    copy: function() {
                        return new Rt(this.points.copy(),this.factory)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Rt
                    }
                }),
                Rt.MINIMUM_VALID_SIZE = 4,
                Rt.serialVersionUID = -0x3b229e262367a600,
                c(Ot, ft),
                e(Ot.prototype, {
                    getSortIndex: function() {
                        return q.SORTINDEX_MULTIPOLYGON
                    },
                    equalsExact: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return !!this.isEquivalentClass(t) && ft.prototype.equalsExact.call(this, t, e)
                        }
                        return ft.prototype.equalsExact.apply(this, arguments)
                    },
                    getBoundaryDimension: function() {
                        return 1
                    },
                    getDimension: function() {
                        return 2
                    },
                    reverse: function() {
                        for (var t = this.geometries.length, e = new Array(t).fill(null), n = 0; n < this.geometries.length; n++)
                            e[n] = this.geometries[n].reverse();
                        return this.getFactory().createMultiPolygon(e)
                    },
                    getBoundary: function() {
                        if (this.isEmpty())
                            return this.getFactory().createMultiLineString();
                        for (var t = new I, e = 0; e < this.geometries.length; e++)
                            for (var n = this.geometries[e], i = n.getBoundary(), r = 0; r < i.getNumGeometries(); r++)
                                t.add(i.getGeometryN(r));
                        var o = new Array(t.size()).fill(null);
                        return this.getFactory().createMultiLineString(t.toArray(o))
                    },
                    getGeometryType: function() {
                        return "MultiPolygon"
                    },
                    copy: function() {
                        for (var t = new Array(this.geometries.length).fill(null), e = 0; e < t.length; e++)
                            t[e] = this.geometries[e].copy();
                        return new Ot(t,this.factory)
                    },
                    interfaces_: function() {
                        return [bt]
                    },
                    getClass: function() {
                        return Ot
                    }
                }),
                Ot.serialVersionUID = -0x7a5aa1369171980,
                e(Pt.prototype, {
                    setCopyUserData: function(t) {
                        this.isUserDataCopied = t
                    },
                    edit: function(t, e) {
                        if (null === t)
                            return null;
                        var n = this.editInternal(t, e);
                        return this.isUserDataCopied && n.setUserData(t.getUserData()),
                        n
                    },
                    editInternal: function(t, e) {
                        return null === this.factory && (this.factory = t.getFactory()),
                        t instanceof ft ? this.editGeometryCollection(t, e) : t instanceof Lt ? this.editPolygon(t, e) : t instanceof St ? e.edit(t, this.factory) : t instanceof wt ? e.edit(t, this.factory) : (f.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()),
                        null)
                    },
                    editGeometryCollection: function(t, e) {
                        for (var n = e.edit(t, this.factory), i = new I, r = 0; r < n.getNumGeometries(); r++) {
                            var o = this.edit(n.getGeometryN(r), e);
                            null === o || o.isEmpty() || i.add(o)
                        }
                        return n.getClass() === Tt ? this.factory.createMultiPoint(i.toArray([])) : n.getClass() === dt ? this.factory.createMultiLineString(i.toArray([])) : n.getClass() === Ot ? this.factory.createMultiPolygon(i.toArray([])) : this.factory.createGeometryCollection(i.toArray([]))
                    },
                    editPolygon: function(t, e) {
                        var n = e.edit(t, this.factory);
                        if (null === n && (n = this.factory.createPolygon(null)),
                        n.isEmpty())
                            return n;
                        var i = this.edit(n.getExteriorRing(), e);
                        if (null === i || i.isEmpty())
                            return this.factory.createPolygon();
                        for (var r = new I, o = 0; o < n.getNumInteriorRing(); o++) {
                            var s = this.edit(n.getInteriorRingN(o), e);
                            null === s || s.isEmpty() || r.add(s)
                        }
                        return this.factory.createPolygon(i, r.toArray([]))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Pt
                    }
                }),
                Pt.GeometryEditorOperation = Mt,
                e(At.prototype, {
                    edit: function(t, e) {
                        return t
                    },
                    interfaces_: function() {
                        return [Mt]
                    },
                    getClass: function() {
                        return At
                    }
                }),
                e(Dt.prototype, {
                    edit: function(t, e) {
                        var n = this.editCoordinates(t.getCoordinates(), t);
                        return null === n ? t : t instanceof Rt ? e.createLinearRing(n) : t instanceof wt ? e.createLineString(n) : t instanceof St ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t
                    },
                    interfaces_: function() {
                        return [Mt]
                    },
                    getClass: function() {
                        return Dt
                    }
                }),
                e(Ft.prototype, {
                    edit: function(t, e) {
                        return t instanceof Rt ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof wt ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof St ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t
                    },
                    interfaces_: function() {
                        return [Mt]
                    },
                    getClass: function() {
                        return Ft
                    }
                }),
                Pt.NoOpGeometryOperation = At,
                Pt.CoordinateOperation = Dt,
                Pt.CoordinateSequenceOperation = Ft,
                e(Gt.prototype, {
                    setOrdinate: function(t, e, n) {
                        switch (e) {
                        case A.X:
                            this.coordinates[t].x = n;
                            break;
                        case A.Y:
                            this.coordinates[t].y = n;
                            break;
                        case A.Z:
                            this.coordinates[t].z = n;
                            break;
                        default:
                            throw new i("invalid ordinateIndex")
                        }
                    },
                    size: function() {
                        return this.coordinates.length
                    },
                    getOrdinate: function(t, e) {
                        switch (e) {
                        case A.X:
                            return this.coordinates[t].x;
                        case A.Y:
                            return this.coordinates[t].y;
                        case A.Z:
                            return this.coordinates[t].z
                        }
                        return r.NaN
                    },
                    getCoordinate: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.coordinates[t]
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            n.x = this.coordinates[e].x,
                            n.y = this.coordinates[e].y,
                            n.z = this.coordinates[e].z
                        }
                    },
                    getCoordinateCopy: function(t) {
                        return new d(this.coordinates[t])
                    },
                    getDimension: function() {
                        return this.dimension
                    },
                    getX: function(t) {
                        return this.coordinates[t].x
                    },
                    clone: function() {
                        for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++)
                            t[e] = this.coordinates[e].clone();
                        return new Gt(t,this.dimension)
                    },
                    expandEnvelope: function(t) {
                        for (var e = 0; e < this.coordinates.length; e++)
                            t.expandToInclude(this.coordinates[e]);
                        return t
                    },
                    copy: function() {
                        for (var t = new Array(this.size()).fill(null), e = 0; e < this.coordinates.length; e++)
                            t[e] = this.coordinates[e].copy();
                        return new Gt(t,this.dimension)
                    },
                    toString: function() {
                        if (this.coordinates.length > 0) {
                            var t = new T(17 * this.coordinates.length);
                            t.append("("),
                            t.append(this.coordinates[0]);
                            for (var e = 1; e < this.coordinates.length; e++)
                                t.append(", "),
                                t.append(this.coordinates[e]);
                            return t.append(")"),
                            t.toString()
                        }
                        return "()"
                    },
                    getY: function(t) {
                        return this.coordinates[t].y
                    },
                    toCoordinateArray: function() {
                        return this.coordinates
                    },
                    interfaces_: function() {
                        return [A, u]
                    },
                    getClass: function() {
                        return Gt
                    }
                }),
                Gt.serialVersionUID = -0xcb44a778db18e00,
                e(kt.prototype, {
                    readResolve: function() {
                        return kt.instance()
                    },
                    create: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof Array) {
                                return new Gt(arguments[0])
                            }
                            if (b(arguments[0], A)) {
                                return new Gt(arguments[0])
                            }
                        } else if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return e > 3 && (e = 3),
                            e < 2 ? new Gt(t) : new Gt(t,e)
                        }
                    },
                    interfaces_: function() {
                        return [G, u]
                    },
                    getClass: function() {
                        return kt
                    }
                }),
                kt.instance = function() {
                    return kt.instanceObject
                }
                ,
                kt.serialVersionUID = -0x38e49fa6cf6f2e00,
                kt.instanceObject = new kt;
                var es, ns = Object.defineProperty, is = function(t, e) {
                    function n(t) {
                        return this && this.constructor === n ? (this._keys = [],
                        this._values = [],
                        this._itp = [],
                        this.objectOnly = e,
                        void (t && Bt.call(this, t))) : new n(t)
                    }
                    return e || ns(t, "size", {
                        get: Kt
                    }),
                    t.constructor = n,
                    n.prototype = t,
                    n
                }({
                    delete: Ut,
                    has: jt,
                    get: Vt,
                    set: Yt,
                    keys: Ht,
                    values: Wt,
                    entries: Jt,
                    forEach: Zt,
                    clear: Xt
                }), rs = "undefined" != typeof Map && Map.prototype.values ? Map : is;
                Qt.prototype = new J,
                Qt.prototype.get = function(t) {
                    return this.map_.get(t) || null
                }
                ,
                Qt.prototype.put = function(t, e) {
                    return this.map_.set(t, e),
                    e
                }
                ,
                Qt.prototype.values = function() {
                    for (var t = new I, e = this.map_.values(), n = e.next(); !n.done; )
                        t.add(n.value),
                        n = e.next();
                    return t
                }
                ,
                Qt.prototype.entrySet = function() {
                    var t = new Z;
                    return this.map_.entries().forEach(function(e) {
                        return t.add(e)
                    }),
                    t
                }
                ,
                Qt.prototype.size = function() {
                    return this.map_.size()
                }
                ,
                e(te.prototype, {
                    equals: function(t) {
                        if (!(t instanceof te))
                            return !1;
                        var e = t;
                        return this.modelType === e.modelType && this.scale === e.scale
                    },
                    compareTo: function(t) {
                        var e = t
                          , n = this.getMaximumSignificantDigits()
                          , i = e.getMaximumSignificantDigits();
                        return new R(n).compareTo(new R(i))
                    },
                    getScale: function() {
                        return this.scale
                    },
                    isFloating: function() {
                        return this.modelType === te.FLOATING || this.modelType === te.FLOATING_SINGLE
                    },
                    getType: function() {
                        return this.modelType
                    },
                    toString: function() {
                        var t = "UNKNOWN";
                        return this.modelType === te.FLOATING ? t = "Floating" : this.modelType === te.FLOATING_SINGLE ? t = "Floating-Single" : this.modelType === te.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"),
                        t
                    },
                    makePrecise: function() {
                        if ("number" == typeof arguments[0]) {
                            var t = arguments[0];
                            if (r.isNaN(t))
                                return t;
                            if (this.modelType === te.FLOATING_SINGLE) {
                                return t
                            }
                            return this.modelType === te.FIXED ? Math.round(t * this.scale) / this.scale : t
                        }
                        if (arguments[0]instanceof d) {
                            var e = arguments[0];
                            if (this.modelType === te.FLOATING)
                                return null;
                            e.x = this.makePrecise(e.x),
                            e.y = this.makePrecise(e.y)
                        }
                    },
                    getMaximumSignificantDigits: function() {
                        var t = 16;
                        return this.modelType === te.FLOATING ? t = 16 : this.modelType === te.FLOATING_SINGLE ? t = 6 : this.modelType === te.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))),
                        t
                    },
                    setScale: function(t) {
                        this.scale = Math.abs(t)
                    },
                    interfaces_: function() {
                        return [u, o]
                    },
                    getClass: function() {
                        return te
                    }
                }),
                te.mostPrecise = function(t, e) {
                    return t.compareTo(e) >= 0 ? t : e
                }
                ,
                e(ee.prototype, {
                    readResolve: function() {
                        return ee.nameToTypeMap.get(this.name)
                    },
                    toString: function() {
                        return this.name
                    },
                    interfaces_: function() {
                        return [u]
                    },
                    getClass: function() {
                        return ee
                    }
                }),
                ee.serialVersionUID = -552860263173159e4,
                ee.nameToTypeMap = new Qt,
                te.Type = ee,
                te.serialVersionUID = 0x6bee6404e9a25c00,
                te.FIXED = new ee("FIXED"),
                te.FLOATING = new ee("FLOATING"),
                te.FLOATING_SINGLE = new ee("FLOATING SINGLE"),
                te.maximumPreciseValue = 9007199254740992,
                e(ne.prototype, {
                    toGeometry: function(t) {
                        return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new d(t.getMinX(),t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new d(t.getMinX(),t.getMinY()), new d(t.getMaxX(),t.getMaxY())]) : this.createPolygon(this.createLinearRing([new d(t.getMinX(),t.getMinY()), new d(t.getMinX(),t.getMaxY()), new d(t.getMaxX(),t.getMaxY()), new d(t.getMaxX(),t.getMinY()), new d(t.getMinX(),t.getMinY())]), null)
                    },
                    createLineString: function() {
                        if (0 === arguments.length)
                            return this.createLineString(this.getCoordinateSequenceFactory().create([]));
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof Array) {
                                var t = arguments[0];
                                return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                            }
                            if (b(arguments[0], A)) {
                                return new wt(arguments[0],this)
                            }
                        }
                    },
                    createMultiLineString: function() {
                        if (0 === arguments.length)
                            return new dt(null,this);
                        if (1 === arguments.length) {
                            return new dt(arguments[0],this)
                        }
                    },
                    buildGeometry: function(t) {
                        for (var e = null, n = !1, i = !1, r = t.iterator(); r.hasNext(); ) {
                            var o = r.next()
                              , s = o.getClass();
                            null === e && (e = s),
                            s !== e && (n = !0),
                            o.isGeometryCollectionOrDerived() && (i = !0)
                        }
                        if (null === e)
                            return this.createGeometryCollection();
                        if (n || i)
                            return this.createGeometryCollection(ne.toGeometryArray(t));
                        var a = t.iterator().next();
                        if (t.size() > 1) {
                            if (a instanceof Lt)
                                return this.createMultiPolygon(ne.toPolygonArray(t));
                            if (a instanceof wt)
                                return this.createMultiLineString(ne.toLineStringArray(t));
                            if (a instanceof St)
                                return this.createMultiPoint(ne.toPointArray(t));
                            f.shouldNeverReachHere("Unhandled class: " + a.getClass().getName())
                        }
                        return a
                    },
                    createMultiPointFromCoords: function(t) {
                        return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                    },
                    createPoint: function() {
                        if (0 === arguments.length)
                            return this.createPoint(this.getCoordinateSequenceFactory().create([]));
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof d) {
                                var t = arguments[0];
                                return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null)
                            }
                            if (b(arguments[0], A)) {
                                return new St(arguments[0],this)
                            }
                        }
                    },
                    getCoordinateSequenceFactory: function() {
                        return this.coordinateSequenceFactory
                    },
                    createPolygon: function() {
                        if (0 === arguments.length)
                            return new Lt(null,null,this);
                        if (1 === arguments.length) {
                            if (b(arguments[0], A)) {
                                var t = arguments[0];
                                return this.createPolygon(this.createLinearRing(t))
                            }
                            if (arguments[0]instanceof Array) {
                                var e = arguments[0];
                                return this.createPolygon(this.createLinearRing(e))
                            }
                            if (arguments[0]instanceof Rt) {
                                var n = arguments[0];
                                return this.createPolygon(n, null)
                            }
                        } else if (2 === arguments.length) {
                            var i = arguments[0]
                              , r = arguments[1];
                            return new Lt(i,r,this)
                        }
                    },
                    getSRID: function() {
                        return this.SRID
                    },
                    createGeometryCollection: function() {
                        if (0 === arguments.length)
                            return new ft(null,this);
                        if (1 === arguments.length) {
                            return new ft(arguments[0],this)
                        }
                    },
                    createGeometry: function(t) {
                        return new Pt(this).edit(t, {
                            edit: function() {
                                if (2 === arguments.length) {
                                    var t = arguments[0];
                                    return arguments[1],
                                    this.coordinateSequenceFactory.create(t)
                                }
                            }
                        })
                    },
                    getPrecisionModel: function() {
                        return this.precisionModel
                    },
                    createLinearRing: function() {
                        if (0 === arguments.length)
                            return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof Array) {
                                var t = arguments[0];
                                return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                            }
                            if (b(arguments[0], A)) {
                                return new Rt(arguments[0],this)
                            }
                        }
                    },
                    createMultiPolygon: function() {
                        if (0 === arguments.length)
                            return new Ot(null,this);
                        if (1 === arguments.length) {
                            return new Ot(arguments[0],this)
                        }
                    },
                    createMultiPoint: function() {
                        if (0 === arguments.length)
                            return new Tt(null,this);
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof Array) {
                                return new Tt(arguments[0],this)
                            }
                            if (arguments[0]instanceof Array) {
                                var t = arguments[0];
                                return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                            }
                            if (b(arguments[0], A)) {
                                var e = arguments[0];
                                if (null === e)
                                    return this.createMultiPoint(new Array(0).fill(null));
                                for (var n = new Array(e.size()).fill(null), i = 0; i < e.size(); i++) {
                                    var r = this.getCoordinateSequenceFactory().create(1, e.getDimension());
                                    Ct.copy(e, i, r, 0, 1),
                                    n[i] = this.createPoint(r)
                                }
                                return this.createMultiPoint(n)
                            }
                        }
                    },
                    interfaces_: function() {
                        return [u]
                    },
                    getClass: function() {
                        return ne
                    }
                }),
                ne.toMultiPolygonArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.toGeometryArray = function(t) {
                    if (null === t)
                        return null;
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.getDefaultCoordinateSequenceFactory = function() {
                    return kt.instance()
                }
                ,
                ne.toMultiLineStringArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.toLineStringArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.toMultiPointArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.toLinearRingArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.toPointArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.toPolygonArray = function(t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e)
                }
                ,
                ne.createPointFromInternalCoord = function(t, e) {
                    return e.getPrecisionModel().makePrecise(t),
                    e.getFactory().createPoint(t)
                }
                ,
                ne.serialVersionUID = -0x5ea75f2051eeb400;
                var os = {
                    typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
                    emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
                    spaces: /\s+/,
                    parenComma: /\)\s*,\s*\(/,
                    doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
                    trimParens: /^\s*\(?(.*?)\)?\s*$/
                };
                e(ie.prototype, {
                    read: function(t) {
                        var e, n, i;
                        t = t.replace(/[\n\r]/g, " ");
                        var r = os.typeStr.exec(t);
                        if (-1 !== t.search("EMPTY") && (r = os.emptyTypeStr.exec(t),
                        r[2] = void 0),
                        r && (n = r[1].toLowerCase(),
                        i = r[2],
                        as[n] && (e = as[n].apply(this, [i]))),
                        void 0 === e)
                            throw new Error("Could not parse WKT " + t);
                        return e
                    },
                    write: function(t) {
                        return this.extractGeometry(t)
                    },
                    extractGeometry: function(t) {
                        var e = t.getGeometryType().toLowerCase();
                        if (!ss[e])
                            return null;
                        var n = e.toUpperCase();
                        return t.isEmpty() ? n + " EMPTY" : n + "(" + ss[e].apply(this, [t]) + ")"
                    }
                });
                var ss = {
                    coordinate: function(t) {
                        return t.x + " " + t.y
                    },
                    point: function(t) {
                        return ss.coordinate.call(this, t.coordinates.coordinates[0])
                    },
                    multipoint: function(t) {
                        for (var e = [], n = 0, i = t.geometries.length; n < i; ++n)
                            e.push("(" + ss.point.apply(this, [t.geometries[n]]) + ")");
                        return e.join(",")
                    },
                    linestring: function(t) {
                        for (var e = [], n = 0, i = t.points.coordinates.length; n < i; ++n)
                            e.push(ss.coordinate.apply(this, [t.points.coordinates[n]]));
                        return e.join(",")
                    },
                    linearring: function(t) {
                        for (var e = [], n = 0, i = t.points.coordinates.length; n < i; ++n)
                            e.push(ss.coordinate.apply(this, [t.points.coordinates[n]]));
                        return e.join(",")
                    },
                    multilinestring: function(t) {
                        for (var e = [], n = 0, i = t.geometries.length; n < i; ++n)
                            e.push("(" + ss.linestring.apply(this, [t.geometries[n]]) + ")");
                        return e.join(",")
                    },
                    polygon: function(t) {
                        var e = [];
                        e.push("(" + ss.linestring.apply(this, [t.shell]) + ")");
                        for (var n = 0, i = t.holes.length; n < i; ++n)
                            e.push("(" + ss.linestring.apply(this, [t.holes[n]]) + ")");
                        return e.join(",")
                    },
                    multipolygon: function(t) {
                        for (var e = [], n = 0, i = t.geometries.length; n < i; ++n)
                            e.push("(" + ss.polygon.apply(this, [t.geometries[n]]) + ")");
                        return e.join(",")
                    },
                    geometrycollection: function(t) {
                        for (var e = [], n = 0, i = t.geometries.length; n < i; ++n)
                            e.push(this.extractGeometry(t.geometries[n]));
                        return e.join(",")
                    }
                }
                  , as = {
                    point: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createPoint();
                        var e = t.trim().split(os.spaces);
                        return this.geometryFactory.createPoint(new d(Number.parseFloat(e[0]),Number.parseFloat(e[1])))
                    },
                    multipoint: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createMultiPoint();
                        for (var e, n = t.trim().split(","), i = [], r = 0, o = n.length; r < o; ++r)
                            e = n[r].replace(os.trimParens, "$1"),
                            i.push(as.point.apply(this, [e]));
                        return this.geometryFactory.createMultiPoint(i)
                    },
                    linestring: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createLineString();
                        for (var e, n = t.trim().split(","), i = [], r = 0, o = n.length; r < o; ++r)
                            e = n[r].trim().split(os.spaces),
                            i.push(new d(Number.parseFloat(e[0]),Number.parseFloat(e[1])));
                        return this.geometryFactory.createLineString(i)
                    },
                    linearring: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createLinearRing();
                        for (var e, n = t.trim().split(","), i = [], r = 0, o = n.length; r < o; ++r)
                            e = n[r].trim().split(os.spaces),
                            i.push(new d(Number.parseFloat(e[0]),Number.parseFloat(e[1])));
                        return this.geometryFactory.createLinearRing(i)
                    },
                    multilinestring: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createMultiLineString();
                        for (var e, n = t.trim().split(os.parenComma), i = [], r = 0, o = n.length; r < o; ++r)
                            e = n[r].replace(os.trimParens, "$1"),
                            i.push(as.linestring.apply(this, [e]));
                        return this.geometryFactory.createMultiLineString(i)
                    },
                    polygon: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createPolygon();
                        for (var e, n, i, r, o = t.trim().split(os.parenComma), s = [], a = 0, u = o.length; a < u; ++a)
                            e = o[a].replace(os.trimParens, "$1"),
                            n = as.linestring.apply(this, [e]),
                            i = this.geometryFactory.createLinearRing(n.points),
                            0 === a ? r = i : s.push(i);
                        return this.geometryFactory.createPolygon(r, s)
                    },
                    multipolygon: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createMultiPolygon();
                        for (var e, n = t.trim().split(os.doubleParenComma), i = [], r = 0, o = n.length; r < o; ++r)
                            e = n[r].replace(os.trimParens, "$1"),
                            i.push(as.polygon.apply(this, [e]));
                        return this.geometryFactory.createMultiPolygon(i)
                    },
                    geometrycollection: function(t) {
                        if (void 0 === t)
                            return this.geometryFactory.createGeometryCollection();
                        t = t.replace(/,\s*([A-Za-z])/g, "|$1");
                        for (var e = t.trim().split("|"), n = [], i = 0, r = e.length; i < r; ++i)
                            n.push(this.read(e[i]));
                        return this.geometryFactory.createGeometryCollection(n)
                    }
                };
                e(re.prototype, {
                    write: function(t) {
                        return this.parser.write(t)
                    }
                }),
                e(re, {
                    toLineString: function(t, e) {
                        if (2 !== arguments.length)
                            throw new Error("Not implemented");
                        return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
                    }
                }),
                e(oe.prototype, {
                    getIndexAlongSegment: function(t, e) {
                        return this.computeIntLineIndex(),
                        this.intLineIndex[t][e]
                    },
                    getTopologySummary: function() {
                        var t = new T;
                        return this.isEndPoint() && t.append(" endpoint"),
                        this._isProper && t.append(" proper"),
                        this.isCollinear() && t.append(" collinear"),
                        t.toString()
                    },
                    computeIntersection: function(t, e, n, i) {
                        this.inputLines[0][0] = t,
                        this.inputLines[0][1] = e,
                        this.inputLines[1][0] = n,
                        this.inputLines[1][1] = i,
                        this.result = this.computeIntersect(t, e, n, i)
                    },
                    getIntersectionNum: function() {
                        return this.result
                    },
                    computeIntLineIndex: function() {
                        if (0 === arguments.length)
                            null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map(function() {
                                return Array(2)
                            }),
                            this.computeIntLineIndex(0),
                            this.computeIntLineIndex(1));
                        else if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = this.getEdgeDistance(t, 0)
                              , n = this.getEdgeDistance(t, 1);
                            e > n ? (this.intLineIndex[t][0] = 0,
                            this.intLineIndex[t][1] = 1) : (this.intLineIndex[t][0] = 1,
                            this.intLineIndex[t][1] = 0)
                        }
                    },
                    isProper: function() {
                        return this.hasIntersection() && this._isProper
                    },
                    setPrecisionModel: function(t) {
                        this.precisionModel = t
                    },
                    isInteriorIntersection: function() {
                        if (0 === arguments.length)
                            return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = 0; e < this.result; e++)
                                if (!this.intPt[e].equals2D(this.inputLines[t][0]) && !this.intPt[e].equals2D(this.inputLines[t][1]))
                                    return !0;
                            return !1
                        }
                    },
                    getIntersection: function(t) {
                        return this.intPt[t]
                    },
                    isEndPoint: function() {
                        return this.hasIntersection() && !this._isProper
                    },
                    hasIntersection: function() {
                        return this.result !== oe.NO_INTERSECTION
                    },
                    getEdgeDistance: function(t, e) {
                        return oe.computeEdgeDistance(this.intPt[e], this.inputLines[t][0], this.inputLines[t][1])
                    },
                    isCollinear: function() {
                        return this.result === oe.COLLINEAR_INTERSECTION
                    },
                    toString: function() {
                        return re.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + " - " + re.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary()
                    },
                    getEndpoint: function(t, e) {
                        return this.inputLines[t][e]
                    },
                    isIntersection: function(t) {
                        for (var e = 0; e < this.result; e++)
                            if (this.intPt[e].equals2D(t))
                                return !0;
                        return !1
                    },
                    getIntersectionAlongSegment: function(t, e) {
                        return this.computeIntLineIndex(),
                        this.intPt[this.intLineIndex[t][e]]
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return oe
                    }
                }),
                oe.computeEdgeDistance = function(t, e, n) {
                    var i = Math.abs(n.x - e.x)
                      , r = Math.abs(n.y - e.y)
                      , o = -1;
                    if (t.equals(e))
                        o = 0;
                    else if (t.equals(n))
                        o = i > r ? i : r;
                    else {
                        var s = Math.abs(t.x - e.x)
                          , a = Math.abs(t.y - e.y);
                        0 !== (o = i > r ? s : a) || t.equals(e) || (o = Math.max(s, a))
                    }
                    return f.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"),
                    o
                }
                ,
                oe.nonRobustComputeEdgeDistance = function(t, e, n) {
                    var i = t.x - e.x
                      , r = t.y - e.y
                      , o = Math.sqrt(i * i + r * r);
                    return f.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"),
                    o
                }
                ,
                oe.DONT_INTERSECT = 0,
                oe.DO_INTERSECT = 1,
                oe.COLLINEAR = 2,
                oe.NO_INTERSECTION = 0,
                oe.POINT_INTERSECTION = 1,
                oe.COLLINEAR_INTERSECTION = 2,
                c(se, oe),
                e(se.prototype, {
                    isInSegmentEnvelopes: function(t) {
                        var e = new C(this.inputLines[0][0],this.inputLines[0][1])
                          , n = new C(this.inputLines[1][0],this.inputLines[1][1]);
                        return e.contains(t) && n.contains(t)
                    },
                    computeIntersection: function() {
                        if (3 !== arguments.length)
                            return oe.prototype.computeIntersection.apply(this, arguments);
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = arguments[2];
                        return this._isProper = !1,
                        C.intersects(e, n, t) && 0 === le.orientationIndex(e, n, t) && 0 === le.orientationIndex(n, e, t) ? (this._isProper = !0,
                        (t.equals(e) || t.equals(n)) && (this._isProper = !1),
                        this.result = oe.POINT_INTERSECTION,
                        null) : void (this.result = oe.NO_INTERSECTION)
                    },
                    normalizeToMinimum: function(t, e, n, i, r) {
                        r.x = this.smallestInAbsValue(t.x, e.x, n.x, i.x),
                        r.y = this.smallestInAbsValue(t.y, e.y, n.y, i.y),
                        t.x -= r.x,
                        t.y -= r.y,
                        e.x -= r.x,
                        e.y -= r.y,
                        n.x -= r.x,
                        n.y -= r.y,
                        i.x -= r.x,
                        i.y -= r.y
                    },
                    safeHCoordinateIntersection: function(t, e, n, i) {
                        var r = null;
                        try {
                            r = F.intersection(t, e, n, i)
                        } catch (o) {
                            if (!(o instanceof _))
                                throw o;
                            r = se.nearestEndpoint(t, e, n, i)
                        }
                        return r
                    },
                    intersection: function(t, e, n, i) {
                        var r = this.intersectionWithNormalization(t, e, n, i);
                        return this.isInSegmentEnvelopes(r) || (r = new d(se.nearestEndpoint(t, e, n, i))),
                        null !== this.precisionModel && this.precisionModel.makePrecise(r),
                        r
                    },
                    smallestInAbsValue: function(t, e, n, i) {
                        var r = t
                          , o = Math.abs(r);
                        return Math.abs(e) < o && (r = e,
                        o = Math.abs(e)),
                        Math.abs(n) < o && (r = n,
                        o = Math.abs(n)),
                        Math.abs(i) < o && (r = i),
                        r
                    },
                    checkDD: function(t, e, n, i, r) {
                        var o = M.intersection(t, e, n, i)
                          , s = this.isInSegmentEnvelopes(o);
                        D.out.println("DD in env = " + s + "  --------------------- " + o),
                        r.distance(o) > 1e-4 && D.out.println("Distance = " + r.distance(o))
                    },
                    intersectionWithNormalization: function(t, e, n, i) {
                        var r = new d(t)
                          , o = new d(e)
                          , s = new d(n)
                          , a = new d(i)
                          , u = new d;
                        this.normalizeToEnvCentre(r, o, s, a, u);
                        var l = this.safeHCoordinateIntersection(r, o, s, a);
                        return l.x += u.x,
                        l.y += u.y,
                        l
                    },
                    computeCollinearIntersection: function(t, e, n, i) {
                        var r = C.intersects(t, e, n)
                          , o = C.intersects(t, e, i)
                          , s = C.intersects(n, i, t)
                          , a = C.intersects(n, i, e);
                        return r && o ? (this.intPt[0] = n,
                        this.intPt[1] = i,
                        oe.COLLINEAR_INTERSECTION) : s && a ? (this.intPt[0] = t,
                        this.intPt[1] = e,
                        oe.COLLINEAR_INTERSECTION) : r && s ? (this.intPt[0] = n,
                        this.intPt[1] = t,
                        !n.equals(t) || o || a ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : r && a ? (this.intPt[0] = n,
                        this.intPt[1] = e,
                        !n.equals(e) || o || s ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : o && s ? (this.intPt[0] = i,
                        this.intPt[1] = t,
                        !i.equals(t) || r || a ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : o && a ? (this.intPt[0] = i,
                        this.intPt[1] = e,
                        !i.equals(e) || r || s ? oe.COLLINEAR_INTERSECTION : oe.POINT_INTERSECTION) : oe.NO_INTERSECTION
                    },
                    normalizeToEnvCentre: function(t, e, n, i, r) {
                        var o = t.x < e.x ? t.x : e.x
                          , s = t.y < e.y ? t.y : e.y
                          , a = t.x > e.x ? t.x : e.x
                          , u = t.y > e.y ? t.y : e.y
                          , l = n.x < i.x ? n.x : i.x
                          , c = n.y < i.y ? n.y : i.y
                          , h = n.x > i.x ? n.x : i.x
                          , f = n.y > i.y ? n.y : i.y
                          , d = o > l ? o : l
                          , g = a < h ? a : h
                          , p = s > c ? s : c
                          , m = u < f ? u : f
                          , y = (d + g) / 2
                          , v = (p + m) / 2;
                        r.x = y,
                        r.y = v,
                        t.x -= r.x,
                        t.y -= r.y,
                        e.x -= r.x,
                        e.y -= r.y,
                        n.x -= r.x,
                        n.y -= r.y,
                        i.x -= r.x,
                        i.y -= r.y
                    },
                    computeIntersect: function(t, e, n, i) {
                        if (this._isProper = !1,
                        !C.intersects(t, e, n, i))
                            return oe.NO_INTERSECTION;
                        var r = le.orientationIndex(t, e, n)
                          , o = le.orientationIndex(t, e, i);
                        if (r > 0 && o > 0 || r < 0 && o < 0)
                            return oe.NO_INTERSECTION;
                        var s = le.orientationIndex(n, i, t)
                          , a = le.orientationIndex(n, i, e);
                        return s > 0 && a > 0 || s < 0 && a < 0 ? oe.NO_INTERSECTION : 0 === r && 0 === o && 0 === s && 0 === a ? this.computeCollinearIntersection(t, e, n, i) : (0 === r || 0 === o || 0 === s || 0 === a ? (this._isProper = !1,
                        t.equals2D(n) || t.equals2D(i) ? this.intPt[0] = t : e.equals2D(n) || e.equals2D(i) ? this.intPt[0] = e : 0 === r ? this.intPt[0] = new d(n) : 0 === o ? this.intPt[0] = new d(i) : 0 === s ? this.intPt[0] = new d(t) : 0 === a && (this.intPt[0] = new d(e))) : (this._isProper = !0,
                        this.intPt[0] = this.intersection(t, e, n, i)),
                        oe.POINT_INTERSECTION)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return se
                    }
                }),
                se.nearestEndpoint = function(t, e, n, i) {
                    var r = t
                      , o = le.distancePointLine(t, n, i)
                      , s = le.distancePointLine(e, n, i);
                    return s < o && (o = s,
                    r = e),
                    s = le.distancePointLine(n, t, e),
                    s < o && (o = s,
                    r = n),
                    s = le.distancePointLine(i, t, e),
                    s < o && (o = s,
                    r = i),
                    r
                }
                ,
                e(ae.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ae
                    }
                }),
                ae.orientationIndex = function(t, e, n) {
                    var i = e.x - t.x
                      , r = e.y - t.y
                      , o = n.x - e.x
                      , s = n.y - e.y;
                    return ae.signOfDet2x2(i, r, o, s)
                }
                ,
                ae.signOfDet2x2 = function(t, e, n, i) {
                    var r = null
                      , o = null
                      , s = null
                      , a = 0;
                    if (r = 1,
                    0 === t || 0 === i)
                        return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -r : r : n > 0 ? r : -r;
                    if (0 === e || 0 === n)
                        return i > 0 ? t > 0 ? r : -r : t > 0 ? -r : r;
                    if (0 < e ? 0 < i ? e <= i || (r = -r,
                    o = t,
                    t = n,
                    n = o,
                    o = e,
                    e = i,
                    i = o) : e <= -i ? (r = -r,
                    n = -n,
                    i = -i) : (o = t,
                    t = -n,
                    n = o,
                    o = e,
                    e = -i,
                    i = o) : 0 < i ? -e <= i ? (r = -r,
                    t = -t,
                    e = -e) : (o = -t,
                    t = n,
                    n = o,
                    o = -e,
                    e = i,
                    i = o) : e >= i ? (t = -t,
                    e = -e,
                    n = -n,
                    i = -i) : (r = -r,
                    o = -t,
                    t = -n,
                    n = o,
                    o = -e,
                    e = -i,
                    i = o),
                    0 < t) {
                        if (!(0 < n))
                            return r;
                        if (!(t <= n))
                            return r
                    } else {
                        if (0 < n)
                            return -r;
                        if (!(t >= n))
                            return -r;
                        r = -r,
                        t = -t,
                        n = -n
                    }
                    for (; ; ) {
                        if (a += 1,
                        s = Math.floor(n / t),
                        n -= s * t,
                        (i -= s * e) < 0)
                            return -r;
                        if (i > e)
                            return r;
                        if (t > n + n) {
                            if (e < i + i)
                                return r
                        } else {
                            if (e > i + i)
                                return -r;
                            n = t - n,
                            i = e - i,
                            r = -r
                        }
                        if (0 === i)
                            return 0 === n ? 0 : -r;
                        if (0 === n)
                            return r;
                        if (s = Math.floor(t / n),
                        t -= s * n,
                        (e -= s * i) < 0)
                            return r;
                        if (e > i)
                            return -r;
                        if (n > t + t) {
                            if (i < e + e)
                                return -r
                        } else {
                            if (i > e + e)
                                return r;
                            t = n - t,
                            e = i - e,
                            r = -r
                        }
                        if (0 === e)
                            return 0 === t ? 0 : r;
                        if (0 === t)
                            return -r
                    }
                }
                ,
                e(ue.prototype, {
                    countSegment: function(t, e) {
                        if (t.x < this.p.x && e.x < this.p.x)
                            return null;
                        if (this.p.x === e.x && this.p.y === e.y)
                            return this.isPointOnSegment = !0,
                            null;
                        if (t.y === this.p.y && e.y === this.p.y) {
                            var n = t.x
                              , i = e.x;
                            return n > i && (n = e.x,
                            i = t.x),
                            this.p.x >= n && this.p.x <= i && (this.isPointOnSegment = !0),
                            null
                        }
                        if (t.y > this.p.y && e.y <= this.p.y || e.y > this.p.y && t.y <= this.p.y) {
                            var r = t.x - this.p.x
                              , o = t.y - this.p.y
                              , s = e.x - this.p.x
                              , a = e.y - this.p.y
                              , u = ae.signOfDet2x2(r, o, s, a);
                            if (0 === u)
                                return this.isPointOnSegment = !0,
                                null;
                            a < o && (u = -u),
                            u > 0 && this.crossingCount++
                        }
                    },
                    isPointInPolygon: function() {
                        return this.getLocation() !== S.EXTERIOR
                    },
                    getLocation: function() {
                        return this.isPointOnSegment ? S.BOUNDARY : this.crossingCount % 2 == 1 ? S.INTERIOR : S.EXTERIOR
                    },
                    isOnSegment: function() {
                        return this.isPointOnSegment
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ue
                    }
                }),
                ue.locatePointInRing = function() {
                    if (arguments[0]instanceof d && b(arguments[1], A)) {
                        for (var t = arguments[0], e = arguments[1], n = new ue(t), i = new d, r = new d, o = 1; o < e.size(); o++)
                            if (e.getCoordinate(o, i),
                            e.getCoordinate(o - 1, r),
                            n.countSegment(i, r),
                            n.isOnSegment())
                                return n.getLocation();
                        return n.getLocation()
                    }
                    if (arguments[0]instanceof d && arguments[1]instanceof Array) {
                        for (var s = arguments[0], a = arguments[1], n = new ue(s), o = 1; o < a.length; o++) {
                            var i = a[o]
                              , r = a[o - 1];
                            if (n.countSegment(i, r),
                            n.isOnSegment())
                                return n.getLocation()
                        }
                        return n.getLocation()
                    }
                }
                ,
                e(le.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return le
                    }
                }),
                le.orientationIndex = function(t, e, n) {
                    return M.orientationIndex(t, e, n)
                }
                ,
                le.signedArea = function() {
                    if (arguments[0]instanceof Array) {
                        var t = arguments[0];
                        if (t.length < 3)
                            return 0;
                        for (var e = 0, n = t[0].x, i = 1; i < t.length - 1; i++) {
                            var r = t[i].x - n
                              , o = t[i + 1].y;
                            e += r * (t[i - 1].y - o)
                        }
                        return e / 2
                    }
                    if (b(arguments[0], A)) {
                        var s = arguments[0]
                          , a = s.size();
                        if (a < 3)
                            return 0;
                        var u = new d
                          , l = new d
                          , c = new d;
                        s.getCoordinate(0, l),
                        s.getCoordinate(1, c);
                        var n = l.x;
                        c.x -= n;
                        for (var e = 0, i = 1; i < a - 1; i++)
                            u.y = l.y,
                            l.x = c.x,
                            l.y = c.y,
                            s.getCoordinate(i + 1, c),
                            c.x -= n,
                            e += l.x * (u.y - c.y);
                        return e / 2
                    }
                }
                ,
                le.distanceLineLine = function(t, e, n, i) {
                    if (t.equals(e))
                        return le.distancePointLine(t, n, i);
                    if (n.equals(i))
                        return le.distancePointLine(i, t, e);
                    var r = !1;
                    if (C.intersects(t, e, n, i)) {
                        var o = (e.x - t.x) * (i.y - n.y) - (e.y - t.y) * (i.x - n.x);
                        if (0 === o)
                            r = !0;
                        else {
                            var s = (t.y - n.y) * (i.x - n.x) - (t.x - n.x) * (i.y - n.y)
                              , a = (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)
                              , u = a / o
                              , l = s / o;
                            (l < 0 || l > 1 || u < 0 || u > 1) && (r = !0)
                        }
                    } else
                        r = !0;
                    return r ? L.min(le.distancePointLine(t, n, i), le.distancePointLine(e, n, i), le.distancePointLine(n, t, e), le.distancePointLine(i, t, e)) : 0
                }
                ,
                le.isPointInRing = function(t, e) {
                    return le.locatePointInRing(t, e) !== S.EXTERIOR
                }
                ,
                le.computeLength = function(t) {
                    var e = t.size();
                    if (e <= 1)
                        return 0;
                    var n = 0
                      , i = new d;
                    t.getCoordinate(0, i);
                    for (var r = i.x, o = i.y, s = 1; s < e; s++) {
                        t.getCoordinate(s, i);
                        var a = i.x
                          , u = i.y
                          , l = a - r
                          , c = u - o;
                        n += Math.sqrt(l * l + c * c),
                        r = a,
                        o = u
                    }
                    return n
                }
                ,
                le.isCCW = function(t) {
                    var e = t.length - 1;
                    if (e < 3)
                        throw new i("Ring has fewer than 4 points, so orientation cannot be determined");
                    for (var n = t[0], r = 0, o = 1; o <= e; o++) {
                        var s = t[o];
                        s.y > n.y && (n = s,
                        r = o)
                    }
                    var a = r;
                    do {
                        (a -= 1) < 0 && (a = e)
                    } while (t[a].equals2D(n) && a !== r);var u = r;
                    do {
                        u = (u + 1) % e
                    } while (t[u].equals2D(n) && u !== r);var l = t[a]
                      , c = t[u];
                    if (l.equals2D(n) || c.equals2D(n) || l.equals2D(c))
                        return !1;
                    var h = le.computeOrientation(l, n, c);
                    return 0 === h ? l.x > c.x : h > 0
                }
                ,
                le.locatePointInRing = function(t, e) {
                    return ue.locatePointInRing(t, e)
                }
                ,
                le.distancePointLinePerpendicular = function(t, e, n) {
                    var i = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y)
                      , r = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / i;
                    return Math.abs(r) * Math.sqrt(i)
                }
                ,
                le.computeOrientation = function(t, e, n) {
                    return le.orientationIndex(t, e, n)
                }
                ,
                le.distancePointLine = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        if (0 === e.length)
                            throw new i("Line array must contain at least one vertex");
                        for (var n = t.distance(e[0]), r = 0; r < e.length - 1; r++) {
                            var o = le.distancePointLine(t, e[r], e[r + 1]);
                            o < n && (n = o)
                        }
                        return n
                    }
                    if (3 === arguments.length) {
                        var s = arguments[0]
                          , a = arguments[1]
                          , u = arguments[2];
                        if (a.x === u.x && a.y === u.y)
                            return s.distance(a);
                        var l = (u.x - a.x) * (u.x - a.x) + (u.y - a.y) * (u.y - a.y)
                          , c = ((s.x - a.x) * (u.x - a.x) + (s.y - a.y) * (u.y - a.y)) / l;
                        if (c <= 0)
                            return s.distance(a);
                        if (c >= 1)
                            return s.distance(u);
                        var h = ((a.y - s.y) * (u.x - a.x) - (a.x - s.x) * (u.y - a.y)) / l;
                        return Math.abs(h) * Math.sqrt(l)
                    }
                }
                ,
                le.isOnLine = function(t, e) {
                    for (var n = new se, i = 1; i < e.length; i++) {
                        var r = e[i - 1]
                          , o = e[i];
                        if (n.computeIntersection(t, r, o),
                        n.hasIntersection())
                            return !0
                    }
                    return !1
                }
                ,
                le.CLOCKWISE = -1,
                le.RIGHT = le.CLOCKWISE,
                le.COUNTERCLOCKWISE = 1,
                le.LEFT = le.COUNTERCLOCKWISE,
                le.COLLINEAR = 0,
                le.STRAIGHT = le.COLLINEAR,
                e(ce.prototype, {
                    minX: function() {
                        return Math.min(this.p0.x, this.p1.x)
                    },
                    orientationIndex: function() {
                        if (arguments[0]instanceof ce) {
                            var t = arguments[0]
                              , e = le.orientationIndex(this.p0, this.p1, t.p0)
                              , n = le.orientationIndex(this.p0, this.p1, t.p1);
                            return e >= 0 && n >= 0 ? Math.max(e, n) : e <= 0 && n <= 0 ? Math.max(e, n) : 0
                        }
                        if (arguments[0]instanceof d) {
                            var i = arguments[0];
                            return le.orientationIndex(this.p0, this.p1, i)
                        }
                    },
                    toGeometry: function(t) {
                        return t.createLineString([this.p0, this.p1])
                    },
                    isVertical: function() {
                        return this.p0.x === this.p1.x
                    },
                    equals: function(t) {
                        if (!(t instanceof ce))
                            return !1;
                        var e = t;
                        return this.p0.equals(e.p0) && this.p1.equals(e.p1)
                    },
                    intersection: function(t) {
                        var e = new se;
                        return e.computeIntersection(this.p0, this.p1, t.p0, t.p1),
                        e.hasIntersection() ? e.getIntersection(0) : null
                    },
                    project: function() {
                        if (arguments[0]instanceof d) {
                            var t = arguments[0];
                            if (t.equals(this.p0) || t.equals(this.p1))
                                return new d(t);
                            var e = this.projectionFactor(t)
                              , n = new d;
                            return n.x = this.p0.x + e * (this.p1.x - this.p0.x),
                            n.y = this.p0.y + e * (this.p1.y - this.p0.y),
                            n
                        }
                        if (arguments[0]instanceof ce) {
                            var i = arguments[0]
                              , r = this.projectionFactor(i.p0)
                              , o = this.projectionFactor(i.p1);
                            if (r >= 1 && o >= 1)
                                return null;
                            if (r <= 0 && o <= 0)
                                return null;
                            var s = this.project(i.p0);
                            r < 0 && (s = this.p0),
                            r > 1 && (s = this.p1);
                            var a = this.project(i.p1);
                            return o < 0 && (a = this.p0),
                            o > 1 && (a = this.p1),
                            new ce(s,a)
                        }
                    },
                    normalize: function() {
                        this.p1.compareTo(this.p0) < 0 && this.reverse()
                    },
                    angle: function() {
                        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
                    },
                    getCoordinate: function(t) {
                        return 0 === t ? this.p0 : this.p1
                    },
                    distancePerpendicular: function(t) {
                        return le.distancePointLinePerpendicular(t, this.p0, this.p1)
                    },
                    minY: function() {
                        return Math.min(this.p0.y, this.p1.y)
                    },
                    midPoint: function() {
                        return ce.midPoint(this.p0, this.p1)
                    },
                    projectionFactor: function(t) {
                        if (t.equals(this.p0))
                            return 0;
                        if (t.equals(this.p1))
                            return 1;
                        var e = this.p1.x - this.p0.x
                          , n = this.p1.y - this.p0.y
                          , i = e * e + n * n;
                        return i <= 0 ? r.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / i
                    },
                    closestPoints: function(t) {
                        var e = this.intersection(t);
                        if (null !== e)
                            return [e, e];
                        var n = new Array(2).fill(null)
                          , i = r.MAX_VALUE
                          , o = null
                          , s = this.closestPoint(t.p0);
                        i = s.distance(t.p0),
                        n[0] = s,
                        n[1] = t.p0;
                        var a = this.closestPoint(t.p1);
                        (o = a.distance(t.p1)) < i && (i = o,
                        n[0] = a,
                        n[1] = t.p1);
                        var u = t.closestPoint(this.p0);
                        (o = u.distance(this.p0)) < i && (i = o,
                        n[0] = this.p0,
                        n[1] = u);
                        var l = t.closestPoint(this.p1);
                        return o = l.distance(this.p1),
                        o < i && (i = o,
                        n[0] = this.p1,
                        n[1] = l),
                        n
                    },
                    closestPoint: function(t) {
                        var e = this.projectionFactor(t);
                        return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1
                    },
                    maxX: function() {
                        return Math.max(this.p0.x, this.p1.x)
                    },
                    getLength: function() {
                        return this.p0.distance(this.p1)
                    },
                    compareTo: function(t) {
                        var e = t
                          , n = this.p0.compareTo(e.p0);
                        return 0 !== n ? n : this.p1.compareTo(e.p1)
                    },
                    reverse: function() {
                        var t = this.p0;
                        this.p0 = this.p1,
                        this.p1 = t
                    },
                    equalsTopo: function(t) {
                        return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0)
                    },
                    lineIntersection: function(t) {
                        try {
                            return F.intersection(this.p0, this.p1, t.p0, t.p1)
                        } catch (t) {
                            if (!(t instanceof _))
                                throw t
                        }
                        return null
                    },
                    maxY: function() {
                        return Math.max(this.p0.y, this.p1.y)
                    },
                    pointAlongOffset: function(t, e) {
                        var n = this.p0.x + t * (this.p1.x - this.p0.x)
                          , i = this.p0.y + t * (this.p1.y - this.p0.y)
                          , r = this.p1.x - this.p0.x
                          , o = this.p1.y - this.p0.y
                          , s = Math.sqrt(r * r + o * o)
                          , a = 0
                          , u = 0;
                        if (0 !== e) {
                            if (s <= 0)
                                throw new IllegalStateException("Cannot compute offset from zero-length line segment");
                            a = e * r / s,
                            u = e * o / s
                        }
                        return new d(n - u,i + a)
                    },
                    setCoordinates: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setCoordinates(t.p0, t.p1)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            this.p0.x = e.x,
                            this.p0.y = e.y,
                            this.p1.x = n.x,
                            this.p1.y = n.y
                        }
                    },
                    segmentFraction: function(t) {
                        var e = this.projectionFactor(t);
                        return e < 0 ? e = 0 : (e > 1 || r.isNaN(e)) && (e = 1),
                        e
                    },
                    toString: function() {
                        return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
                    },
                    isHorizontal: function() {
                        return this.p0.y === this.p1.y
                    },
                    distance: function() {
                        if (arguments[0]instanceof ce) {
                            var t = arguments[0];
                            return le.distanceLineLine(this.p0, this.p1, t.p0, t.p1)
                        }
                        if (arguments[0]instanceof d) {
                            var e = arguments[0];
                            return le.distancePointLine(e, this.p0, this.p1)
                        }
                    },
                    pointAlong: function(t) {
                        var e = new d;
                        return e.x = this.p0.x + t * (this.p1.x - this.p0.x),
                        e.y = this.p0.y + t * (this.p1.y - this.p0.y),
                        e
                    },
                    hashCode: function() {
                        var t = java.lang.Double.doubleToLongBits(this.p0.x);
                        t ^= 31 * java.lang.Double.doubleToLongBits(this.p0.y);
                        var e = Math.trunc(t) ^ Math.trunc(t >> 32)
                          , n = java.lang.Double.doubleToLongBits(this.p1.x);
                        return n ^= 31 * java.lang.Double.doubleToLongBits(this.p1.y),
                        e ^ Math.trunc(n) ^ Math.trunc(n >> 32)
                    },
                    interfaces_: function() {
                        return [o, u]
                    },
                    getClass: function() {
                        return ce
                    }
                }),
                ce.midPoint = function(t, e) {
                    return new d((t.x + e.x) / 2,(t.y + e.y) / 2)
                }
                ,
                ce.serialVersionUID = 0x2d2172135f411c00,
                e(he.prototype, {
                    isIntersects: function() {
                        return !this.isDisjoint()
                    },
                    isCovers: function() {
                        return (he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) || he.isTrue(this.matrix[S.INTERIOR][S.BOUNDARY]) || he.isTrue(this.matrix[S.BOUNDARY][S.INTERIOR]) || he.isTrue(this.matrix[S.BOUNDARY][S.BOUNDARY])) && this.matrix[S.EXTERIOR][S.INTERIOR] === lt.FALSE && this.matrix[S.EXTERIOR][S.BOUNDARY] === lt.FALSE
                    },
                    isCoveredBy: function() {
                        return (he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) || he.isTrue(this.matrix[S.INTERIOR][S.BOUNDARY]) || he.isTrue(this.matrix[S.BOUNDARY][S.INTERIOR]) || he.isTrue(this.matrix[S.BOUNDARY][S.BOUNDARY])) && this.matrix[S.INTERIOR][S.EXTERIOR] === lt.FALSE && this.matrix[S.BOUNDARY][S.EXTERIOR] === lt.FALSE
                    },
                    set: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = 0; e < t.length; e++) {
                                var n = Math.trunc(e / 3)
                                  , i = e % 3;
                                this.matrix[n][i] = lt.toDimensionValue(t.charAt(e))
                            }
                        else if (3 === arguments.length) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = arguments[2];
                            this.matrix[r][o] = s
                        }
                    },
                    isContains: function() {
                        return he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && this.matrix[S.EXTERIOR][S.INTERIOR] === lt.FALSE && this.matrix[S.EXTERIOR][S.BOUNDARY] === lt.FALSE
                    },
                    setAtLeast: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = 0; e < t.length; e++) {
                                var n = Math.trunc(e / 3)
                                  , i = e % 3;
                                this.setAtLeast(n, i, lt.toDimensionValue(t.charAt(e)))
                            }
                        else if (3 === arguments.length) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = arguments[2];
                            this.matrix[r][o] < s && (this.matrix[r][o] = s)
                        }
                    },
                    setAtLeastIfValid: function(t, e, n) {
                        t >= 0 && e >= 0 && this.setAtLeast(t, e, n)
                    },
                    isWithin: function() {
                        return he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && this.matrix[S.INTERIOR][S.EXTERIOR] === lt.FALSE && this.matrix[S.BOUNDARY][S.EXTERIOR] === lt.FALSE
                    },
                    isTouches: function(t, e) {
                        return t > e ? this.isTouches(e, t) : (t === lt.A && e === lt.A || t === lt.L && e === lt.L || t === lt.L && e === lt.A || t === lt.P && e === lt.A || t === lt.P && e === lt.L) && this.matrix[S.INTERIOR][S.INTERIOR] === lt.FALSE && (he.isTrue(this.matrix[S.INTERIOR][S.BOUNDARY]) || he.isTrue(this.matrix[S.BOUNDARY][S.INTERIOR]) || he.isTrue(this.matrix[S.BOUNDARY][S.BOUNDARY]))
                    },
                    isOverlaps: function(t, e) {
                        return t === lt.P && e === lt.P || t === lt.A && e === lt.A ? he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && he.isTrue(this.matrix[S.INTERIOR][S.EXTERIOR]) && he.isTrue(this.matrix[S.EXTERIOR][S.INTERIOR]) : t === lt.L && e === lt.L && 1 === this.matrix[S.INTERIOR][S.INTERIOR] && he.isTrue(this.matrix[S.INTERIOR][S.EXTERIOR]) && he.isTrue(this.matrix[S.EXTERIOR][S.INTERIOR])
                    },
                    isEquals: function(t, e) {
                        return t === e && he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && this.matrix[S.INTERIOR][S.EXTERIOR] === lt.FALSE && this.matrix[S.BOUNDARY][S.EXTERIOR] === lt.FALSE && this.matrix[S.EXTERIOR][S.INTERIOR] === lt.FALSE && this.matrix[S.EXTERIOR][S.BOUNDARY] === lt.FALSE
                    },
                    toString: function() {
                        for (var t = new T("123456789"), e = 0; e < 3; e++)
                            for (var n = 0; n < 3; n++)
                                t.setCharAt(3 * e + n, lt.toDimensionSymbol(this.matrix[e][n]));
                        return t.toString()
                    },
                    setAll: function(t) {
                        for (var e = 0; e < 3; e++)
                            for (var n = 0; n < 3; n++)
                                this.matrix[e][n] = t
                    },
                    get: function(t, e) {
                        return this.matrix[t][e]
                    },
                    transpose: function() {
                        var t = this.matrix[1][0];
                        return this.matrix[1][0] = this.matrix[0][1],
                        this.matrix[0][1] = t,
                        t = this.matrix[2][0],
                        this.matrix[2][0] = this.matrix[0][2],
                        this.matrix[0][2] = t,
                        t = this.matrix[2][1],
                        this.matrix[2][1] = this.matrix[1][2],
                        this.matrix[1][2] = t,
                        this
                    },
                    matches: function(t) {
                        if (9 !== t.length)
                            throw new i("Should be length 9: " + t);
                        for (var e = 0; e < 3; e++)
                            for (var n = 0; n < 3; n++)
                                if (!he.matches(this.matrix[e][n], t.charAt(3 * e + n)))
                                    return !1;
                        return !0
                    },
                    add: function(t) {
                        for (var e = 0; e < 3; e++)
                            for (var n = 0; n < 3; n++)
                                this.setAtLeast(e, n, t.get(e, n))
                    },
                    isDisjoint: function() {
                        return this.matrix[S.INTERIOR][S.INTERIOR] === lt.FALSE && this.matrix[S.INTERIOR][S.BOUNDARY] === lt.FALSE && this.matrix[S.BOUNDARY][S.INTERIOR] === lt.FALSE && this.matrix[S.BOUNDARY][S.BOUNDARY] === lt.FALSE
                    },
                    isCrosses: function(t, e) {
                        return t === lt.P && e === lt.L || t === lt.P && e === lt.A || t === lt.L && e === lt.A ? he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && he.isTrue(this.matrix[S.INTERIOR][S.EXTERIOR]) : t === lt.L && e === lt.P || t === lt.A && e === lt.P || t === lt.A && e === lt.L ? he.isTrue(this.matrix[S.INTERIOR][S.INTERIOR]) && he.isTrue(this.matrix[S.EXTERIOR][S.INTERIOR]) : t === lt.L && e === lt.L && 0 === this.matrix[S.INTERIOR][S.INTERIOR]
                    },
                    interfaces_: function() {
                        return [s]
                    },
                    getClass: function() {
                        return he
                    }
                }),
                he.matches = function() {
                    if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) {
                        var t = arguments[0]
                          , e = arguments[1];
                        return e === lt.SYM_DONTCARE || e === lt.SYM_TRUE && (t >= 0 || t === lt.TRUE) || e === lt.SYM_FALSE && t === lt.FALSE || e === lt.SYM_P && t === lt.P || e === lt.SYM_L && t === lt.L || e === lt.SYM_A && t === lt.A
                    }
                    if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) {
                        var n = arguments[0]
                          , i = arguments[1];
                        return new he(n).matches(i)
                    }
                }
                ,
                he.isTrue = function(t) {
                    return t >= 0 || t === lt.TRUE
                }
                ;
                var us = Object.freeze({
                    Coordinate: d,
                    CoordinateList: N,
                    Envelope: C,
                    LineSegment: ce,
                    GeometryFactory: ne,
                    Geometry: q,
                    Point: St,
                    LineString: wt,
                    LinearRing: Rt,
                    Polygon: Lt,
                    GeometryCollection: ft,
                    MultiPoint: Tt,
                    MultiLineString: dt,
                    MultiPolygon: Ot,
                    Dimension: lt,
                    IntersectionMatrix: he,
                    PrecisionModel: te
                });
                e(fe.prototype, {
                    addPoint: function(t) {
                        this.ptCount += 1,
                        this.ptCentSum.x += t.x,
                        this.ptCentSum.y += t.y
                    },
                    setBasePoint: function(t) {
                        null === this.areaBasePt && (this.areaBasePt = t)
                    },
                    addLineSegments: function(t) {
                        for (var e = 0, n = 0; n < t.length - 1; n++) {
                            var i = t[n].distance(t[n + 1]);
                            if (0 !== i) {
                                e += i;
                                var r = (t[n].x + t[n + 1].x) / 2;
                                this.lineCentSum.x += i * r;
                                var o = (t[n].y + t[n + 1].y) / 2;
                                this.lineCentSum.y += i * o
                            }
                        }
                        this.totalLength += e,
                        0 === e && t.length > 0 && this.addPoint(t[0])
                    },
                    addHole: function(t) {
                        for (var e = le.isCCW(t), n = 0; n < t.length - 1; n++)
                            this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);
                        this.addLineSegments(t)
                    },
                    getCentroid: function() {
                        var t = new d;
                        if (Math.abs(this.areasum2) > 0)
                            t.x = this.cg3.x / 3 / this.areasum2,
                            t.y = this.cg3.y / 3 / this.areasum2;
                        else if (this.totalLength > 0)
                            t.x = this.lineCentSum.x / this.totalLength,
                            t.y = this.lineCentSum.y / this.totalLength;
                        else {
                            if (!(this.ptCount > 0))
                                return null;
                            t.x = this.ptCentSum.x / this.ptCount,
                            t.y = this.ptCentSum.y / this.ptCount
                        }
                        return t
                    },
                    addShell: function(t) {
                        t.length > 0 && this.setBasePoint(t[0]);
                        for (var e = !le.isCCW(t), n = 0; n < t.length - 1; n++)
                            this.addTriangle(this.areaBasePt, t[n], t[n + 1], e);
                        this.addLineSegments(t)
                    },
                    addTriangle: function(t, e, n, i) {
                        var r = i ? 1 : -1;
                        fe.centroid3(t, e, n, this.triangleCent3);
                        var o = fe.area2(t, e, n);
                        this.cg3.x += r * o * this.triangleCent3.x,
                        this.cg3.y += r * o * this.triangleCent3.y,
                        this.areasum2 += r * o
                    },
                    add: function() {
                        if (arguments[0]instanceof Lt) {
                            var t = arguments[0];
                            this.addShell(t.getExteriorRing().getCoordinates());
                            for (var e = 0; e < t.getNumInteriorRing(); e++)
                                this.addHole(t.getInteriorRingN(e).getCoordinates())
                        } else if (arguments[0]instanceof q) {
                            var n = arguments[0];
                            if (n.isEmpty())
                                return null;
                            if (n instanceof St)
                                this.addPoint(n.getCoordinate());
                            else if (n instanceof wt)
                                this.addLineSegments(n.getCoordinates());
                            else if (n instanceof Lt) {
                                var i = n;
                                this.add(i)
                            } else if (n instanceof ft)
                                for (var r = n, e = 0; e < r.getNumGeometries(); e++)
                                    this.add(r.getGeometryN(e))
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return fe
                    }
                }),
                fe.area2 = function(t, e, n) {
                    return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y)
                }
                ,
                fe.centroid3 = function(t, e, n, i) {
                    return i.x = t.x + e.x + n.x,
                    i.y = t.y + e.y + n.y,
                    null
                }
                ,
                fe.getCentroid = function(t) {
                    return new fe(t).getCentroid()
                }
                ,
                de.prototype = new Error,
                de.prototype.name = "EmptyStackException",
                ge.prototype = new v,
                ge.prototype.add = function(t) {
                    return this.array_.push(t),
                    !0
                }
                ,
                ge.prototype.get = function(t) {
                    if (t < 0 || t >= this.size())
                        throw new IndexOutOfBoundsException;
                    return this.array_[t]
                }
                ,
                ge.prototype.push = function(t) {
                    return this.array_.push(t),
                    t
                }
                ,
                ge.prototype.pop = function(t) {
                    if (0 === this.array_.length)
                        throw new de;
                    return this.array_.pop()
                }
                ,
                ge.prototype.peek = function() {
                    if (0 === this.array_.length)
                        throw new de;
                    return this.array_[this.array_.length - 1]
                }
                ,
                ge.prototype.empty = function() {
                    return 0 === this.array_.length
                }
                ,
                ge.prototype.isEmpty = function() {
                    return this.empty()
                }
                ,
                ge.prototype.search = function(t) {
                    return this.array_.indexOf(t)
                }
                ,
                ge.prototype.size = function() {
                    return this.array_.length
                }
                ,
                ge.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                        t.push(this.array_[e]);
                    return t
                }
                ,
                e(pe.prototype, {
                    filter: function(t) {
                        this.treeSet.contains(t) || (this.list.add(t),
                        this.treeSet.add(t))
                    },
                    getCoordinates: function() {
                        var t = new Array(this.list.size()).fill(null);
                        return this.list.toArray(t)
                    },
                    interfaces_: function() {
                        return [B]
                    },
                    getClass: function() {
                        return pe
                    }
                }),
                pe.filterCoordinates = function(t) {
                    for (var e = new pe, n = 0; n < t.length; n++)
                        e.filter(t[n]);
                    return e.getCoordinates()
                }
                ,
                e(me.prototype, {
                    preSort: function(t) {
                        for (var e = null, n = 1; n < t.length; n++)
                            (t[n].y < t[0].y || t[n].y === t[0].y && t[n].x < t[0].x) && (e = t[0],
                            t[0] = t[n],
                            t[n] = e);
                        return ut.sort(t, 1, t.length, new ye(t[0])),
                        t
                    },
                    computeOctRing: function(t) {
                        var e = this.computeOctPts(t)
                          , n = new N;
                        return n.add(e, !1),
                        n.size() < 3 ? null : (n.closeRing(),
                        n.toCoordinateArray())
                    },
                    lineOrPolygon: function(t) {
                        if (t = this.cleanRing(t),
                        3 === t.length)
                            return this.geomFactory.createLineString([t[0], t[1]]);
                        var e = this.geomFactory.createLinearRing(t);
                        return this.geomFactory.createPolygon(e, null)
                    },
                    cleanRing: function(t) {
                        f.equals(t[0], t[t.length - 1]);
                        for (var e = new I, n = null, i = 0; i <= t.length - 2; i++) {
                            var r = t[i]
                              , o = t[i + 1];
                            r.equals(o) || null !== n && this.isBetween(n, r, o) || (e.add(r),
                            n = r)
                        }
                        e.add(t[t.length - 1]);
                        var s = new Array(e.size()).fill(null);
                        return e.toArray(s)
                    },
                    isBetween: function(t, e, n) {
                        if (0 !== le.computeOrientation(t, e, n))
                            return !1;
                        if (t.x !== n.x) {
                            if (t.x <= e.x && e.x <= n.x)
                                return !0;
                            if (n.x <= e.x && e.x <= t.x)
                                return !0
                        }
                        if (t.y !== n.y) {
                            if (t.y <= e.y && e.y <= n.y)
                                return !0;
                            if (n.y <= e.y && e.y <= t.y)
                                return !0
                        }
                        return !1
                    },
                    reduce: function(t) {
                        var e = this.computeOctRing(t);
                        if (null === e)
                            return t;
                        for (var n = new at, i = 0; i < e.length; i++)
                            n.add(e[i]);
                        for (var i = 0; i < t.length; i++)
                            le.isPointInRing(t[i], e) || n.add(t[i]);
                        var r = X.toCoordinateArray(n);
                        return r.length < 3 ? this.padArray3(r) : r
                    },
                    getConvexHull: function() {
                        if (0 === this.inputPts.length)
                            return this.geomFactory.createGeometryCollection(null);
                        if (1 === this.inputPts.length)
                            return this.geomFactory.createPoint(this.inputPts[0]);
                        if (2 === this.inputPts.length)
                            return this.geomFactory.createLineString(this.inputPts);
                        var t = this.inputPts;
                        this.inputPts.length > 50 && (t = this.reduce(this.inputPts));
                        var e = this.preSort(t)
                          , n = this.grahamScan(e)
                          , i = this.toCoordinateArray(n);
                        return this.lineOrPolygon(i)
                    },
                    padArray3: function(t) {
                        for (var e = new Array(3).fill(null), n = 0; n < e.length; n++)
                            n < t.length ? e[n] = t[n] : e[n] = t[0];
                        return e
                    },
                    computeOctPts: function(t) {
                        for (var e = new Array(8).fill(null), n = 0; n < e.length; n++)
                            e[n] = t[0];
                        for (var i = 1; i < t.length; i++)
                            t[i].x < e[0].x && (e[0] = t[i]),
                            t[i].x - t[i].y < e[1].x - e[1].y && (e[1] = t[i]),
                            t[i].y > e[2].y && (e[2] = t[i]),
                            t[i].x + t[i].y > e[3].x + e[3].y && (e[3] = t[i]),
                            t[i].x > e[4].x && (e[4] = t[i]),
                            t[i].x - t[i].y > e[5].x - e[5].y && (e[5] = t[i]),
                            t[i].y < e[6].y && (e[6] = t[i]),
                            t[i].x + t[i].y < e[7].x + e[7].y && (e[7] = t[i]);
                        return e
                    },
                    toCoordinateArray: function(t) {
                        for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {
                            var i = t.get(n);
                            e[n] = i
                        }
                        return e
                    },
                    grahamScan: function(t) {
                        var e = null
                          , n = new ge;
                        e = n.push(t[0]),
                        e = n.push(t[1]),
                        e = n.push(t[2]);
                        for (var i = 3; i < t.length; i++) {
                            for (e = n.pop(); !n.empty() && le.computeOrientation(n.peek(), e, t[i]) > 0; )
                                e = n.pop();
                            e = n.push(e),
                            e = n.push(t[i])
                        }
                        return e = n.push(t[0]),
                        n
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return me
                    }
                }),
                me.extractCoordinates = function(t) {
                    var e = new pe;
                    return t.apply(e),
                    e.getCoordinates()
                }
                ,
                e(ye.prototype, {
                    compare: function(t, e) {
                        var n = t
                          , i = e;
                        return ye.polarCompare(this.origin, n, i)
                    },
                    interfaces_: function() {
                        return [a]
                    },
                    getClass: function() {
                        return ye
                    }
                }),
                ye.polarCompare = function(t, e, n) {
                    var i = e.x - t.x
                      , r = e.y - t.y
                      , o = n.x - t.x
                      , s = n.y - t.y
                      , a = le.computeOrientation(t, e, n);
                    if (a === le.COUNTERCLOCKWISE)
                        return 1;
                    if (a === le.CLOCKWISE)
                        return -1;
                    var u = i * i + r * r
                      , l = o * o + s * s;
                    return u < l ? -1 : u > l ? 1 : 0
                }
                ,
                me.RadialComparator = ye,
                e(ve.prototype, {
                    transformPoint: function(t, e) {
                        return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
                    },
                    transformPolygon: function(t, e) {
                        var n = !0
                          , i = this.transformLinearRing(t.getExteriorRing(), t);
                        null !== i && i instanceof Rt && !i.isEmpty() || (n = !1);
                        for (var r = new I, o = 0; o < t.getNumInteriorRing(); o++) {
                            var s = this.transformLinearRing(t.getInteriorRingN(o), t);
                            null === s || s.isEmpty() || (s instanceof Rt || (n = !1),
                            r.add(s))
                        }
                        if (n)
                            return this.factory.createPolygon(i, r.toArray([]));
                        var a = new I;
                        return null !== i && a.add(i),
                        a.addAll(r),
                        this.factory.buildGeometry(a)
                    },
                    createCoordinateSequence: function(t) {
                        return this.factory.getCoordinateSequenceFactory().create(t)
                    },
                    getInputGeometry: function() {
                        return this.inputGeom
                    },
                    transformMultiLineString: function(t, e) {
                        for (var n = new I, i = 0; i < t.getNumGeometries(); i++) {
                            var r = this.transformLineString(t.getGeometryN(i), t);
                            null !== r && (r.isEmpty() || n.add(r))
                        }
                        return this.factory.buildGeometry(n)
                    },
                    transformCoordinates: function(t, e) {
                        return this.copy(t)
                    },
                    transformLineString: function(t, e) {
                        return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
                    },
                    transformMultiPoint: function(t, e) {
                        for (var n = new I, i = 0; i < t.getNumGeometries(); i++) {
                            var r = this.transformPoint(t.getGeometryN(i), t);
                            null !== r && (r.isEmpty() || n.add(r))
                        }
                        return this.factory.buildGeometry(n)
                    },
                    transformMultiPolygon: function(t, e) {
                        for (var n = new I, i = 0; i < t.getNumGeometries(); i++) {
                            var r = this.transformPolygon(t.getGeometryN(i), t);
                            null !== r && (r.isEmpty() || n.add(r))
                        }
                        return this.factory.buildGeometry(n)
                    },
                    copy: function(t) {
                        return t.copy()
                    },
                    transformGeometryCollection: function(t, e) {
                        for (var n = new I, i = 0; i < t.getNumGeometries(); i++) {
                            var r = this.transform(t.getGeometryN(i));
                            null !== r && (this.pruneEmptyGeometry && r.isEmpty() || n.add(r))
                        }
                        return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(ne.toGeometryArray(n)) : this.factory.buildGeometry(n)
                    },
                    transform: function(t) {
                        if (this.inputGeom = t,
                        this.factory = t.getFactory(),
                        t instanceof St)
                            return this.transformPoint(t, null);
                        if (t instanceof Tt)
                            return this.transformMultiPoint(t, null);
                        if (t instanceof Rt)
                            return this.transformLinearRing(t, null);
                        if (t instanceof wt)
                            return this.transformLineString(t, null);
                        if (t instanceof dt)
                            return this.transformMultiLineString(t, null);
                        if (t instanceof Lt)
                            return this.transformPolygon(t, null);
                        if (t instanceof Ot)
                            return this.transformMultiPolygon(t, null);
                        if (t instanceof ft)
                            return this.transformGeometryCollection(t, null);
                        throw new i("Unknown Geometry subtype: " + t.getClass().getName())
                    },
                    transformLinearRing: function(t, e) {
                        var n = this.transformCoordinates(t.getCoordinateSequence(), t);
                        if (null === n)
                            return this.factory.createLinearRing(null);
                        var i = n.size();
                        return i > 0 && i < 4 && !this.preserveType ? this.factory.createLineString(n) : this.factory.createLinearRing(n)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ve
                    }
                }),
                e(Ee.prototype, {
                    snapVertices: function(t, e) {
                        for (var n = this._isClosed ? t.size() - 1 : t.size(), i = 0; i < n; i++) {
                            var r = t.get(i)
                              , o = this.findSnapForVertex(r, e);
                            null !== o && (t.set(i, new d(o)),
                            0 === i && this._isClosed && t.set(t.size() - 1, new d(o)))
                        }
                    },
                    findSnapForVertex: function(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            if (t.equals2D(e[n]))
                                return null;
                            if (t.distance(e[n]) < this.snapTolerance)
                                return e[n]
                        }
                        return null
                    },
                    snapTo: function(t) {
                        var e = new N(this.srcPts);
                        return this.snapVertices(e, t),
                        this.snapSegments(e, t),
                        e.toCoordinateArray()
                    },
                    snapSegments: function(t, e) {
                        if (0 === e.length)
                            return null;
                        var n = e.length;
                        e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);
                        for (var i = 0; i < n; i++) {
                            var r = e[i]
                              , o = this.findSegmentIndexToSnap(r, t);
                            o >= 0 && t.add(o + 1, new d(r), !1)
                        }
                    },
                    findSegmentIndexToSnap: function(t, e) {
                        for (var n = r.MAX_VALUE, i = -1, o = 0; o < e.size() - 1; o++) {
                            if (this.seg.p0 = e.get(o),
                            this.seg.p1 = e.get(o + 1),
                            this.seg.p0.equals2D(t) || this.seg.p1.equals2D(t)) {
                                if (this.allowSnappingToSourceVertices)
                                    continue;
                                return -1
                            }
                            var s = this.seg.distance(t);
                            s < this.snapTolerance && s < n && (n = s,
                            i = o)
                        }
                        return i
                    },
                    setAllowSnappingToSourceVertices: function(t) {
                        this.allowSnappingToSourceVertices = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ee
                    }
                }),
                Ee.isClosed = function(t) {
                    return !(t.length <= 1) && t[0].equals2D(t[t.length - 1])
                }
                ,
                e(xe.prototype, {
                    snapTo: function(t, e) {
                        return new Ie(e,this.extractTargetCoordinates(t)).transform(this.srcGeom)
                    },
                    snapToSelf: function(t, e) {
                        var n = this.extractTargetCoordinates(this.srcGeom)
                          , i = new Ie(t,n,!0)
                          , r = i.transform(this.srcGeom)
                          , o = r;
                        return e && b(o, bt) && (o = r.buffer(0)),
                        o
                    },
                    computeSnapTolerance: function(t) {
                        return this.computeMinimumSegmentLength(t) / 10
                    },
                    extractTargetCoordinates: function(t) {
                        for (var e = new at, n = t.getCoordinates(), i = 0; i < n.length; i++)
                            e.add(n[i]);
                        return e.toArray(new Array(0).fill(null))
                    },
                    computeMinimumSegmentLength: function(t) {
                        for (var e = r.MAX_VALUE, n = 0; n < t.length - 1; n++) {
                            var i = t[n].distance(t[n + 1]);
                            i < e && (e = i)
                        }
                        return e
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return xe
                    }
                }),
                xe.snap = function(t, e, n) {
                    var i = new Array(2).fill(null)
                      , r = new xe(t);
                    i[0] = r.snapTo(e, n);
                    var o = new xe(e);
                    return i[1] = o.snapTo(i[0], n),
                    i
                }
                ,
                xe.computeOverlaySnapTolerance = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0]
                          , e = xe.computeSizeBasedSnapTolerance(t)
                          , n = t.getPrecisionModel();
                        if (n.getType() === te.FIXED) {
                            var i = 1 / n.getScale() * 2 / 1.415;
                            i > e && (e = i)
                        }
                        return e
                    }
                    if (2 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1];
                        return Math.min(xe.computeOverlaySnapTolerance(r), xe.computeOverlaySnapTolerance(o))
                    }
                }
                ,
                xe.computeSizeBasedSnapTolerance = function(t) {
                    var e = t.getEnvelopeInternal();
                    return Math.min(e.getHeight(), e.getWidth()) * xe.SNAP_PRECISION_FACTOR
                }
                ,
                xe.snapToSelf = function(t, e, n) {
                    return new xe(t).snapToSelf(e, n)
                }
                ,
                xe.SNAP_PRECISION_FACTOR = 1e-9,
                c(Ie, ve),
                e(Ie.prototype, {
                    snapLine: function(t, e) {
                        var n = new Ee(t,this.snapTolerance);
                        return n.setAllowSnappingToSourceVertices(this.isSelfSnap),
                        n.snapTo(e)
                    },
                    transformCoordinates: function(t, e) {
                        var n = t.toCoordinateArray()
                          , i = this.snapLine(n, this.snapPts);
                        return this.factory.getCoordinateSequenceFactory().create(i)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ie
                    }
                }),
                e(Ne.prototype, {
                    getCommon: function() {
                        return r.longBitsToDouble(this.commonBits)
                    },
                    add: function(t) {
                        var e = r.doubleToLongBits(t);
                        return this.isFirst ? (this.commonBits = e,
                        this.commonSignExp = Ne.signExpBits(this.commonBits),
                        this.isFirst = !1,
                        null) : Ne.signExpBits(e) !== this.commonSignExp ? (this.commonBits = 0,
                        null) : (this.commonMantissaBitsCount = Ne.numCommonMostSigMantissaBits(this.commonBits, e),
                        void (this.commonBits = Ne.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount))))
                    },
                    toString: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = r.longBitsToDouble(t)
                              , n = Long.toBinaryString(t)
                              , i = "0000000000000000000000000000000000000000000000000000000000000000" + n
                              , o = i.substring(i.length - 64);
                            return o.substring(0, 1) + "  " + o.substring(1, 12) + "(exp) " + o.substring(12) + " [ " + e + " ]"
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ne
                    }
                }),
                Ne.getBit = function(t, e) {
                    return 0 != (t & 1 << e) ? 1 : 0
                }
                ,
                Ne.signExpBits = function(t) {
                    return t >> 52
                }
                ,
                Ne.zeroLowerBits = function(t, e) {
                    return t & ~((1 << e) - 1)
                }
                ,
                Ne.numCommonMostSigMantissaBits = function(t, e) {
                    for (var n = 0, i = 52; i >= 0; i--) {
                        if (Ne.getBit(t, i) !== Ne.getBit(e, i))
                            return n;
                        n++
                    }
                    return 52
                }
                ,
                e(Ce.prototype, {
                    addCommonBits: function(t) {
                        var e = new _e(this.commonCoord);
                        t.apply(e),
                        t.geometryChanged()
                    },
                    removeCommonBits: function(t) {
                        if (0 === this.commonCoord.x && 0 === this.commonCoord.y)
                            return t;
                        var e = new d(this.commonCoord);
                        e.x = -e.x,
                        e.y = -e.y;
                        var n = new _e(e);
                        return t.apply(n),
                        t.geometryChanged(),
                        t
                    },
                    getCommonCoordinate: function() {
                        return this.commonCoord
                    },
                    add: function(t) {
                        t.apply(this.ccFilter),
                        this.commonCoord = this.ccFilter.getCommonCoordinate()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ce
                    }
                }),
                e(we.prototype, {
                    filter: function(t) {
                        this.commonBitsX.add(t.x),
                        this.commonBitsY.add(t.y)
                    },
                    getCommonCoordinate: function() {
                        return new d(this.commonBitsX.getCommon(),this.commonBitsY.getCommon())
                    },
                    interfaces_: function() {
                        return [B]
                    },
                    getClass: function() {
                        return we
                    }
                }),
                e(_e.prototype, {
                    filter: function(t, e) {
                        var n = t.getOrdinate(e, 0) + this.trans.x
                          , i = t.getOrdinate(e, 1) + this.trans.y;
                        t.setOrdinate(e, 0, n),
                        t.setOrdinate(e, 1, i)
                    },
                    isDone: function() {
                        return !1
                    },
                    isGeometryChanged: function() {
                        return !0
                    },
                    interfaces_: function() {
                        return [ht]
                    },
                    getClass: function() {
                        return _e
                    }
                }),
                Ce.CommonCoordinateFilter = we,
                Ce.Translater = _e,
                e(Se.prototype, {
                    next: function() {
                        if (this.atStart)
                            return this.atStart = !1,
                            Se.isAtomic(this.parent) && this.index++,
                            this.parent;
                        if (null !== this.subcollectionIterator) {
                            if (this.subcollectionIterator.hasNext())
                                return this.subcollectionIterator.next();
                            this.subcollectionIterator = null
                        }
                        if (this.index >= this.max)
                            throw new E;
                        var t = this.parent.getGeometryN(this.index++);
                        return t instanceof ft ? (this.subcollectionIterator = new Se(t),
                        this.subcollectionIterator.next()) : t
                    },
                    remove: function() {
                        throw new UnsupportedOperationException(this.getClass().getName())
                    },
                    hasNext: function() {
                        if (this.atStart)
                            return !0;
                        if (null !== this.subcollectionIterator) {
                            if (this.subcollectionIterator.hasNext())
                                return !0;
                            this.subcollectionIterator = null
                        }
                        return !(this.index >= this.max)
                    },
                    interfaces_: function() {
                        return [p]
                    },
                    getClass: function() {
                        return Se
                    }
                }),
                Se.isAtomic = function(t) {
                    return !(t instanceof ft)
                }
                ,
                e(be.prototype, {
                    locateInternal: function() {
                        if (arguments[0]instanceof d && arguments[1]instanceof Lt) {
                            var t = arguments[0]
                              , e = arguments[1];
                            if (e.isEmpty())
                                return S.EXTERIOR;
                            var n = e.getExteriorRing()
                              , i = this.locateInPolygonRing(t, n);
                            if (i === S.EXTERIOR)
                                return S.EXTERIOR;
                            if (i === S.BOUNDARY)
                                return S.BOUNDARY;
                            for (var r = 0; r < e.getNumInteriorRing(); r++) {
                                var o = e.getInteriorRingN(r)
                                  , s = this.locateInPolygonRing(t, o);
                                if (s === S.INTERIOR)
                                    return S.EXTERIOR;
                                if (s === S.BOUNDARY)
                                    return S.BOUNDARY
                            }
                            return S.INTERIOR
                        }
                        if (arguments[0]instanceof d && arguments[1]instanceof wt) {
                            var a = arguments[0]
                              , u = arguments[1];
                            if (!u.getEnvelopeInternal().intersects(a))
                                return S.EXTERIOR;
                            var l = u.getCoordinates();
                            return u.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? le.isOnLine(a, l) ? S.INTERIOR : S.EXTERIOR : S.BOUNDARY
                        }
                        if (arguments[0]instanceof d && arguments[1]instanceof St) {
                            var c = arguments[0];
                            return arguments[1].getCoordinate().equals2D(c) ? S.INTERIOR : S.EXTERIOR
                        }
                    },
                    locateInPolygonRing: function(t, e) {
                        return e.getEnvelopeInternal().intersects(t) ? le.locatePointInRing(t, e.getCoordinates()) : S.EXTERIOR
                    },
                    intersects: function(t, e) {
                        return this.locate(t, e) !== S.EXTERIOR
                    },
                    updateLocationInfo: function(t) {
                        t === S.INTERIOR && (this.isIn = !0),
                        t === S.BOUNDARY && this.numBoundaries++
                    },
                    computeLocation: function(t, e) {
                        if (e instanceof St && this.updateLocationInfo(this.locateInternal(t, e)),
                        e instanceof wt)
                            this.updateLocationInfo(this.locateInternal(t, e));
                        else if (e instanceof Lt)
                            this.updateLocationInfo(this.locateInternal(t, e));
                        else if (e instanceof dt)
                            for (var n = e, i = 0; i < n.getNumGeometries(); i++) {
                                var r = n.getGeometryN(i);
                                this.updateLocationInfo(this.locateInternal(t, r))
                            }
                        else if (e instanceof Ot)
                            for (var o = e, i = 0; i < o.getNumGeometries(); i++) {
                                var s = o.getGeometryN(i);
                                this.updateLocationInfo(this.locateInternal(t, s))
                            }
                        else if (e instanceof ft)
                            for (var a = new Se(e); a.hasNext(); ) {
                                var u = a.next();
                                u !== e && this.computeLocation(t, u)
                            }
                    },
                    locate: function(t, e) {
                        return e.isEmpty() ? S.EXTERIOR : e instanceof wt ? this.locateInternal(t, e) : e instanceof Lt ? this.locateInternal(t, e) : (this.isIn = !1,
                        this.numBoundaries = 0,
                        this.computeLocation(t, e),
                        this.boundaryRule.isInBoundary(this.numBoundaries) ? S.BOUNDARY : this.numBoundaries > 0 || this.isIn ? S.INTERIOR : S.EXTERIOR)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return be
                    }
                }),
                e(Le.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Le
                    }
                }),
                Le.octant = function() {
                    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0]
                          , e = arguments[1];
                        if (0 === t && 0 === e)
                            throw new i("Cannot compute the octant for point ( " + t + ", " + e + " )");
                        var n = Math.abs(t)
                          , r = Math.abs(e);
                        return t >= 0 ? e >= 0 ? n >= r ? 0 : 1 : n >= r ? 7 : 6 : e >= 0 ? n >= r ? 3 : 2 : n >= r ? 4 : 5
                    }
                    if (arguments[0]instanceof d && arguments[1]instanceof d) {
                        var o = arguments[0]
                          , s = arguments[1]
                          , a = s.x - o.x
                          , u = s.y - o.y;
                        if (0 === a && 0 === u)
                            throw new i("Cannot compute the octant for two identical points " + o);
                        return Le.octant(a, u)
                    }
                }
                ,
                e(Te.prototype, {
                    getCoordinates: function() {},
                    size: function() {},
                    getCoordinate: function(t) {},
                    isClosed: function() {},
                    setData: function(t) {},
                    getData: function() {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Te
                    }
                }),
                e(Re.prototype, {
                    getCoordinates: function() {
                        return this.pts
                    },
                    size: function() {
                        return this.pts.length
                    },
                    getCoordinate: function(t) {
                        return this.pts[t]
                    },
                    isClosed: function() {
                        return this.pts[0].equals(this.pts[this.pts.length - 1])
                    },
                    getSegmentOctant: function(t) {
                        return t === this.pts.length - 1 ? -1 : Le.octant(this.getCoordinate(t), this.getCoordinate(t + 1))
                    },
                    setData: function(t) {
                        this.data = t
                    },
                    getData: function() {
                        return this.data
                    },
                    toString: function() {
                        return re.toLineString(new Gt(this.pts))
                    },
                    interfaces_: function() {
                        return [Te]
                    },
                    getClass: function() {
                        return Re
                    }
                }),
                e(Oe.prototype, {
                    getBounds: function() {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Oe
                    }
                }),
                e(Pe.prototype, {
                    getItem: function() {
                        return this.item
                    },
                    getBounds: function() {
                        return this.bounds
                    },
                    interfaces_: function() {
                        return [Oe, u]
                    },
                    getClass: function() {
                        return Pe
                    }
                }),
                e(Me.prototype, {
                    poll: function() {
                        if (this.isEmpty())
                            return null;
                        var t = this.items.get(1);
                        return this.items.set(1, this.items.get(this._size)),
                        this._size -= 1,
                        this.reorder(1),
                        t
                    },
                    size: function() {
                        return this._size
                    },
                    reorder: function(t) {
                        for (var e = null, n = this.items.get(t); 2 * t <= this._size && (e = 2 * t,
                        e !== this._size && this.items.get(e + 1).compareTo(this.items.get(e)) < 0 && e++,
                        this.items.get(e).compareTo(n) < 0); t = e)
                            this.items.set(t, this.items.get(e));
                        this.items.set(t, n)
                    },
                    clear: function() {
                        this._size = 0,
                        this.items.clear()
                    },
                    isEmpty: function() {
                        return 0 === this._size
                    },
                    add: function(t) {
                        this.items.add(null),
                        this._size += 1;
                        var e = this._size;
                        for (this.items.set(0, t); t.compareTo(this.items.get(Math.trunc(e / 2))) < 0; e /= 2)
                            this.items.set(e, this.items.get(Math.trunc(e / 2)));
                        this.items.set(e, t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Me
                    }
                }),
                e(Ae.prototype, {
                    visitItem: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ae
                    }
                }),
                e(De.prototype, {
                    insert: function(t, e) {},
                    remove: function(t, e) {},
                    query: function() {
                        1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0],
                        arguments[1])
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return De
                    }
                }),
                e(Fe.prototype, {
                    getLevel: function() {
                        return this.level
                    },
                    size: function() {
                        return this.childBoundables.size()
                    },
                    getChildBoundables: function() {
                        return this.childBoundables
                    },
                    addChildBoundable: function(t) {
                        f.isTrue(null === this.bounds),
                        this.childBoundables.add(t)
                    },
                    isEmpty: function() {
                        return this.childBoundables.isEmpty()
                    },
                    getBounds: function() {
                        return null === this.bounds && (this.bounds = this.computeBounds()),
                        this.bounds
                    },
                    interfaces_: function() {
                        return [Oe, u]
                    },
                    getClass: function() {
                        return Fe
                    }
                }),
                Fe.serialVersionUID = 0x5a1e55ec41369800;
                var ls = {
                    reverseOrder: function() {
                        return {
                            compare: function(t, e) {
                                return e.compareTo(t)
                            }
                        }
                    },
                    min: function(t) {
                        return ls.sort(t),
                        t.get(0)
                    },
                    sort: function(t, e) {
                        var n = t.toArray();
                        e ? ut.sort(n, e) : ut.sort(n);
                        for (var i = t.iterator(), r = 0, o = n.length; r < o; r++)
                            i.next(),
                            i.set(n[r])
                    },
                    singletonList: function(t) {
                        var e = new I;
                        return e.add(t),
                        e
                    }
                };
                e(Ge.prototype, {
                    expandToQueue: function(t, e) {
                        var n = Ge.isComposite(this.boundable1)
                          , r = Ge.isComposite(this.boundable2);
                        if (n && r)
                            return Ge.area(this.boundable1) > Ge.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, t, e),
                            null) : (this.expand(this.boundable2, this.boundable1, t, e),
                            null);
                        if (n)
                            return this.expand(this.boundable1, this.boundable2, t, e),
                            null;
                        if (r)
                            return this.expand(this.boundable2, this.boundable1, t, e),
                            null;
                        throw new i("neither boundable is composite")
                    },
                    isLeaves: function() {
                        return !(Ge.isComposite(this.boundable1) || Ge.isComposite(this.boundable2))
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
                    },
                    expand: function(t, e, n, i) {
                        for (var r = t.getChildBoundables(), o = r.iterator(); o.hasNext(); ) {
                            var s = o.next()
                              , a = new Ge(s,e,this.itemDistance);
                            a.getDistance() < i && n.add(a)
                        }
                    },
                    getBoundable: function(t) {
                        return 0 === t ? this.boundable1 : this.boundable2
                    },
                    getDistance: function() {
                        return this._distance
                    },
                    distance: function() {
                        return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) : this.boundable1.getBounds().distance(this.boundable2.getBounds())
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return Ge
                    }
                }),
                Ge.area = function(t) {
                    return t.getBounds().getArea()
                }
                ,
                Ge.isComposite = function(t) {
                    return t instanceof Fe
                }
                ,
                e(ke.prototype, {
                    getNodeCapacity: function() {
                        return this.nodeCapacity
                    },
                    lastNode: function(t) {
                        return t.get(t.size() - 1)
                    },
                    size: function() {
                        if (0 === arguments.length)
                            return this.isEmpty() ? 0 : (this.build(),
                            this.size(this.root));
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = 0, n = t.getChildBoundables().iterator(); n.hasNext(); ) {
                                var i = n.next();
                                i instanceof Fe ? e += this.size(i) : i instanceof Pe && (e += 1)
                            }
                            return e
                        }
                    },
                    removeItem: function(t, e) {
                        for (var n = null, i = t.getChildBoundables().iterator(); i.hasNext(); ) {
                            var r = i.next();
                            r instanceof Pe && r.getItem() === e && (n = r)
                        }
                        return null !== n && (t.getChildBoundables().remove(n),
                        !0)
                    },
                    itemsTree: function() {
                        if (0 === arguments.length) {
                            this.build();
                            var t = this.itemsTree(this.root);
                            return null === t ? new I : t
                        }
                        if (1 === arguments.length) {
                            for (var e = arguments[0], n = new I, i = e.getChildBoundables().iterator(); i.hasNext(); ) {
                                var r = i.next();
                                if (r instanceof Fe) {
                                    var o = this.itemsTree(r);
                                    null !== o && n.add(o)
                                } else
                                    r instanceof Pe ? n.add(r.getItem()) : f.shouldNeverReachHere()
                            }
                            return n.size() <= 0 ? null : n
                        }
                    },
                    insert: function(t, e) {
                        f.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built."),
                        this.itemBoundables.add(new Pe(t,e))
                    },
                    boundablesAtLevel: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = new I;
                            return this.boundablesAtLevel(t, this.root, e),
                            e
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = arguments[2];
                            if (f.isTrue(n > -2),
                            i.getLevel() === n)
                                return r.add(i),
                                null;
                            for (var o = i.getChildBoundables().iterator(); o.hasNext(); ) {
                                var s = o.next();
                                s instanceof Fe ? this.boundablesAtLevel(n, s, r) : (f.isTrue(s instanceof Pe),
                                -1 === n && r.add(s))
                            }
                            return null
                        }
                    },
                    query: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.build();
                            var e = new I;
                            return this.isEmpty() ? e : (this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.query(t, this.root, e),
                            e)
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            if (this.build(),
                            this.isEmpty())
                                return null;
                            this.getIntersectsOp().intersects(this.root.getBounds(), n) && this.query(n, this.root, i)
                        } else if (3 === arguments.length)
                            if (b(arguments[2], Ae) && arguments[0]instanceof Object && arguments[1]instanceof Fe)
                                for (var r = arguments[0], o = arguments[1], s = arguments[2], a = o.getChildBoundables(), u = 0; u < a.size(); u++) {
                                    var l = a.get(u);
                                    this.getIntersectsOp().intersects(l.getBounds(), r) && (l instanceof Fe ? this.query(r, l, s) : l instanceof Pe ? s.visitItem(l.getItem()) : f.shouldNeverReachHere())
                                }
                            else if (b(arguments[2], v) && arguments[0]instanceof Object && arguments[1]instanceof Fe)
                                for (var c = arguments[0], h = arguments[1], d = arguments[2], a = h.getChildBoundables(), u = 0; u < a.size(); u++) {
                                    var l = a.get(u);
                                    this.getIntersectsOp().intersects(l.getBounds(), c) && (l instanceof Fe ? this.query(c, l, d) : l instanceof Pe ? d.add(l.getItem()) : f.shouldNeverReachHere())
                                }
                    },
                    build: function() {
                        return this.built ? null : (this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1),
                        this.itemBoundables = null,
                        void (this.built = !0))
                    },
                    getRoot: function() {
                        return this.build(),
                        this.root
                    },
                    remove: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return this.build(),
                            !!this.getIntersectsOp().intersects(this.root.getBounds(), t) && this.remove(t, this.root, e)
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = arguments[2]
                              , o = this.removeItem(i, r);
                            if (o)
                                return !0;
                            for (var s = null, a = i.getChildBoundables().iterator(); a.hasNext(); ) {
                                var u = a.next();
                                if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof Fe && (o = this.remove(n, u, r))) {
                                    s = u;
                                    break
                                }
                            }
                            return null !== s && s.getChildBoundables().isEmpty() && i.getChildBoundables().remove(s),
                            o
                        }
                    },
                    createHigherLevels: function(t, e) {
                        f.isTrue(!t.isEmpty());
                        var n = this.createParentBoundables(t, e + 1);
                        return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1)
                    },
                    depth: function() {
                        if (0 === arguments.length)
                            return this.isEmpty() ? 0 : (this.build(),
                            this.depth(this.root));
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = 0, n = t.getChildBoundables().iterator(); n.hasNext(); ) {
                                var i = n.next();
                                if (i instanceof Fe) {
                                    var r = this.depth(i);
                                    r > e && (e = r)
                                }
                            }
                            return e + 1
                        }
                    },
                    createParentBoundables: function(t, e) {
                        f.isTrue(!t.isEmpty());
                        var n = new I;
                        n.add(this.createNode(e));
                        var i = new I(t);
                        ls.sort(i, this.getComparator());
                        for (var r = i.iterator(); r.hasNext(); ) {
                            var o = r.next();
                            this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)),
                            this.lastNode(n).addChildBoundable(o)
                        }
                        return n
                    },
                    isEmpty: function() {
                        return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty()
                    },
                    interfaces_: function() {
                        return [u]
                    },
                    getClass: function() {
                        return ke
                    }
                }),
                ke.compareDoubles = function(t, e) {
                    return t > e ? 1 : t < e ? -1 : 0
                }
                ,
                ke.IntersectsOp = qe,
                ke.serialVersionUID = -0x35ef64c82d4c5400,
                ke.DEFAULT_NODE_CAPACITY = 10,
                e(Be.prototype, {
                    distance: function(t, e) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Be
                    }
                }),
                c(Ue, ke),
                e(Ue.prototype, {
                    createParentBoundablesFromVerticalSlices: function(t, e) {
                        f.isTrue(t.length > 0);
                        for (var n = new I, i = 0; i < t.length; i++)
                            n.addAll(this.createParentBoundablesFromVerticalSlice(t[i], e));
                        return n
                    },
                    createNode: function(t) {
                        return new Ve(t)
                    },
                    size: function() {
                        return 0 === arguments.length ? ke.prototype.size.call(this) : ke.prototype.size.apply(this, arguments)
                    },
                    insert: function() {
                        if (2 !== arguments.length)
                            return ke.prototype.insert.apply(this, arguments);
                        var t = arguments[0]
                          , e = arguments[1];
                        return t.isNull() ? null : void ke.prototype.insert.call(this, t, e)
                    },
                    getIntersectsOp: function() {
                        return Ue.intersectsOp
                    },
                    verticalSlices: function(t, e) {
                        for (var n = Math.trunc(Math.ceil(t.size() / e)), i = new Array(e).fill(null), r = t.iterator(), o = 0; o < e; o++) {
                            i[o] = new I;
                            for (var s = 0; r.hasNext() && s < n; ) {
                                var a = r.next();
                                i[o].add(a),
                                s++
                            }
                        }
                        return i
                    },
                    query: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return ke.prototype.query.call(this, t)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            ke.prototype.query.call(this, e, n)
                        } else if (3 === arguments.length)
                            if (b(arguments[2], Ae) && arguments[0]instanceof Object && arguments[1]instanceof Fe) {
                                var i = arguments[0]
                                  , r = arguments[1]
                                  , o = arguments[2];
                                ke.prototype.query.call(this, i, r, o)
                            } else if (b(arguments[2], v) && arguments[0]instanceof Object && arguments[1]instanceof Fe) {
                                var s = arguments[0]
                                  , a = arguments[1]
                                  , u = arguments[2];
                                ke.prototype.query.call(this, s, a, u)
                            }
                    },
                    getComparator: function() {
                        return Ue.yComparator
                    },
                    createParentBoundablesFromVerticalSlice: function(t, e) {
                        return ke.prototype.createParentBoundables.call(this, t, e)
                    },
                    remove: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return ke.prototype.remove.call(this, t, e)
                        }
                        return ke.prototype.remove.apply(this, arguments)
                    },
                    depth: function() {
                        return 0 === arguments.length ? ke.prototype.depth.call(this) : ke.prototype.depth.apply(this, arguments)
                    },
                    createParentBoundables: function(t, e) {
                        f.isTrue(!t.isEmpty());
                        var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity()))
                          , i = new I(t);
                        ls.sort(i, Ue.xComparator);
                        var r = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(n))));
                        return this.createParentBoundablesFromVerticalSlices(r, e)
                    },
                    nearestNeighbour: function() {
                        if (1 === arguments.length) {
                            if (b(arguments[0], Be)) {
                                var t = arguments[0]
                                  , e = new Ge(this.getRoot(),this.getRoot(),t);
                                return this.nearestNeighbour(e)
                            }
                            if (arguments[0]instanceof Ge) {
                                var n = arguments[0];
                                return this.nearestNeighbour(n, r.POSITIVE_INFINITY)
                            }
                        } else if (2 === arguments.length) {
                            if (arguments[0]instanceof Ue && b(arguments[1], Be)) {
                                var i = arguments[0]
                                  , o = arguments[1]
                                  , e = new Ge(this.getRoot(),i.getRoot(),o);
                                return this.nearestNeighbour(e)
                            }
                            if (arguments[0]instanceof Ge && "number" == typeof arguments[1]) {
                                var s = arguments[0]
                                  , a = arguments[1]
                                  , u = a
                                  , l = null
                                  , c = new Me;
                                for (c.add(s); !c.isEmpty() && u > 0; ) {
                                    var h = c.poll()
                                      , f = h.getDistance();
                                    if (f >= u)
                                        break;
                                    h.isLeaves() ? (u = f,
                                    l = h) : h.expandToQueue(c, u)
                                }
                                return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()]
                            }
                        } else if (3 === arguments.length) {
                            var d = arguments[0]
                              , g = arguments[1]
                              , p = arguments[2]
                              , m = new Pe(d,g)
                              , e = new Ge(this.getRoot(),m,p);
                            return this.nearestNeighbour(e)[0]
                        }
                    },
                    interfaces_: function() {
                        return [De, u]
                    },
                    getClass: function() {
                        return Ue
                    }
                }),
                Ue.centreX = function(t) {
                    return Ue.avg(t.getMinX(), t.getMaxX())
                }
                ,
                Ue.avg = function(t, e) {
                    return (t + e) / 2
                }
                ,
                Ue.centreY = function(t) {
                    return Ue.avg(t.getMinY(), t.getMaxY())
                }
                ,
                c(Ve, Fe),
                e(Ve.prototype, {
                    computeBounds: function() {
                        for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext(); ) {
                            var n = e.next();
                            null === t ? t = new C(n.getBounds()) : t.expandToInclude(n.getBounds())
                        }
                        return t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ve
                    }
                }),
                Ue.STRtreeNode = Ve,
                Ue.serialVersionUID = 0x39920f7d5f261e0,
                Ue.xComparator = {
                    interfaces_: function() {
                        return [a]
                    },
                    compare: function(t, e) {
                        return ke.compareDoubles(Ue.centreX(t.getBounds()), Ue.centreX(e.getBounds()))
                    }
                },
                Ue.yComparator = {
                    interfaces_: function() {
                        return [a]
                    },
                    compare: function(t, e) {
                        return ke.compareDoubles(Ue.centreY(t.getBounds()), Ue.centreY(e.getBounds()))
                    }
                },
                Ue.intersectsOp = {
                    interfaces_: function() {
                        return [IntersectsOp]
                    },
                    intersects: function(t, e) {
                        return t.intersects(e)
                    }
                },
                Ue.DEFAULT_NODE_CAPACITY = 10,
                e(ze.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ze
                    }
                }),
                ze.relativeSign = function(t, e) {
                    return t < e ? -1 : t > e ? 1 : 0
                }
                ,
                ze.compare = function(t, e, n) {
                    if (e.equals2D(n))
                        return 0;
                    var i = ze.relativeSign(e.x, n.x)
                      , r = ze.relativeSign(e.y, n.y);
                    switch (t) {
                    case 0:
                        return ze.compareValue(i, r);
                    case 1:
                        return ze.compareValue(r, i);
                    case 2:
                        return ze.compareValue(r, -i);
                    case 3:
                        return ze.compareValue(-i, r);
                    case 4:
                        return ze.compareValue(-i, -r);
                    case 5:
                        return ze.compareValue(-r, -i);
                    case 6:
                        return ze.compareValue(-r, i);
                    case 7:
                        return ze.compareValue(i, -r)
                    }
                    return f.shouldNeverReachHere("invalid octant value"),
                    0
                }
                ,
                ze.compareValue = function(t, e) {
                    return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0
                }
                ,
                e(je.prototype, {
                    getCoordinate: function() {
                        return this.coord
                    },
                    print: function(t) {
                        t.print(this.coord),
                        t.print(" seg # = " + this.segmentIndex)
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : ze.compare(this.segmentOctant, this.coord, e.coord)
                    },
                    isEndPoint: function(t) {
                        return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t
                    },
                    isInterior: function() {
                        return this._isInterior
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return je
                    }
                }),
                e(Ye.prototype, {
                    getSplitCoordinates: function() {
                        var t = new N;
                        this.addEndpoints();
                        for (var e = this.iterator(), n = e.next(); e.hasNext(); ) {
                            var i = e.next();
                            this.addEdgeCoordinates(n, i, t),
                            n = i
                        }
                        return t.toCoordinateArray()
                    },
                    addCollapsedNodes: function() {
                        var t = new I;
                        this.findCollapsesFromInsertedNodes(t),
                        this.findCollapsesFromExistingVertices(t);
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next().intValue();
                            this.add(this.edge.getCoordinate(n), n)
                        }
                    },
                    print: function(t) {
                        t.println("Intersections:");
                        for (var e = this.iterator(); e.hasNext(); ) {
                            e.next().print(t)
                        }
                    },
                    findCollapsesFromExistingVertices: function(t) {
                        for (var e = 0; e < this.edge.size() - 2; e++) {
                            var n = this.edge.getCoordinate(e)
                              , i = (this.edge.getCoordinate(e + 1),
                            this.edge.getCoordinate(e + 2));
                            n.equals2D(i) && t.add(new R(e + 1))
                        }
                    },
                    addEdgeCoordinates: function(t, e, n) {
                        var i = e.segmentIndex - t.segmentIndex + 2
                          , r = this.edge.getCoordinate(e.segmentIndex)
                          , o = e.isInterior() || !e.coord.equals2D(r);
                        o || i--,
                        n.add(new d(t.coord), !1);
                        for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++)
                            n.add(this.edge.getCoordinate(s));
                        o && n.add(new d(e.coord))
                    },
                    iterator: function() {
                        return this.nodeMap.values().iterator()
                    },
                    addSplitEdges: function(t) {
                        this.addEndpoints(),
                        this.addCollapsedNodes();
                        for (var e = this.iterator(), n = e.next(); e.hasNext(); ) {
                            var i = e.next()
                              , r = this.createSplitEdge(n, i);
                            t.add(r),
                            n = i
                        }
                    },
                    findCollapseIndex: function(t, e, n) {
                        if (!t.coord.equals2D(e.coord))
                            return !1;
                        var i = e.segmentIndex - t.segmentIndex;
                        return e.isInterior() || i--,
                        1 === i && (n[0] = t.segmentIndex + 1,
                        !0)
                    },
                    findCollapsesFromInsertedNodes: function(t) {
                        for (var e = new Array(1).fill(null), n = this.iterator(), i = n.next(); n.hasNext(); ) {
                            var r = n.next();
                            this.findCollapseIndex(i, r, e) && t.add(new R(e[0])),
                            i = r
                        }
                    },
                    getEdge: function() {
                        return this.edge
                    },
                    addEndpoints: function() {
                        var t = this.edge.size() - 1;
                        this.add(this.edge.getCoordinate(0), 0),
                        this.add(this.edge.getCoordinate(t), t)
                    },
                    createSplitEdge: function(t, e) {
                        var n = e.segmentIndex - t.segmentIndex + 2
                          , i = this.edge.getCoordinate(e.segmentIndex)
                          , r = e.isInterior() || !e.coord.equals2D(i);
                        r || n--;
                        var o = new Array(n).fill(null)
                          , s = 0;
                        o[s++] = new d(t.coord);
                        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++)
                            o[s++] = this.edge.getCoordinate(a);
                        return r && (o[s] = new d(e.coord)),
                        new We(o,this.edge.getData())
                    },
                    add: function(t, e) {
                        var n = new je(this.edge,t,e,this.edge.getSegmentOctant(e))
                          , i = this.nodeMap.get(n);
                        return null !== i ? (f.isTrue(i.coord.equals2D(t), "Found equal nodes with different coordinates"),
                        i) : (this.nodeMap.put(n, n),
                        n)
                    },
                    checkSplitEdgesCorrectness: function(t) {
                        var e = this.edge.getCoordinates()
                          , n = t.get(0)
                          , i = n.getCoordinate(0);
                        if (!i.equals2D(e[0]))
                            throw new l("bad split edge start point at " + i);
                        var r = t.get(t.size() - 1)
                          , o = r.getCoordinates()
                          , s = o[o.length - 1];
                        if (!s.equals2D(e[e.length - 1]))
                            throw new l("bad split edge end point at " + s)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ye
                    }
                }),
                e(Xe.prototype, {
                    next: function() {
                        return null === this.currNode ? (this.currNode = this.nextNode,
                        this.currSegIndex = this.currNode.segmentIndex,
                        this.readNextNode(),
                        this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode,
                        this.currSegIndex = this.currNode.segmentIndex,
                        this.readNextNode(),
                        this.currNode) : (this.nextNode.segmentIndex,
                        this.currNode.segmentIndex,
                        null)
                    },
                    remove: function() {
                        throw new UnsupportedOperationException(this.getClass().getName())
                    },
                    hasNext: function() {
                        return null !== this.nextNode
                    },
                    readNextNode: function() {
                        this.nodeIt.hasNext() ? this.nextNode = this.nodeIt.next() : this.nextNode = null
                    },
                    interfaces_: function() {
                        return [p]
                    },
                    getClass: function() {
                        return Xe
                    }
                }),
                e(He.prototype, {
                    addIntersection: function(t, e) {},
                    interfaces_: function() {
                        return [Te]
                    },
                    getClass: function() {
                        return He
                    }
                }),
                e(We.prototype, {
                    getCoordinates: function() {
                        return this.pts
                    },
                    size: function() {
                        return this.pts.length
                    },
                    getCoordinate: function(t) {
                        return this.pts[t]
                    },
                    isClosed: function() {
                        return this.pts[0].equals(this.pts[this.pts.length - 1])
                    },
                    getSegmentOctant: function(t) {
                        return t === this.pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
                    },
                    setData: function(t) {
                        this.data = t
                    },
                    safeOctant: function(t, e) {
                        return t.equals2D(e) ? 0 : Le.octant(t, e)
                    },
                    getData: function() {
                        return this.data
                    },
                    addIntersection: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            this.addIntersectionNode(t, e)
                        } else if (4 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = (arguments[2],
                            arguments[3])
                              , o = new d(n.getIntersection(r));
                            this.addIntersection(o, i)
                        }
                    },
                    toString: function() {
                        return re.toLineString(new Gt(this.pts))
                    },
                    getNodeList: function() {
                        return this.nodeList
                    },
                    addIntersectionNode: function(t, e) {
                        var n = e
                          , i = n + 1;
                        if (i < this.pts.length) {
                            var r = this.pts[i];
                            t.equals2D(r) && (n = i)
                        }
                        return this.nodeList.add(t, n)
                    },
                    addIntersections: function(t, e, n) {
                        for (var i = 0; i < t.getIntersectionNum(); i++)
                            this.addIntersection(t, e, n, i)
                    },
                    interfaces_: function() {
                        return [He]
                    },
                    getClass: function() {
                        return We
                    }
                }),
                We.getNodedSubstrings = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0]
                          , e = new I;
                        return We.getNodedSubstrings(t, e),
                        e
                    }
                    if (2 === arguments.length)
                        for (var n = arguments[0], i = arguments[1], r = n.iterator(); r.hasNext(); ) {
                            var o = r.next();
                            o.getNodeList().addSplitEdges(i)
                        }
                }
                ,
                e(Je.prototype, {
                    overlap: function() {
                        if (2 === arguments.length)
                            arguments[0],
                            arguments[1];
                        else if (4 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1]
                              , n = arguments[2]
                              , i = arguments[3];
                            t.getLineSegment(e, this.overlapSeg1),
                            n.getLineSegment(i, this.overlapSeg2),
                            this.overlap(this.overlapSeg1, this.overlapSeg2)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Je
                    }
                }),
                e($e.prototype, {
                    getLineSegment: function(t, e) {
                        e.p0 = this.pts[t],
                        e.p1 = this.pts[t + 1]
                    },
                    computeSelect: function(t, e, n, i) {
                        var r = this.pts[e]
                          , o = this.pts[n];
                        if (i.tempEnv1.init(r, o),
                        n - e == 1)
                            return i.select(this, e),
                            null;
                        if (!t.intersects(i.tempEnv1))
                            return null;
                        var s = Math.trunc((e + n) / 2);
                        e < s && this.computeSelect(t, e, s, i),
                        s < n && this.computeSelect(t, s, n, i)
                    },
                    getCoordinates: function() {
                        for (var t = new Array(this.end - this.start + 1).fill(null), e = 0, n = this.start; n <= this.end; n++)
                            t[e++] = this.pts[n];
                        return t
                    },
                    computeOverlaps: function(t, e) {
                        this.computeOverlapsInternal(this.start, this.end, t, t.start, t.end, e)
                    },
                    setId: function(t) {
                        this.id = t
                    },
                    select: function(t, e) {
                        this.computeSelect(t, this.start, this.end, e)
                    },
                    getEnvelope: function() {
                        if (null === this.env) {
                            var t = this.pts[this.start]
                              , e = this.pts[this.end];
                            this.env = new C(t,e)
                        }
                        return this.env
                    },
                    getEndIndex: function() {
                        return this.end
                    },
                    getStartIndex: function() {
                        return this.start
                    },
                    getContext: function() {
                        return this.context
                    },
                    getId: function() {
                        return this.id
                    },
                    computeOverlapsInternal: function(t, e, n, i, r, o) {
                        var s = this.pts[t]
                          , a = this.pts[e]
                          , u = n.pts[i]
                          , l = n.pts[r];
                        if (e - t == 1 && r - i == 1)
                            return o.overlap(this, t, n, i),
                            null;
                        if (o.tempEnv1.init(s, a),
                        o.tempEnv2.init(u, l),
                        !o.tempEnv1.intersects(o.tempEnv2))
                            return null;
                        var c = Math.trunc((t + e) / 2)
                          , h = Math.trunc((i + r) / 2);
                        t < c && (i < h && this.computeOverlapsInternal(t, c, n, i, h, o),
                        h < r && this.computeOverlapsInternal(t, c, n, h, r, o)),
                        c < e && (i < h && this.computeOverlapsInternal(c, e, n, i, h, o),
                        h < r && this.computeOverlapsInternal(c, e, n, h, r, o))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return $e
                    }
                }),
                e(Ke.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ke
                    }
                }),
                Ke.isNorthern = function(t) {
                    return t === Ke.NE || t === Ke.NW
                }
                ,
                Ke.isOpposite = function(t, e) {
                    return t !== e && 2 == (t - e + 4) % 4
                }
                ,
                Ke.commonHalfPlane = function(t, e) {
                    if (t === e)
                        return t;
                    if (2 == (t - e + 4) % 4)
                        return -1;
                    var n = t < e ? t : e
                      , i = t > e ? t : e;
                    return 0 === n && 3 === i ? 3 : n
                }
                ,
                Ke.isInHalfPlane = function(t, e) {
                    return e === Ke.SE ? t === Ke.SE || t === Ke.SW : t === e || t === e + 1
                }
                ,
                Ke.quadrant = function() {
                    if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                        var t = arguments[0]
                          , e = arguments[1];
                        if (0 === t && 0 === e)
                            throw new i("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
                        return t >= 0 ? e >= 0 ? Ke.NE : Ke.SE : e >= 0 ? Ke.NW : Ke.SW
                    }
                    if (arguments[0]instanceof d && arguments[1]instanceof d) {
                        var n = arguments[0]
                          , r = arguments[1];
                        if (r.x === n.x && r.y === n.y)
                            throw new i("Cannot compute the quadrant for two identical points " + n);
                        return r.x >= n.x ? r.y >= n.y ? Ke.NE : Ke.SE : r.y >= n.y ? Ke.NW : Ke.SW
                    }
                }
                ,
                Ke.NE = 0,
                Ke.NW = 1,
                Ke.SW = 2,
                Ke.SE = 3,
                e(Ze.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ze
                    }
                }),
                Ze.getChainStartIndices = function(t) {
                    var e = 0
                      , n = new I;
                    n.add(new R(e));
                    do {
                        var i = Ze.findChainEnd(t, e);
                        n.add(new R(i)),
                        e = i
                    } while (e < t.length - 1);return Ze.toIntArray(n)
                }
                ,
                Ze.findChainEnd = function(t, e) {
                    for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]); )
                        n++;
                    if (n >= t.length - 1)
                        return t.length - 1;
                    for (var i = Ke.quadrant(t[n], t[n + 1]), r = e + 1; r < t.length; ) {
                        if (!t[r - 1].equals2D(t[r])) {
                            if (Ke.quadrant(t[r - 1], t[r]) !== i)
                                break
                        }
                        r++
                    }
                    return r - 1
                }
                ,
                Ze.getChains = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Ze.getChains(t, null)
                    }
                    if (2 === arguments.length) {
                        for (var e = arguments[0], n = arguments[1], i = new I, r = Ze.getChainStartIndices(e), o = 0; o < r.length - 1; o++) {
                            var s = new $e(e,r[o],r[o + 1],n);
                            i.add(s)
                        }
                        return i
                    }
                }
                ,
                Ze.toIntArray = function(t) {
                    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)
                        e[n] = t.get(n).intValue();
                    return e
                }
                ,
                e(Qe.prototype, {
                    computeNodes: function(t) {},
                    getNodedSubstrings: function() {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Qe
                    }
                }),
                e(tn.prototype, {
                    setSegmentIntersector: function(t) {
                        this.segInt = t
                    },
                    interfaces_: function() {
                        return [Qe]
                    },
                    getClass: function() {
                        return tn
                    }
                }),
                c(en, tn),
                e(en.prototype, {
                    getMonotoneChains: function() {
                        return this.monoChains
                    },
                    getNodedSubstrings: function() {
                        return We.getNodedSubstrings(this.nodedSegStrings)
                    },
                    getIndex: function() {
                        return this.index
                    },
                    add: function(t) {
                        for (var e = Ze.getChains(t.getCoordinates(), t), n = e.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.setId(this.idCounter++),
                            this.index.insert(i.getEnvelope(), i),
                            this.monoChains.add(i)
                        }
                    },
                    computeNodes: function(t) {
                        this.nodedSegStrings = t;
                        for (var e = t.iterator(); e.hasNext(); )
                            this.add(e.next());
                        this.intersectChains()
                    },
                    intersectChains: function() {
                        for (var t = new nn(this.segInt), e = this.monoChains.iterator(); e.hasNext(); )
                            for (var n = e.next(), i = this.index.query(n.getEnvelope()), r = i.iterator(); r.hasNext(); ) {
                                var o = r.next();
                                if (o.getId() > n.getId() && (n.computeOverlaps(o, t),
                                this.nOverlaps++),
                                this.segInt.isDone())
                                    return null
                            }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return en
                    }
                }),
                c(nn, Je),
                e(nn.prototype, {
                    overlap: function() {
                        if (4 !== arguments.length)
                            return Je.prototype.overlap.apply(this, arguments);
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = arguments[2]
                          , i = arguments[3]
                          , r = t.getContext()
                          , o = n.getContext();
                        this.si.processIntersections(r, e, o, i)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return nn
                    }
                }),
                en.SegmentOverlapAction = nn,
                c(rn, l),
                e(rn.prototype, {
                    getCoordinate: function() {
                        return this.pt
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return rn
                    }
                }),
                rn.msgWithCoord = function(t, e) {
                    return null !== e ? t + " [ " + e + " ]" : t
                }
                ,
                e(on.prototype, {
                    processIntersections: function(t, e, n, i) {},
                    isDone: function() {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return on
                    }
                }),
                e(sn.prototype, {
                    getInteriorIntersection: function() {
                        return this.interiorIntersection
                    },
                    setCheckEndSegmentsOnly: function(t) {
                        this.isCheckEndSegmentsOnly = t
                    },
                    getIntersectionSegments: function() {
                        return this.intSegments
                    },
                    count: function() {
                        return this.intersectionCount
                    },
                    getIntersections: function() {
                        return this.intersections
                    },
                    setFindAllIntersections: function(t) {
                        this.findAllIntersections = t
                    },
                    setKeepIntersections: function(t) {
                        this.keepIntersections = t
                    },
                    processIntersections: function(t, e, n, i) {
                        if (!this.findAllIntersections && this.hasIntersection())
                            return null;
                        if (t === n && e === i)
                            return null;
                        if (this.isCheckEndSegmentsOnly) {
                            if (!(this.isEndSegment(t, e) || this.isEndSegment(n, i)))
                                return null
                        }
                        var r = t.getCoordinates()[e]
                          , o = t.getCoordinates()[e + 1]
                          , s = n.getCoordinates()[i]
                          , a = n.getCoordinates()[i + 1];
                        this.li.computeIntersection(r, o, s, a),
                        this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = new Array(4).fill(null),
                        this.intSegments[0] = r,
                        this.intSegments[1] = o,
                        this.intSegments[2] = s,
                        this.intSegments[3] = a,
                        this.interiorIntersection = this.li.getIntersection(0),
                        this.keepIntersections && this.intersections.add(this.interiorIntersection),
                        this.intersectionCount++)
                    },
                    isEndSegment: function(t, e) {
                        return 0 === e || e >= t.size() - 2
                    },
                    hasIntersection: function() {
                        return null !== this.interiorIntersection
                    },
                    isDone: function() {
                        return !this.findAllIntersections && null !== this.interiorIntersection
                    },
                    interfaces_: function() {
                        return [on]
                    },
                    getClass: function() {
                        return sn
                    }
                }),
                sn.createAllIntersectionsFinder = function(t) {
                    var e = new sn(t);
                    return e.setFindAllIntersections(!0),
                    e
                }
                ,
                sn.createAnyIntersectionFinder = function(t) {
                    return new sn(t)
                }
                ,
                sn.createIntersectionCounter = function(t) {
                    var e = new sn(t);
                    return e.setFindAllIntersections(!0),
                    e.setKeepIntersections(!1),
                    e
                }
                ,
                e(an.prototype, {
                    execute: function() {
                        return null !== this.segInt ? null : void this.checkInteriorIntersections()
                    },
                    getIntersections: function() {
                        return this.segInt.getIntersections()
                    },
                    isValid: function() {
                        return this.execute(),
                        this._isValid
                    },
                    setFindAllIntersections: function(t) {
                        this.findAllIntersections = t
                    },
                    checkInteriorIntersections: function() {
                        this._isValid = !0,
                        this.segInt = new sn(this.li),
                        this.segInt.setFindAllIntersections(this.findAllIntersections);
                        var t = new en;
                        if (t.setSegmentIntersector(this.segInt),
                        t.computeNodes(this.segStrings),
                        this.segInt.hasIntersection())
                            return this._isValid = !1,
                            null
                    },
                    checkValid: function() {
                        if (this.execute(),
                        !this._isValid)
                            throw new rn(this.getErrorMessage(),this.segInt.getInteriorIntersection())
                    },
                    getErrorMessage: function() {
                        if (this._isValid)
                            return "no intersections found";
                        var t = this.segInt.getIntersectionSegments();
                        return "found non-noded intersection between " + re.toLineString(t[0], t[1]) + " and " + re.toLineString(t[2], t[3])
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return an
                    }
                }),
                an.computeIntersections = function(t) {
                    var e = new an(t);
                    return e.setFindAllIntersections(!0),
                    e.isValid(),
                    e.getIntersections()
                }
                ,
                e(un.prototype, {
                    checkValid: function() {
                        this.nv.checkValid()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return un
                    }
                }),
                un.toSegmentStrings = function(t) {
                    for (var e = new I, n = t.iterator(); n.hasNext(); ) {
                        var i = n.next();
                        e.add(new Re(i.getCoordinates(),i))
                    }
                    return e
                }
                ,
                un.checkValid = function(t) {
                    new un(t).checkValid()
                }
                ,
                e(ln.prototype, {
                    map: function(t) {
                        for (var e = new I, n = 0; n < t.getNumGeometries(); n++) {
                            var i = this.mapOp.map(t.getGeometryN(n));
                            i.isEmpty() || e.add(i)
                        }
                        return t.getFactory().createGeometryCollection(ne.toGeometryArray(e))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ln
                    }
                }),
                ln.map = function(t, e) {
                    return new ln(e).map(t)
                }
                ,
                e(cn.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return cn
                    }
                }),
                cn.opposite = function(t) {
                    return t === cn.LEFT ? cn.RIGHT : t === cn.RIGHT ? cn.LEFT : t
                }
                ,
                cn.ON = 0,
                cn.LEFT = 1,
                cn.RIGHT = 2,
                e(hn.prototype, {
                    setAllLocations: function(t) {
                        for (var e = 0; e < this.location.length; e++)
                            this.location[e] = t
                    },
                    isNull: function() {
                        for (var t = 0; t < this.location.length; t++)
                            if (this.location[t] !== S.NONE)
                                return !1;
                        return !0
                    },
                    setAllLocationsIfNull: function(t) {
                        for (var e = 0; e < this.location.length; e++)
                            this.location[e] === S.NONE && (this.location[e] = t)
                    },
                    isLine: function() {
                        return 1 === this.location.length
                    },
                    merge: function(t) {
                        if (t.location.length > this.location.length) {
                            var e = new Array(3).fill(null);
                            e[cn.ON] = this.location[cn.ON],
                            e[cn.LEFT] = S.NONE,
                            e[cn.RIGHT] = S.NONE,
                            this.location = e
                        }
                        for (var n = 0; n < this.location.length; n++)
                            this.location[n] === S.NONE && n < t.location.length && (this.location[n] = t.location[n])
                    },
                    getLocations: function() {
                        return this.location
                    },
                    flip: function() {
                        if (this.location.length <= 1)
                            return null;
                        var t = this.location[cn.LEFT];
                        this.location[cn.LEFT] = this.location[cn.RIGHT],
                        this.location[cn.RIGHT] = t
                    },
                    toString: function() {
                        var t = new T;
                        return this.location.length > 1 && t.append(S.toLocationSymbol(this.location[cn.LEFT])),
                        t.append(S.toLocationSymbol(this.location[cn.ON])),
                        this.location.length > 1 && t.append(S.toLocationSymbol(this.location[cn.RIGHT])),
                        t.toString()
                    },
                    setLocations: function(t, e, n) {
                        this.location[cn.ON] = t,
                        this.location[cn.LEFT] = e,
                        this.location[cn.RIGHT] = n
                    },
                    get: function(t) {
                        return t < this.location.length ? this.location[t] : S.NONE
                    },
                    isArea: function() {
                        return this.location.length > 1
                    },
                    isAnyNull: function() {
                        for (var t = 0; t < this.location.length; t++)
                            if (this.location[t] === S.NONE)
                                return !0;
                        return !1
                    },
                    setLocation: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setLocation(cn.ON, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            this.location[e] = n
                        }
                    },
                    init: function(t) {
                        this.location = new Array(t).fill(null),
                        this.setAllLocations(S.NONE)
                    },
                    isEqualOnSide: function(t, e) {
                        return this.location[e] === t.location[e]
                    },
                    allPositionsEqual: function(t) {
                        for (var e = 0; e < this.location.length; e++)
                            if (this.location[e] !== t)
                                return !1;
                        return !0
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return hn
                    }
                }),
                e(fn.prototype, {
                    getGeometryCount: function() {
                        var t = 0;
                        return this.elt[0].isNull() || t++,
                        this.elt[1].isNull() || t++,
                        t
                    },
                    setAllLocations: function(t, e) {
                        this.elt[t].setAllLocations(e)
                    },
                    isNull: function(t) {
                        return this.elt[t].isNull()
                    },
                    setAllLocationsIfNull: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.setAllLocationsIfNull(0, t),
                            this.setAllLocationsIfNull(1, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            this.elt[e].setAllLocationsIfNull(n)
                        }
                    },
                    isLine: function(t) {
                        return this.elt[t].isLine()
                    },
                    merge: function(t) {
                        for (var e = 0; e < 2; e++)
                            null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new hn(t.elt[e]) : this.elt[e].merge(t.elt[e])
                    },
                    flip: function() {
                        this.elt[0].flip(),
                        this.elt[1].flip()
                    },
                    getLocation: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.elt[t].get(cn.ON)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            return this.elt[e].get(n)
                        }
                    },
                    toString: function() {
                        var t = new T;
                        return null !== this.elt[0] && (t.append("A:"),
                        t.append(this.elt[0].toString())),
                        null !== this.elt[1] && (t.append(" B:"),
                        t.append(this.elt[1].toString())),
                        t.toString()
                    },
                    isArea: function() {
                        if (0 === arguments.length)
                            return this.elt[0].isArea() || this.elt[1].isArea();
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.elt[t].isArea()
                        }
                    },
                    isAnyNull: function(t) {
                        return this.elt[t].isAnyNull()
                    },
                    setLocation: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            this.elt[t].setLocation(cn.ON, e)
                        } else if (3 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = arguments[2];
                            this.elt[n].setLocation(i, r)
                        }
                    },
                    isEqualOnSide: function(t, e) {
                        return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
                    },
                    allPositionsEqual: function(t, e) {
                        return this.elt[t].allPositionsEqual(e)
                    },
                    toLine: function(t) {
                        this.elt[t].isArea() && (this.elt[t] = new hn(this.elt[t].location[0]))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return fn
                    }
                }),
                fn.toLineLabel = function(t) {
                    for (var e = new fn(S.NONE), n = 0; n < 2; n++)
                        e.setLocation(n, t.getLocation(n));
                    return e
                }
                ,
                e(dn.prototype, {
                    computeRing: function() {
                        if (null !== this.ring)
                            return null;
                        for (var t = new Array(this.pts.size()).fill(null), e = 0; e < this.pts.size(); e++)
                            t[e] = this.pts.get(e);
                        this.ring = this.geometryFactory.createLinearRing(t),
                        this._isHole = le.isCCW(this.ring.getCoordinates())
                    },
                    isIsolated: function() {
                        return 1 === this.label.getGeometryCount()
                    },
                    computePoints: function(t) {
                        this.startDe = t;
                        var e = t
                          , n = !0;
                        do {
                            if (null === e)
                                throw new rn("Found null DirectedEdge");
                            if (e.getEdgeRing() === this)
                                throw new rn("Directed Edge visited twice during ring-building at " + e.getCoordinate());
                            this.edges.add(e);
                            var i = e.getLabel();
                            f.isTrue(i.isArea()),
                            this.mergeLabel(i),
                            this.addPoints(e.getEdge(), e.isForward(), n),
                            n = !1,
                            this.setEdgeRing(e, this),
                            e = this.getNext(e)
                        } while (e !== this.startDe)
                    },
                    getLinearRing: function() {
                        return this.ring
                    },
                    getCoordinate: function(t) {
                        return this.pts.get(t)
                    },
                    computeMaxNodeDegree: function() {
                        this.maxNodeDegree = 0;
                        var t = this.startDe;
                        do {
                            var e = t.getNode()
                              , n = e.getEdges().getOutgoingDegree(this);
                            n > this.maxNodeDegree && (this.maxNodeDegree = n),
                            t = this.getNext(t)
                        } while (t !== this.startDe);this.maxNodeDegree *= 2
                    },
                    addPoints: function(t, e, n) {
                        var i = t.getCoordinates();
                        if (e) {
                            var r = 1;
                            n && (r = 0);
                            for (var o = r; o < i.length; o++)
                                this.pts.add(i[o])
                        } else {
                            var r = i.length - 2;
                            n && (r = i.length - 1);
                            for (var o = r; o >= 0; o--)
                                this.pts.add(i[o])
                        }
                    },
                    isHole: function() {
                        return this._isHole
                    },
                    setInResult: function() {
                        var t = this.startDe;
                        do {
                            t.getEdge().setInResult(!0),
                            t = t.getNext()
                        } while (t !== this.startDe)
                    },
                    containsPoint: function(t) {
                        var e = this.getLinearRing();
                        if (!e.getEnvelopeInternal().contains(t))
                            return !1;
                        if (!le.isPointInRing(t, e.getCoordinates()))
                            return !1;
                        for (var n = this.holes.iterator(); n.hasNext(); ) {
                            if (n.next().containsPoint(t))
                                return !1
                        }
                        return !0
                    },
                    addHole: function(t) {
                        this.holes.add(t)
                    },
                    isShell: function() {
                        return null === this.shell
                    },
                    getLabel: function() {
                        return this.label
                    },
                    getEdges: function() {
                        return this.edges
                    },
                    getMaxNodeDegree: function() {
                        return this.maxNodeDegree < 0 && this.computeMaxNodeDegree(),
                        this.maxNodeDegree
                    },
                    getShell: function() {
                        return this.shell
                    },
                    mergeLabel: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.mergeLabel(t, 0),
                            this.mergeLabel(t, 1)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1]
                              , i = e.getLocation(n, cn.RIGHT);
                            if (i === S.NONE)
                                return null;
                            if (this.label.getLocation(n) === S.NONE)
                                return this.label.setLocation(n, i),
                                null
                        }
                    },
                    setShell: function(t) {
                        this.shell = t,
                        null !== t && t.addHole(this)
                    },
                    toPolygon: function(t) {
                        for (var e = new Array(this.holes.size()).fill(null), n = 0; n < this.holes.size(); n++)
                            e[n] = this.holes.get(n).getLinearRing();
                        return t.createPolygon(this.getLinearRing(), e)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return dn
                    }
                }),
                c(gn, dn),
                e(gn.prototype, {
                    setEdgeRing: function(t, e) {
                        t.setMinEdgeRing(e)
                    },
                    getNext: function(t) {
                        return t.getNextMin()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return gn
                    }
                }),
                c(pn, dn),
                e(pn.prototype, {
                    buildMinimalRings: function() {
                        var t = new I
                          , e = this.startDe;
                        do {
                            if (null === e.getMinEdgeRing()) {
                                var n = new gn(e,this.geometryFactory);
                                t.add(n)
                            }
                            e = e.getNext()
                        } while (e !== this.startDe);return t
                    },
                    setEdgeRing: function(t, e) {
                        t.setEdgeRing(e)
                    },
                    linkDirectedEdgesForMinimalEdgeRings: function() {
                        var t = this.startDe;
                        do {
                            t.getNode().getEdges().linkMinimalDirectedEdges(this),
                            t = t.getNext()
                        } while (t !== this.startDe)
                    },
                    getNext: function(t) {
                        return t.getNext()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return pn
                    }
                }),
                e(mn.prototype, {
                    setVisited: function(t) {
                        this._isVisited = t
                    },
                    setInResult: function(t) {
                        this._isInResult = t
                    },
                    isCovered: function() {
                        return this._isCovered
                    },
                    isCoveredSet: function() {
                        return this._isCoveredSet
                    },
                    setLabel: function(t) {
                        this.label = t
                    },
                    getLabel: function() {
                        return this.label
                    },
                    setCovered: function(t) {
                        this._isCovered = t,
                        this._isCoveredSet = !0
                    },
                    updateIM: function(t) {
                        f.isTrue(this.label.getGeometryCount() >= 2, "found partial label"),
                        this.computeIM(t)
                    },
                    isInResult: function() {
                        return this._isInResult
                    },
                    isVisited: function() {
                        return this._isVisited
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return mn
                    }
                }),
                c(yn, mn),
                e(yn.prototype, {
                    isIncidentEdgeInResult: function() {
                        for (var t = this.getEdges().getEdges().iterator(); t.hasNext(); ) {
                            if (t.next().getEdge().isInResult())
                                return !0
                        }
                        return !1
                    },
                    isIsolated: function() {
                        return 1 === this.label.getGeometryCount()
                    },
                    getCoordinate: function() {
                        return this.coord
                    },
                    print: function(t) {
                        t.println("node " + this.coord + " lbl: " + this.label)
                    },
                    computeIM: function(t) {},
                    computeMergedLocation: function(t, e) {
                        var n = S.NONE;
                        if (n = this.label.getLocation(e),
                        !t.isNull(e)) {
                            var i = t.getLocation(e);
                            n !== S.BOUNDARY && (n = i)
                        }
                        return n
                    },
                    setLabel: function() {
                        if (2 !== arguments.length)
                            return mn.prototype.setLabel.apply(this, arguments);
                        var t = arguments[0]
                          , e = arguments[1];
                        null === this.label ? this.label = new fn(t,e) : this.label.setLocation(t, e)
                    },
                    getEdges: function() {
                        return this.edges
                    },
                    mergeLabel: function() {
                        if (arguments[0]instanceof yn) {
                            var t = arguments[0];
                            this.mergeLabel(t.label)
                        } else if (arguments[0]instanceof fn)
                            for (var e = arguments[0], n = 0; n < 2; n++) {
                                var i = this.computeMergedLocation(e, n)
                                  , r = this.label.getLocation(n);
                                r === S.NONE && this.label.setLocation(n, i)
                            }
                    },
                    add: function(t) {
                        this.edges.insert(t),
                        t.setNode(this)
                    },
                    setLabelBoundary: function(t) {
                        if (null === this.label)
                            return null;
                        var e = S.NONE;
                        null !== this.label && (e = this.label.getLocation(t));
                        var n = null;
                        switch (e) {
                        case S.BOUNDARY:
                            n = S.INTERIOR;
                            break;
                        case S.INTERIOR:
                            n = S.BOUNDARY;
                            break;
                        default:
                            n = S.BOUNDARY
                        }
                        this.label.setLocation(t, n)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return yn
                    }
                }),
                e(vn.prototype, {
                    find: function(t) {
                        return this.nodeMap.get(t)
                    },
                    addNode: function() {
                        if (arguments[0]instanceof d) {
                            var t = arguments[0]
                              , e = this.nodeMap.get(t);
                            return null === e && (e = this.nodeFact.createNode(t),
                            this.nodeMap.put(t, e)),
                            e
                        }
                        if (arguments[0]instanceof yn) {
                            var n = arguments[0]
                              , e = this.nodeMap.get(n.getCoordinate());
                            return null === e ? (this.nodeMap.put(n.getCoordinate(), n),
                            n) : (e.mergeLabel(n),
                            e)
                        }
                    },
                    print: function(t) {
                        for (var e = this.iterator(); e.hasNext(); ) {
                            e.next().print(t)
                        }
                    },
                    iterator: function() {
                        return this.nodeMap.values().iterator()
                    },
                    values: function() {
                        return this.nodeMap.values()
                    },
                    getBoundaryNodes: function(t) {
                        for (var e = new I, n = this.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.getLabel().getLocation(t) === S.BOUNDARY && e.add(i)
                        }
                        return e
                    },
                    add: function(t) {
                        var e = t.getCoordinate();
                        this.addNode(e).add(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return vn
                    }
                }),
                e(En.prototype, {
                    compareDirection: function(t) {
                        return this.dx === t.dx && this.dy === t.dy ? 0 : this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : le.computeOrientation(t.p0, t.p1, this.p1)
                    },
                    getDy: function() {
                        return this.dy
                    },
                    getCoordinate: function() {
                        return this.p0
                    },
                    setNode: function(t) {
                        this.node = t
                    },
                    print: function(t) {
                        var e = Math.atan2(this.dy, this.dx)
                          , n = this.getClass().getName()
                          , i = n.lastIndexOf(".")
                          , r = n.substring(i + 1);
                        t.print("  " + r + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + e + "   " + this.label)
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.compareDirection(e)
                    },
                    getDirectedCoordinate: function() {
                        return this.p1
                    },
                    getDx: function() {
                        return this.dx
                    },
                    getLabel: function() {
                        return this.label
                    },
                    getEdge: function() {
                        return this.edge
                    },
                    getQuadrant: function() {
                        return this.quadrant
                    },
                    getNode: function() {
                        return this.node
                    },
                    toString: function() {
                        var t = Math.atan2(this.dy, this.dx)
                          , e = this.getClass().getName()
                          , n = e.lastIndexOf(".");
                        return "  " + e.substring(n + 1) + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + t + "   " + this.label
                    },
                    computeLabel: function(t) {},
                    init: function(t, e) {
                        this.p0 = t,
                        this.p1 = e,
                        this.dx = e.x - t.x,
                        this.dy = e.y - t.y,
                        this.quadrant = Ke.quadrant(this.dx, this.dy),
                        f.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found")
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return En
                    }
                }),
                c(xn, En),
                e(xn.prototype, {
                    getNextMin: function() {
                        return this.nextMin
                    },
                    getDepth: function(t) {
                        return this.depth[t]
                    },
                    setVisited: function(t) {
                        this._isVisited = t
                    },
                    computeDirectedLabel: function() {
                        this.label = new fn(this.edge.getLabel()),
                        this._isForward || this.label.flip()
                    },
                    getNext: function() {
                        return this.next
                    },
                    setDepth: function(t, e) {
                        if (-999 !== this.depth[t] && this.depth[t] !== e)
                            throw new rn("assigned depths do not match",this.getCoordinate());
                        this.depth[t] = e
                    },
                    isInteriorAreaEdge: function() {
                        for (var t = !0, e = 0; e < 2; e++)
                            this.label.isArea(e) && this.label.getLocation(e, cn.LEFT) === S.INTERIOR && this.label.getLocation(e, cn.RIGHT) === S.INTERIOR || (t = !1);
                        return t
                    },
                    setNextMin: function(t) {
                        this.nextMin = t
                    },
                    print: function(t) {
                        En.prototype.print.call(this, t),
                        t.print(" " + this.depth[cn.LEFT] + "/" + this.depth[cn.RIGHT]),
                        t.print(" (" + this.getDepthDelta() + ")"),
                        this._isInResult && t.print(" inResult")
                    },
                    setMinEdgeRing: function(t) {
                        this.minEdgeRing = t
                    },
                    isLineEdge: function() {
                        var t = this.label.isLine(0) || this.label.isLine(1)
                          , e = !this.label.isArea(0) || this.label.allPositionsEqual(0, S.EXTERIOR)
                          , n = !this.label.isArea(1) || this.label.allPositionsEqual(1, S.EXTERIOR);
                        return t && e && n
                    },
                    setEdgeRing: function(t) {
                        this.edgeRing = t
                    },
                    getMinEdgeRing: function() {
                        return this.minEdgeRing
                    },
                    getDepthDelta: function() {
                        var t = this.edge.getDepthDelta();
                        return this._isForward || (t = -t),
                        t
                    },
                    setInResult: function(t) {
                        this._isInResult = t
                    },
                    getSym: function() {
                        return this.sym
                    },
                    isForward: function() {
                        return this._isForward
                    },
                    getEdge: function() {
                        return this.edge
                    },
                    printEdge: function(t) {
                        this.print(t),
                        t.print(" "),
                        this._isForward ? this.edge.print(t) : this.edge.printReverse(t)
                    },
                    setSym: function(t) {
                        this.sym = t
                    },
                    setVisitedEdge: function(t) {
                        this.setVisited(t),
                        this.sym.setVisited(t)
                    },
                    setEdgeDepths: function(t, e) {
                        var n = this.getEdge().getDepthDelta();
                        this._isForward || (n = -n);
                        var i = 1;
                        t === cn.LEFT && (i = -1);
                        var r = cn.opposite(t)
                          , o = n * i
                          , s = e + o;
                        this.setDepth(t, e),
                        this.setDepth(r, s)
                    },
                    getEdgeRing: function() {
                        return this.edgeRing
                    },
                    isInResult: function() {
                        return this._isInResult
                    },
                    setNext: function(t) {
                        this.next = t
                    },
                    isVisited: function() {
                        return this._isVisited
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return xn
                    }
                }),
                xn.depthFactor = function(t, e) {
                    return t === S.EXTERIOR && e === S.INTERIOR ? 1 : t === S.INTERIOR && e === S.EXTERIOR ? -1 : 0
                }
                ,
                e(In.prototype, {
                    createNode: function(t) {
                        return new yn(t,null)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return In
                    }
                }),
                e(Nn.prototype, {
                    printEdges: function(t) {
                        t.println("Edges:");
                        for (var e = 0; e < this.edges.size(); e++) {
                            t.println("edge " + e + ":");
                            var n = this.edges.get(e);
                            n.print(t),
                            n.eiList.print(t)
                        }
                    },
                    find: function(t) {
                        return this.nodes.find(t)
                    },
                    addNode: function() {
                        if (arguments[0]instanceof yn) {
                            var t = arguments[0];
                            return this.nodes.addNode(t)
                        }
                        if (arguments[0]instanceof d) {
                            var e = arguments[0];
                            return this.nodes.addNode(e)
                        }
                    },
                    getNodeIterator: function() {
                        return this.nodes.iterator()
                    },
                    linkResultDirectedEdges: function() {
                        for (var t = this.nodes.iterator(); t.hasNext(); ) {
                            t.next().getEdges().linkResultDirectedEdges()
                        }
                    },
                    debugPrintln: function(t) {
                        D.out.println(t)
                    },
                    isBoundaryNode: function(t, e) {
                        var n = this.nodes.find(e);
                        if (null === n)
                            return !1;
                        var i = n.getLabel();
                        return null !== i && i.getLocation(t) === S.BOUNDARY
                    },
                    linkAllDirectedEdges: function() {
                        for (var t = this.nodes.iterator(); t.hasNext(); ) {
                            t.next().getEdges().linkAllDirectedEdges()
                        }
                    },
                    matchInSameDirection: function(t, e, n, i) {
                        return !!t.equals(n) && le.computeOrientation(t, e, i) === le.COLLINEAR && Ke.quadrant(t, e) === Ke.quadrant(n, i)
                    },
                    getEdgeEnds: function() {
                        return this.edgeEndList
                    },
                    debugPrint: function(t) {
                        D.out.print(t)
                    },
                    getEdgeIterator: function() {
                        return this.edges.iterator()
                    },
                    findEdgeInSameDirection: function(t, e) {
                        for (var n = 0; n < this.edges.size(); n++) {
                            var i = this.edges.get(n)
                              , r = i.getCoordinates();
                            if (this.matchInSameDirection(t, e, r[0], r[1]))
                                return i;
                            if (this.matchInSameDirection(t, e, r[r.length - 1], r[r.length - 2]))
                                return i
                        }
                        return null
                    },
                    insertEdge: function(t) {
                        this.edges.add(t)
                    },
                    findEdgeEnd: function(t) {
                        for (var e = this.getEdgeEnds().iterator(); e.hasNext(); ) {
                            var n = e.next();
                            if (n.getEdge() === t)
                                return n
                        }
                        return null
                    },
                    addEdges: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.edges.add(n);
                            var i = new xn(n,!0)
                              , r = new xn(n,!1);
                            i.setSym(r),
                            r.setSym(i),
                            this.add(i),
                            this.add(r)
                        }
                    },
                    add: function(t) {
                        this.nodes.add(t),
                        this.edgeEndList.add(t)
                    },
                    getNodes: function() {
                        return this.nodes.values()
                    },
                    findEdge: function(t, e) {
                        for (var n = 0; n < this.edges.size(); n++) {
                            var i = this.edges.get(n)
                              , r = i.getCoordinates();
                            if (t.equals(r[0]) && e.equals(r[1]))
                                return i
                        }
                        return null
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Nn
                    }
                }),
                Nn.linkResultDirectedEdges = function(t) {
                    for (var e = t.iterator(); e.hasNext(); ) {
                        e.next().getEdges().linkResultDirectedEdges()
                    }
                }
                ,
                e(Cn.prototype, {
                    sortShellsAndHoles: function(t, e, n) {
                        for (var i = t.iterator(); i.hasNext(); ) {
                            var r = i.next();
                            r.isHole() ? n.add(r) : e.add(r)
                        }
                    },
                    computePolygons: function(t) {
                        for (var e = new I, n = t.iterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = i.toPolygon(this.geometryFactory);
                            e.add(r)
                        }
                        return e
                    },
                    placeFreeHoles: function(t, e) {
                        for (var n = e.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (null === i.getShell()) {
                                var r = this.findEdgeRingContaining(i, t);
                                if (null === r)
                                    throw new rn("unable to assign hole to a shell",i.getCoordinate(0));
                                i.setShell(r)
                            }
                        }
                    },
                    buildMinimalEdgeRings: function(t, e, n) {
                        for (var i = new I, r = t.iterator(); r.hasNext(); ) {
                            var o = r.next();
                            if (o.getMaxNodeDegree() > 2) {
                                o.linkDirectedEdgesForMinimalEdgeRings();
                                var s = o.buildMinimalRings()
                                  , a = this.findShell(s);
                                null !== a ? (this.placePolygonHoles(a, s),
                                e.add(a)) : n.addAll(s)
                            } else
                                i.add(o)
                        }
                        return i
                    },
                    containsPoint: function(t) {
                        for (var e = this.shellList.iterator(); e.hasNext(); ) {
                            if (e.next().containsPoint(t))
                                return !0
                        }
                        return !1
                    },
                    buildMaximalEdgeRings: function(t) {
                        for (var e = new I, n = t.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (i.isInResult() && i.getLabel().isArea() && null === i.getEdgeRing()) {
                                var r = new pn(i,this.geometryFactory);
                                e.add(r),
                                r.setInResult()
                            }
                        }
                        return e
                    },
                    placePolygonHoles: function(t, e) {
                        for (var n = e.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.isHole() && i.setShell(t)
                        }
                    },
                    getPolygons: function() {
                        return this.computePolygons(this.shellList)
                    },
                    findEdgeRingContaining: function(t, e) {
                        for (var n = t.getLinearRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext(); ) {
                            var u = a.next()
                              , l = u.getLinearRing()
                              , c = l.getEnvelopeInternal();
                            null !== o && (s = o.getLinearRing().getEnvelopeInternal());
                            var h = !1;
                            c.contains(i) && le.isPointInRing(r, l.getCoordinates()) && (h = !0),
                            h && (null === o || s.contains(c)) && (o = u)
                        }
                        return o
                    },
                    findShell: function(t) {
                        for (var e = 0, n = null, i = t.iterator(); i.hasNext(); ) {
                            var r = i.next();
                            r.isHole() || (n = r,
                            e++)
                        }
                        return f.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"),
                        n
                    },
                    add: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.add(t.getEdgeEnds(), t.getNodes())
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            Nn.linkResultDirectedEdges(n);
                            var i = this.buildMaximalEdgeRings(e)
                              , r = new I
                              , o = this.buildMinimalEdgeRings(i, this.shellList, r);
                            this.sortShellsAndHoles(o, this.shellList, r),
                            this.placeFreeHoles(this.shellList, r)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Cn
                    }
                }),
                e(wn.prototype, {
                    collectLines: function(t) {
                        for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.collectLineEdge(n, t, this.lineEdgesList),
                            this.collectBoundaryTouchEdge(n, t, this.lineEdgesList)
                        }
                    },
                    labelIsolatedLine: function(t, e) {
                        var n = this.ptLocator.locate(t.getCoordinate(), this.op.getArgGeometry(e));
                        t.getLabel().setLocation(e, n)
                    },
                    build: function(t) {
                        return this.findCoveredLineEdges(),
                        this.collectLines(t),
                        this.buildLines(t),
                        this.resultLineList
                    },
                    collectLineEdge: function(t, e, n) {
                        var i = t.getLabel()
                          , r = t.getEdge();
                        t.isLineEdge() && (t.isVisited() || !ni.isResultOfOp(i, e) || r.isCovered() || (n.add(r),
                        t.setVisitedEdge(!0)))
                    },
                    findCoveredLineEdges: function() {
                        for (var t = this.op.getGraph().getNodes().iterator(); t.hasNext(); ) {
                            t.next().getEdges().findCoveredLineEdges()
                        }
                        for (var e = this.op.getGraph().getEdgeEnds().iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getEdge();
                            if (n.isLineEdge() && !i.isCoveredSet()) {
                                var r = this.op.isCoveredByA(n.getCoordinate());
                                i.setCovered(r)
                            }
                        }
                    },
                    labelIsolatedLines: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getLabel();
                            n.isIsolated() && (i.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1))
                        }
                    },
                    buildLines: function(t) {
                        for (var e = this.lineEdgesList.iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = (n.getLabel(),
                            this.geometryFactory.createLineString(n.getCoordinates()));
                            this.resultLineList.add(i),
                            n.setInResult(!0)
                        }
                    },
                    collectBoundaryTouchEdge: function(t, e, n) {
                        var i = t.getLabel();
                        return t.isLineEdge() ? null : t.isVisited() ? null : t.isInteriorAreaEdge() ? null : t.getEdge().isInResult() ? null : (f.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()),
                        void (ni.isResultOfOp(i, e) && e === ni.INTERSECTION && (n.add(t.getEdge()),
                        t.setVisitedEdge(!0))))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return wn
                    }
                }),
                e(_n.prototype, {
                    filterCoveredNodeToPoint: function(t) {
                        var e = t.getCoordinate();
                        if (!this.op.isCoveredByLA(e)) {
                            var n = this.geometryFactory.createPoint(e);
                            this.resultPointList.add(n)
                        }
                    },
                    extractNonCoveredResultNodes: function(t) {
                        for (var e = this.op.getGraph().getNodes().iterator(); e.hasNext(); ) {
                            var n = e.next();
                            if (!(n.isInResult() || n.isIncidentEdgeInResult() || 0 !== n.getEdges().getDegree() && t !== ni.INTERSECTION)) {
                                var i = n.getLabel();
                                ni.isResultOfOp(i, t) && this.filterCoveredNodeToPoint(n)
                            }
                        }
                    },
                    build: function(t) {
                        return this.extractNonCoveredResultNodes(t),
                        this.resultPointList
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return _n
                    }
                }),
                e(Sn.prototype, {
                    locate: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Sn
                    }
                }),
                e(bn.prototype, {
                    locate: function(t) {
                        return bn.locate(t, this.geom)
                    },
                    interfaces_: function() {
                        return [Sn]
                    },
                    getClass: function() {
                        return bn
                    }
                }),
                bn.isPointInRing = function(t, e) {
                    return !!e.getEnvelopeInternal().intersects(t) && le.isPointInRing(t, e.getCoordinates())
                }
                ,
                bn.containsPointInPolygon = function(t, e) {
                    if (e.isEmpty())
                        return !1;
                    var n = e.getExteriorRing();
                    if (!bn.isPointInRing(t, n))
                        return !1;
                    for (var i = 0; i < e.getNumInteriorRing(); i++) {
                        var r = e.getInteriorRingN(i);
                        if (bn.isPointInRing(t, r))
                            return !1
                    }
                    return !0
                }
                ,
                bn.containsPoint = function(t, e) {
                    if (e instanceof Lt)
                        return bn.containsPointInPolygon(t, e);
                    if (e instanceof ft)
                        for (var n = new Se(e); n.hasNext(); ) {
                            var i = n.next();
                            if (i !== e && bn.containsPoint(t, i))
                                return !0
                        }
                    return !1
                }
                ,
                bn.locate = function(t, e) {
                    return e.isEmpty() ? S.EXTERIOR : bn.containsPoint(t, e) ? S.INTERIOR : S.EXTERIOR
                }
                ,
                e(Ln.prototype, {
                    getNextCW: function(t) {
                        this.getEdges();
                        var e = this.edgeList.indexOf(t)
                          , n = e - 1;
                        return 0 === e && (n = this.edgeList.size() - 1),
                        this.edgeList.get(n)
                    },
                    propagateSideLabels: function(t) {
                        for (var e = S.NONE, n = this.iterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = i.getLabel();
                            r.isArea(t) && r.getLocation(t, cn.LEFT) !== S.NONE && (e = r.getLocation(t, cn.LEFT))
                        }
                        if (e === S.NONE)
                            return null;
                        for (var o = e, n = this.iterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = i.getLabel();
                            if (r.getLocation(t, cn.ON) === S.NONE && r.setLocation(t, cn.ON, o),
                            r.isArea(t)) {
                                var s = r.getLocation(t, cn.LEFT)
                                  , a = r.getLocation(t, cn.RIGHT);
                                if (a !== S.NONE) {
                                    if (a !== o)
                                        throw new rn("side location conflict",i.getCoordinate());
                                    s === S.NONE && f.shouldNeverReachHere("found single null side (at " + i.getCoordinate() + ")"),
                                    o = s
                                } else
                                    f.isTrue(r.getLocation(t, cn.LEFT) === S.NONE, "found single null side"),
                                    r.setLocation(t, cn.RIGHT, o),
                                    r.setLocation(t, cn.LEFT, o)
                            }
                        }
                    },
                    getCoordinate: function() {
                        var t = this.iterator();
                        return t.hasNext() ? t.next().getCoordinate() : null
                    },
                    print: function(t) {
                        D.out.println("EdgeEndStar:   " + this.getCoordinate());
                        for (var e = this.iterator(); e.hasNext(); ) {
                            e.next().print(t)
                        }
                    },
                    isAreaLabelsConsistent: function(t) {
                        return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),
                        this.checkAreaLabelsConsistent(0)
                    },
                    checkAreaLabelsConsistent: function(t) {
                        var e = this.getEdges();
                        if (e.size() <= 0)
                            return !0;
                        var n = e.size() - 1
                          , i = e.get(n).getLabel()
                          , r = i.getLocation(t, cn.LEFT);
                        f.isTrue(r !== S.NONE, "Found unlabelled area edge");
                        for (var o = r, s = this.iterator(); s.hasNext(); ) {
                            var a = s.next()
                              , u = a.getLabel();
                            f.isTrue(u.isArea(t), "Found non-area edge");
                            var l = u.getLocation(t, cn.LEFT)
                              , c = u.getLocation(t, cn.RIGHT);
                            if (l === c)
                                return !1;
                            if (c !== o)
                                return !1;
                            o = l
                        }
                        return !0
                    },
                    findIndex: function(t) {
                        this.iterator();
                        for (var e = 0; e < this.edgeList.size(); e++) {
                            if (this.edgeList.get(e) === t)
                                return e
                        }
                        return -1
                    },
                    iterator: function() {
                        return this.getEdges().iterator()
                    },
                    getEdges: function() {
                        return null === this.edgeList && (this.edgeList = new I(this.edgeMap.values())),
                        this.edgeList
                    },
                    getLocation: function(t, e, n) {
                        return this.ptInAreaLocation[t] === S.NONE && (this.ptInAreaLocation[t] = bn.locate(e, n[t].getGeometry())),
                        this.ptInAreaLocation[t]
                    },
                    toString: function() {
                        var t = new T;
                        t.append("EdgeEndStar:   " + this.getCoordinate()),
                        t.append("\n");
                        for (var e = this.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            t.append(n),
                            t.append("\n")
                        }
                        return t.toString()
                    },
                    computeEdgeEndLabels: function(t) {
                        for (var e = this.iterator(); e.hasNext(); ) {
                            e.next().computeLabel(t)
                        }
                    },
                    computeLabelling: function(t) {
                        this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),
                        this.propagateSideLabels(0),
                        this.propagateSideLabels(1);
                        for (var e = [!1, !1], n = this.iterator(); n.hasNext(); )
                            for (var i = n.next(), r = i.getLabel(), o = 0; o < 2; o++)
                                r.isLine(o) && r.getLocation(o) === S.BOUNDARY && (e[o] = !0);
                        for (var n = this.iterator(); n.hasNext(); )
                            for (var i = n.next(), r = i.getLabel(), o = 0; o < 2; o++)
                                if (r.isAnyNull(o)) {
                                    var s = S.NONE;
                                    if (e[o])
                                        s = S.EXTERIOR;
                                    else {
                                        var a = i.getCoordinate();
                                        s = this.getLocation(o, a, t)
                                    }
                                    r.setAllLocationsIfNull(o, s)
                                }
                    },
                    getDegree: function() {
                        return this.edgeMap.size()
                    },
                    insertEdgeEnd: function(t, e) {
                        this.edgeMap.put(t, e),
                        this.edgeList = null
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ln
                    }
                }),
                c(Tn, Ln),
                e(Tn.prototype, {
                    linkResultDirectedEdges: function() {
                        this.getResultAreaEdges();
                        for (var t = null, e = null, n = this.SCANNING_FOR_INCOMING, i = 0; i < this.resultAreaEdgeList.size(); i++) {
                            var r = this.resultAreaEdgeList.get(i)
                              , o = r.getSym();
                            if (r.getLabel().isArea())
                                switch (null === t && r.isInResult() && (t = r),
                                n) {
                                case this.SCANNING_FOR_INCOMING:
                                    if (!o.isInResult())
                                        continue;
                                    e = o,
                                    n = this.LINKING_TO_OUTGOING;
                                    break;
                                case this.LINKING_TO_OUTGOING:
                                    if (!r.isInResult())
                                        continue;
                                    e.setNext(r),
                                    n = this.SCANNING_FOR_INCOMING
                                }
                        }
                        if (n === this.LINKING_TO_OUTGOING) {
                            if (null === t)
                                throw new rn("no outgoing dirEdge found",this.getCoordinate());
                            f.isTrue(t.isInResult(), "unable to link last incoming dirEdge"),
                            e.setNext(t)
                        }
                    },
                    insert: function(t) {
                        var e = t;
                        this.insertEdgeEnd(e, e)
                    },
                    getRightmostEdge: function() {
                        var t = this.getEdges()
                          , e = t.size();
                        if (e < 1)
                            return null;
                        var n = t.get(0);
                        if (1 === e)
                            return n;
                        var i = t.get(e - 1)
                          , r = n.getQuadrant()
                          , o = i.getQuadrant();
                        return Ke.isNorthern(r) && Ke.isNorthern(o) ? n : Ke.isNorthern(r) || Ke.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== i.getDy() ? i : (f.shouldNeverReachHere("found two horizontal edges incident on node"),
                        null) : i
                    },
                    print: function(t) {
                        D.out.println("DirectedEdgeStar: " + this.getCoordinate());
                        for (var e = this.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            t.print("out "),
                            n.print(t),
                            t.println(),
                            t.print("in "),
                            n.getSym().print(t),
                            t.println()
                        }
                    },
                    getResultAreaEdges: function() {
                        if (null !== this.resultAreaEdgeList)
                            return this.resultAreaEdgeList;
                        this.resultAreaEdgeList = new I;
                        for (var t = this.iterator(); t.hasNext(); ) {
                            var e = t.next();
                            (e.isInResult() || e.getSym().isInResult()) && this.resultAreaEdgeList.add(e)
                        }
                        return this.resultAreaEdgeList
                    },
                    updateLabelling: function(t) {
                        for (var e = this.iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getLabel();
                            i.setAllLocationsIfNull(0, t.getLocation(0)),
                            i.setAllLocationsIfNull(1, t.getLocation(1))
                        }
                    },
                    linkAllDirectedEdges: function() {
                        this.getEdges();
                        for (var t = null, e = null, n = this.edgeList.size() - 1; n >= 0; n--) {
                            var i = this.edgeList.get(n)
                              , r = i.getSym();
                            null === e && (e = r),
                            null !== t && r.setNext(t),
                            t = i
                        }
                        e.setNext(t)
                    },
                    computeDepths: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = this.findIndex(t)
                              , n = (t.getLabel(),
                            t.getDepth(cn.LEFT))
                              , i = t.getDepth(cn.RIGHT)
                              , r = this.computeDepths(e + 1, this.edgeList.size(), n);
                            if (this.computeDepths(0, e, r) !== i)
                                throw new rn("depth mismatch at " + t.getCoordinate())
                        } else if (3 === arguments.length) {
                            for (var o = arguments[0], s = arguments[1], a = arguments[2], u = a, l = o; l < s; l++) {
                                var c = this.edgeList.get(l);
                                c.getLabel(),
                                c.setEdgeDepths(cn.RIGHT, u),
                                u = c.getDepth(cn.LEFT)
                            }
                            return u
                        }
                    },
                    mergeSymLabels: function() {
                        for (var t = this.iterator(); t.hasNext(); ) {
                            var e = t.next();
                            e.getLabel().merge(e.getSym().getLabel())
                        }
                    },
                    linkMinimalDirectedEdges: function(t) {
                        for (var e = null, n = null, i = this.SCANNING_FOR_INCOMING, r = this.resultAreaEdgeList.size() - 1; r >= 0; r--) {
                            var o = this.resultAreaEdgeList.get(r)
                              , s = o.getSym();
                            switch (null === e && o.getEdgeRing() === t && (e = o),
                            i) {
                            case this.SCANNING_FOR_INCOMING:
                                if (s.getEdgeRing() !== t)
                                    continue;
                                n = s,
                                i = this.LINKING_TO_OUTGOING;
                                break;
                            case this.LINKING_TO_OUTGOING:
                                if (o.getEdgeRing() !== t)
                                    continue;
                                n.setNextMin(o),
                                i = this.SCANNING_FOR_INCOMING
                            }
                        }
                        i === this.LINKING_TO_OUTGOING && (f.isTrue(null !== e, "found null for first outgoing dirEdge"),
                        f.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"),
                        n.setNextMin(e))
                    },
                    getOutgoingDegree: function() {
                        if (0 === arguments.length) {
                            for (var t = 0, e = this.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                n.isInResult() && t++
                            }
                            return t
                        }
                        if (1 === arguments.length) {
                            for (var i = arguments[0], t = 0, e = this.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                n.getEdgeRing() === i && t++
                            }
                            return t
                        }
                    },
                    getLabel: function() {
                        return this.label
                    },
                    findCoveredLineEdges: function() {
                        for (var t = S.NONE, e = this.iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getSym();
                            if (!n.isLineEdge()) {
                                if (n.isInResult()) {
                                    t = S.INTERIOR;
                                    break
                                }
                                if (i.isInResult()) {
                                    t = S.EXTERIOR;
                                    break
                                }
                            }
                        }
                        if (t === S.NONE)
                            return null;
                        for (var r = t, e = this.iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getSym();
                            n.isLineEdge() ? n.getEdge().setCovered(r === S.INTERIOR) : (n.isInResult() && (r = S.EXTERIOR),
                            i.isInResult() && (r = S.INTERIOR))
                        }
                    },
                    computeLabelling: function(t) {
                        Ln.prototype.computeLabelling.call(this, t),
                        this.label = new fn(S.NONE);
                        for (var e = this.iterator(); e.hasNext(); )
                            for (var n = e.next(), i = n.getEdge(), r = i.getLabel(), o = 0; o < 2; o++) {
                                var s = r.getLocation(o);
                                s !== S.INTERIOR && s !== S.BOUNDARY || this.label.setLocation(o, S.INTERIOR)
                            }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Tn
                    }
                }),
                c(Rn, In),
                e(Rn.prototype, {
                    createNode: function(t) {
                        return new yn(t,new Tn)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Rn
                    }
                }),
                e(On.prototype, {
                    computeIntersections: function(t, e) {
                        this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return On
                    }
                }),
                e(Pn.prototype, {
                    isDelete: function() {
                        return this.eventType === Pn.DELETE
                    },
                    setDeleteEventIndex: function(t) {
                        this.deleteEventIndex = t
                    },
                    getObject: function() {
                        return this.obj
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.xValue < e.xValue ? -1 : this.xValue > e.xValue ? 1 : this.eventType < e.eventType ? -1 : this.eventType > e.eventType ? 1 : 0
                    },
                    getInsertEvent: function() {
                        return this.insertEvent
                    },
                    isInsert: function() {
                        return this.eventType === Pn.INSERT
                    },
                    isSameLabel: function(t) {
                        return null !== this.label && this.label === t.label
                    },
                    getDeleteEventIndex: function() {
                        return this.deleteEventIndex
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return Pn
                    }
                }),
                Pn.INSERT = 1,
                Pn.DELETE = 2,
                e(Mn.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Mn
                    }
                }),
                e(An.prototype, {
                    isTrivialIntersection: function(t, e, n, i) {
                        if (t === n && 1 === this.li.getIntersectionNum()) {
                            if (An.isAdjacentSegments(e, i))
                                return !0;
                            if (t.isClosed()) {
                                var r = t.getNumPoints() - 1;
                                if (0 === e && i === r || 0 === i && e === r)
                                    return !0
                            }
                        }
                        return !1
                    },
                    getProperIntersectionPoint: function() {
                        return this.properIntersectionPoint
                    },
                    setIsDoneIfProperInt: function(t) {
                        this.isDoneWhenProperInt = t
                    },
                    hasProperInteriorIntersection: function() {
                        return this.hasProperInterior
                    },
                    isBoundaryPointInternal: function(t, e) {
                        for (var n = e.iterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = i.getCoordinate();
                            if (t.isIntersection(r))
                                return !0
                        }
                        return !1
                    },
                    hasProperIntersection: function() {
                        return this.hasProper
                    },
                    hasIntersection: function() {
                        return this._hasIntersection
                    },
                    isDone: function() {
                        return this._isDone
                    },
                    isBoundaryPoint: function(t, e) {
                        return !(null === e || !this.isBoundaryPointInternal(t, e[0]) && !this.isBoundaryPointInternal(t, e[1]))
                    },
                    setBoundaryNodes: function(t, e) {
                        this.bdyNodes = new Array(2).fill(null),
                        this.bdyNodes[0] = t,
                        this.bdyNodes[1] = e
                    },
                    addIntersections: function(t, e, n, i) {
                        if (t === n && e === i)
                            return null;
                        this.numTests++;
                        var r = t.getCoordinates()[e]
                          , o = t.getCoordinates()[e + 1]
                          , s = n.getCoordinates()[i]
                          , a = n.getCoordinates()[i + 1];
                        this.li.computeIntersection(r, o, s, a),
                        this.li.hasIntersection() && (this.recordIsolated && (t.setIsolated(!1),
                        n.setIsolated(!1)),
                        this.numIntersections++,
                        this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0,
                        !this.includeProper && this.li.isProper() || (t.addIntersections(this.li, e, 0),
                        n.addIntersections(this.li, i, 1)),
                        this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(),
                        this.hasProper = !0,
                        this.isDoneWhenProperInt && (this._isDone = !0),
                        this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return An
                    }
                }),
                An.isAdjacentSegments = function(t, e) {
                    return 1 === Math.abs(t - e)
                }
                ,
                c(Dn, Mn),
                e(Dn.prototype, {
                    prepareEvents: function() {
                        ls.sort(this.events);
                        for (var t = 0; t < this.events.size(); t++) {
                            var e = this.events.get(t);
                            e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
                        }
                    },
                    computeIntersections: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            this.nOverlaps = 0,
                            this.prepareEvents();
                            for (var e = 0; e < this.events.size(); e++) {
                                var n = this.events.get(e);
                                if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t),
                                t.isDone())
                                    break
                            }
                        } else if (3 === arguments.length)
                            if (arguments[2]instanceof An && b(arguments[0], v) && b(arguments[1], v)) {
                                var i = arguments[0]
                                  , r = arguments[1]
                                  , o = arguments[2];
                                this.addEdges(i, i),
                                this.addEdges(r, r),
                                this.computeIntersections(o)
                            } else if ("boolean" == typeof arguments[2] && b(arguments[0], v) && arguments[1]instanceof An) {
                                var s = arguments[0]
                                  , a = arguments[1]
                                  , u = arguments[2];
                                u ? this.addEdges(s, null) : this.addEdges(s),
                                this.computeIntersections(a)
                            }
                    },
                    addEdge: function(t, e) {
                        for (var n = t.getMonotoneChainEdge(), i = n.getStartIndexes(), r = 0; r < i.length - 1; r++) {
                            var o = new On(n,r)
                              , s = new Pn(e,n.getMinX(r),o);
                            this.events.add(s),
                            this.events.add(new Pn(n.getMaxX(r),s))
                        }
                    },
                    processOverlaps: function(t, e, n, i) {
                        for (var r = n.getObject(), o = t; o < e; o++) {
                            var s = this.events.get(o);
                            if (s.isInsert()) {
                                var a = s.getObject();
                                n.isSameLabel(s) || (r.computeIntersections(a, i),
                                this.nOverlaps++)
                            }
                        }
                    },
                    addEdges: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = t.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.addEdge(n, n)
                            }
                        else if (2 === arguments.length)
                            for (var i = arguments[0], r = arguments[1], e = i.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.addEdge(n, r)
                            }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Dn
                    }
                }),
                e(Fn.prototype, {
                    getMin: function() {
                        return this.min
                    },
                    intersects: function(t, e) {
                        return !(this.min > e || this.max < t)
                    },
                    getMax: function() {
                        return this.max
                    },
                    toString: function() {
                        return re.toLineString(new d(this.min,0), new d(this.max,0))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Fn
                    }
                }),
                e(Gn.prototype, {
                    compare: function(t, e) {
                        var n = t
                          , i = e
                          , r = (n.min + n.max) / 2
                          , o = (i.min + i.max) / 2;
                        return r < o ? -1 : r > o ? 1 : 0
                    },
                    interfaces_: function() {
                        return [a]
                    },
                    getClass: function() {
                        return Gn
                    }
                }),
                Fn.NodeComparator = Gn,
                c(kn, Fn),
                e(kn.prototype, {
                    query: function(t, e, n) {
                        return this.intersects(t, e) ? void n.visitItem(this.item) : null
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return kn
                    }
                }),
                c(qn, Fn),
                e(qn.prototype, {
                    buildExtent: function(t, e) {
                        this.min = Math.min(t.min, e.min),
                        this.max = Math.max(t.max, e.max)
                    },
                    query: function(t, e, n) {
                        return this.intersects(t, e) ? (null !== this.node1 && this.node1.query(t, e, n),
                        void (null !== this.node2 && this.node2.query(t, e, n))) : null
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return qn
                    }
                }),
                e(Bn.prototype, {
                    buildTree: function() {
                        ls.sort(this.leaves, new IntervalRTreeNode.NodeComparator);
                        for (var t = this.leaves, e = null, n = new I; ; ) {
                            if (this.buildLevel(t, n),
                            1 === n.size())
                                return n.get(0);
                            e = t,
                            t = n,
                            n = e
                        }
                    },
                    insert: function(t, e, n) {
                        if (null !== this.root)
                            throw new IllegalStateException("Index cannot be added to once it has been queried");
                        this.leaves.add(new kn(t,e,n))
                    },
                    query: function(t, e, n) {
                        this.init(),
                        this.root.query(t, e, n)
                    },
                    buildRoot: function() {
                        return null !== this.root ? null : void (this.root = this.buildTree())
                    },
                    printNode: function(t) {
                        D.out.println(re.toLineString(new d(t.min,this.level), new d(t.max,this.level)))
                    },
                    init: function() {
                        return null !== this.root ? null : void this.buildRoot()
                    },
                    buildLevel: function(t, e) {
                        this.level++,
                        e.clear();
                        for (var n = 0; n < t.size(); n += 2) {
                            var i = t.get(n);
                            if (null === (n + 1 < t.size() ? t.get(n) : null))
                                e.add(i);
                            else {
                                var r = new qn(t.get(n),t.get(n + 1));
                                e.add(r)
                            }
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Bn
                    }
                }),
                e(Un.prototype, {
                    filter: function(t) {
                        if (this.isForcedToLineString && t instanceof Rt) {
                            var e = t.getFactory().createLineString(t.getCoordinateSequence());
                            return this.lines.add(e),
                            null
                        }
                        t instanceof wt && this.lines.add(t)
                    },
                    setForceToLineString: function(t) {
                        this.isForcedToLineString = t
                    },
                    interfaces_: function() {
                        return [k]
                    },
                    getClass: function() {
                        return Un
                    }
                }),
                Un.getGeometry = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return t.getFactory().buildGeometry(Un.getLines(t))
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        return e.getFactory().buildGeometry(Un.getLines(e, n))
                    }
                }
                ,
                Un.getLines = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Un.getLines(t, !1)
                    }
                    if (2 === arguments.length) {
                        if (b(arguments[0], m) && b(arguments[1], m)) {
                            for (var e = arguments[0], n = arguments[1], i = e.iterator(); i.hasNext(); ) {
                                var r = i.next();
                                Un.getLines(r, n)
                            }
                            return n
                        }
                        if (arguments[0]instanceof q && "boolean" == typeof arguments[1]) {
                            var o = arguments[0]
                              , s = arguments[1]
                              , a = new I;
                            return o.apply(new Un(a,s)),
                            a
                        }
                        if (arguments[0]instanceof q && b(arguments[1], m)) {
                            var u = arguments[0]
                              , l = arguments[1];
                            return u instanceof wt ? l.add(u) : u.apply(new Un(l)),
                            l
                        }
                    } else if (3 === arguments.length) {
                        if ("boolean" == typeof arguments[2] && b(arguments[0], m) && b(arguments[1], m)) {
                            for (var c = arguments[0], h = arguments[1], f = arguments[2], i = c.iterator(); i.hasNext(); ) {
                                var r = i.next();
                                Un.getLines(r, h, f)
                            }
                            return h
                        }
                        if ("boolean" == typeof arguments[2] && arguments[0]instanceof q && b(arguments[1], m)) {
                            var d = arguments[0]
                              , g = arguments[1]
                              , p = arguments[2];
                            return d.apply(new Un(g,p)),
                            g
                        }
                    }
                }
                ,
                e(Vn.prototype, {
                    visitItem: function(t) {
                        this.items.add(t)
                    },
                    getItems: function() {
                        return this.items
                    },
                    interfaces_: function() {
                        return [Ae]
                    },
                    getClass: function() {
                        return Vn
                    }
                }),
                e(zn.prototype, {
                    locate: function(t) {
                        var e = new ue(t)
                          , n = new jn(e);
                        return this.index.query(t.y, t.y, n),
                        e.getLocation()
                    },
                    interfaces_: function() {
                        return [Sn]
                    },
                    getClass: function() {
                        return zn
                    }
                }),
                e(jn.prototype, {
                    visitItem: function(t) {
                        var e = t;
                        this.counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
                    },
                    interfaces_: function() {
                        return [Ae]
                    },
                    getClass: function() {
                        return jn
                    }
                }),
                e(Yn.prototype, {
                    init: function(t) {
                        for (var e = Un.getLines(t), n = e.iterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = i.getCoordinates();
                            this.addLine(r)
                        }
                    },
                    addLine: function(t) {
                        for (var e = 1; e < t.length; e++) {
                            var n = new ce(t[e - 1],t[e])
                              , i = Math.min(n.p0.y, n.p1.y)
                              , r = Math.max(n.p0.y, n.p1.y);
                            this.index.insert(i, r, n)
                        }
                    },
                    query: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1]
                              , n = new Vn;
                            return this.index.query(t, e, n),
                            n.getItems()
                        }
                        if (3 === arguments.length) {
                            var i = arguments[0]
                              , r = arguments[1]
                              , o = arguments[2];
                            this.index.query(i, r, o)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Yn
                    }
                }),
                zn.SegmentVisitor = jn,
                zn.IntervalIndexedGeometry = Yn,
                e(Xn.prototype, {
                    getSegmentIndex: function() {
                        return this.segmentIndex
                    },
                    getCoordinate: function() {
                        return this.coord
                    },
                    print: function(t) {
                        t.print(this.coord),
                        t.print(" seg # = " + this.segmentIndex),
                        t.println(" dist = " + this.dist)
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.compare(e.segmentIndex, e.dist)
                    },
                    isEndPoint: function(t) {
                        return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t
                    },
                    toString: function() {
                        return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
                    },
                    getDistance: function() {
                        return this.dist
                    },
                    compare: function(t, e) {
                        return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return Xn
                    }
                }),
                e(Hn.prototype, {
                    print: function(t) {
                        t.println("Intersections:");
                        for (var e = this.iterator(); e.hasNext(); ) {
                            e.next().print(t)
                        }
                    },
                    iterator: function() {
                        return this.nodeMap.values().iterator()
                    },
                    addSplitEdges: function(t) {
                        this.addEndpoints();
                        for (var e = this.iterator(), n = e.next(); e.hasNext(); ) {
                            var i = e.next()
                              , r = this.createSplitEdge(n, i);
                            t.add(r),
                            n = i
                        }
                    },
                    addEndpoints: function() {
                        var t = this.edge.pts.length - 1;
                        this.add(this.edge.pts[0], 0, 0),
                        this.add(this.edge.pts[t], t, 0)
                    },
                    createSplitEdge: function(t, e) {
                        var n = e.segmentIndex - t.segmentIndex + 2
                          , i = this.edge.pts[e.segmentIndex]
                          , r = e.dist > 0 || !e.coord.equals2D(i);
                        r || n--;
                        var o = new Array(n).fill(null)
                          , s = 0;
                        o[s++] = new d(t.coord);
                        for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++)
                            o[s++] = this.edge.pts[a];
                        return r && (o[s] = e.coord),
                        new Kn(o,new fn(this.edge.label))
                    },
                    add: function(t, e, n) {
                        var i = new Xn(t,e,n)
                          , r = this.nodeMap.get(i);
                        return null !== r ? r : (this.nodeMap.put(i, i),
                        i)
                    },
                    isIntersection: function(t) {
                        for (var e = this.iterator(); e.hasNext(); ) {
                            if (e.next().coord.equals(t))
                                return !0
                        }
                        return !1
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Hn
                    }
                }),
                e(Wn.prototype, {
                    getChainStartIndices: function(t) {
                        var e = 0
                          , n = new I;
                        n.add(new R(e));
                        do {
                            var i = this.findChainEnd(t, e);
                            n.add(new R(i)),
                            e = i
                        } while (e < t.length - 1);return Wn.toIntArray(n)
                    },
                    findChainEnd: function(t, e) {
                        for (var n = Ke.quadrant(t[e], t[e + 1]), i = e + 1; i < t.length; ) {
                            if (Ke.quadrant(t[i - 1], t[i]) !== n)
                                break;
                            i++
                        }
                        return i - 1
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Wn
                    }
                }),
                Wn.toIntArray = function(t) {
                    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)
                        e[n] = t.get(n).intValue();
                    return e
                }
                ,
                e(Jn.prototype, {
                    getCoordinates: function() {
                        return this.pts
                    },
                    getMaxX: function(t) {
                        var e = this.pts[this.startIndex[t]].x
                          , n = this.pts[this.startIndex[t + 1]].x;
                        return e > n ? e : n
                    },
                    getMinX: function(t) {
                        var e = this.pts[this.startIndex[t]].x
                          , n = this.pts[this.startIndex[t + 1]].x;
                        return e < n ? e : n
                    },
                    computeIntersectsForChain: function() {
                        if (4 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1]
                              , n = arguments[2]
                              , i = arguments[3];
                            this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], i)
                        } else if (6 === arguments.length) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = arguments[2]
                              , a = arguments[3]
                              , u = arguments[4]
                              , l = arguments[5]
                              , c = this.pts[r]
                              , h = this.pts[o]
                              , f = s.pts[a]
                              , d = s.pts[u];
                            if (o - r == 1 && u - a == 1)
                                return l.addIntersections(this.e, r, s.e, a),
                                null;
                            if (this.env1.init(c, h),
                            this.env2.init(f, d),
                            !this.env1.intersects(this.env2))
                                return null;
                            var g = Math.trunc((r + o) / 2)
                              , p = Math.trunc((a + u) / 2);
                            r < g && (a < p && this.computeIntersectsForChain(r, g, s, a, p, l),
                            p < u && this.computeIntersectsForChain(r, g, s, p, u, l)),
                            g < o && (a < p && this.computeIntersectsForChain(g, o, s, a, p, l),
                            p < u && this.computeIntersectsForChain(g, o, s, p, u, l))
                        }
                    },
                    getStartIndexes: function() {
                        return this.startIndex
                    },
                    computeIntersects: function(t, e) {
                        for (var n = 0; n < this.startIndex.length - 1; n++)
                            for (var i = 0; i < t.startIndex.length - 1; i++)
                                this.computeIntersectsForChain(n, t, i, e)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Jn
                    }
                }),
                e($n.prototype, {
                    getDepth: function(t, e) {
                        return this.depth[t][e]
                    },
                    setDepth: function(t, e, n) {
                        this.depth[t][e] = n
                    },
                    isNull: function() {
                        if (0 === arguments.length) {
                            for (var t = 0; t < 2; t++)
                                for (var e = 0; e < 3; e++)
                                    if (this.depth[t][e] !== $n.NULL_VALUE)
                                        return !1;
                            return !0
                        }
                        if (1 === arguments.length) {
                            var n = arguments[0];
                            return this.depth[n][1] === $n.NULL_VALUE
                        }
                        if (2 === arguments.length) {
                            var i = arguments[0]
                              , r = arguments[1];
                            return this.depth[i][r] === $n.NULL_VALUE
                        }
                    },
                    normalize: function() {
                        for (var t = 0; t < 2; t++)
                            if (!this.isNull(t)) {
                                var e = this.depth[t][1];
                                this.depth[t][2] < e && (e = this.depth[t][2]),
                                e < 0 && (e = 0);
                                for (var n = 1; n < 3; n++) {
                                    var i = 0;
                                    this.depth[t][n] > e && (i = 1),
                                    this.depth[t][n] = i
                                }
                            }
                    },
                    getDelta: function(t) {
                        return this.depth[t][cn.RIGHT] - this.depth[t][cn.LEFT]
                    },
                    getLocation: function(t, e) {
                        return this.depth[t][e] <= 0 ? S.EXTERIOR : S.INTERIOR
                    },
                    toString: function() {
                        return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2]
                    },
                    add: function() {
                        if (1 === arguments.length)
                            for (var t = arguments[0], e = 0; e < 2; e++)
                                for (var n = 1; n < 3; n++) {
                                    var i = t.getLocation(e, n);
                                    i !== S.EXTERIOR && i !== S.INTERIOR || (this.isNull(e, n) ? this.depth[e][n] = $n.depthAtLocation(i) : this.depth[e][n] += $n.depthAtLocation(i))
                                }
                        else if (3 === arguments.length) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = arguments[2];
                            s === S.INTERIOR && this.depth[r][o]++
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return $n
                    }
                }),
                $n.depthAtLocation = function(t) {
                    return t === S.EXTERIOR ? 0 : t === S.INTERIOR ? 1 : $n.NULL_VALUE
                }
                ,
                $n.NULL_VALUE = -1,
                c(Kn, mn),
                e(Kn.prototype, {
                    getDepth: function() {
                        return this.depth
                    },
                    getCollapsedEdge: function() {
                        var t = new Array(2).fill(null);
                        return t[0] = this.pts[0],
                        t[1] = this.pts[1],
                        new Kn(t,fn.toLineLabel(this.label))
                    },
                    isIsolated: function() {
                        return this._isIsolated
                    },
                    getCoordinates: function() {
                        return this.pts
                    },
                    setIsolated: function(t) {
                        this._isIsolated = t
                    },
                    setName: function(t) {
                        this.name = t
                    },
                    equals: function(t) {
                        if (!(t instanceof Kn))
                            return !1;
                        var e = t;
                        if (this.pts.length !== e.pts.length)
                            return !1;
                        for (var n = !0, i = !0, r = this.pts.length, o = 0; o < this.pts.length; o++)
                            if (this.pts[o].equals2D(e.pts[o]) || (n = !1),
                            this.pts[o].equals2D(e.pts[--r]) || (i = !1),
                            !n && !i)
                                return !1;
                        return !0
                    },
                    getCoordinate: function() {
                        if (0 === arguments.length)
                            return this.pts.length > 0 ? this.pts[0] : null;
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.pts[t]
                        }
                    },
                    print: function(t) {
                        t.print("edge " + this.name + ": "),
                        t.print("LINESTRING (");
                        for (var e = 0; e < this.pts.length; e++)
                            e > 0 && t.print(","),
                            t.print(this.pts[e].x + " " + this.pts[e].y);
                        t.print(")  " + this.label + " " + this.depthDelta)
                    },
                    computeIM: function(t) {
                        Kn.updateIM(this.label, t)
                    },
                    isCollapsed: function() {
                        return !!this.label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2])
                    },
                    isClosed: function() {
                        return this.pts[0].equals(this.pts[this.pts.length - 1])
                    },
                    getMaximumSegmentIndex: function() {
                        return this.pts.length - 1
                    },
                    getDepthDelta: function() {
                        return this.depthDelta
                    },
                    getNumPoints: function() {
                        return this.pts.length
                    },
                    printReverse: function(t) {
                        t.print("edge " + this.name + ": ");
                        for (var e = this.pts.length - 1; e >= 0; e--)
                            t.print(this.pts[e] + " ");
                        t.println("")
                    },
                    getMonotoneChainEdge: function() {
                        return null === this.mce && (this.mce = new Jn(this)),
                        this.mce
                    },
                    getEnvelope: function() {
                        if (null === this.env) {
                            this.env = new C;
                            for (var t = 0; t < this.pts.length; t++)
                                this.env.expandToInclude(this.pts[t])
                        }
                        return this.env
                    },
                    addIntersection: function(t, e, n, i) {
                        var r = new d(t.getIntersection(i))
                          , o = e
                          , s = t.getEdgeDistance(n, i)
                          , a = o + 1;
                        if (a < this.pts.length) {
                            var u = this.pts[a];
                            r.equals2D(u) && (o = a,
                            s = 0)
                        }
                        this.eiList.add(r, o, s)
                    },
                    toString: function() {
                        var t = new T;
                        t.append("edge " + this.name + ": "),
                        t.append("LINESTRING (");
                        for (var e = 0; e < this.pts.length; e++)
                            e > 0 && t.append(","),
                            t.append(this.pts[e].x + " " + this.pts[e].y);
                        return t.append(")  " + this.label + " " + this.depthDelta),
                        t.toString()
                    },
                    isPointwiseEqual: function(t) {
                        if (this.pts.length !== t.pts.length)
                            return !1;
                        for (var e = 0; e < this.pts.length; e++)
                            if (!this.pts[e].equals2D(t.pts[e]))
                                return !1;
                        return !0
                    },
                    setDepthDelta: function(t) {
                        this.depthDelta = t
                    },
                    getEdgeIntersectionList: function() {
                        return this.eiList
                    },
                    addIntersections: function(t, e, n) {
                        for (var i = 0; i < t.getIntersectionNum(); i++)
                            this.addIntersection(t, e, n, i)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Kn
                    }
                }),
                Kn.updateIM = function() {
                    if (2 !== arguments.length)
                        return mn.prototype.updateIM.apply(this, arguments);
                    var t = arguments[0]
                      , e = arguments[1];
                    e.setAtLeastIfValid(t.getLocation(0, cn.ON), t.getLocation(1, cn.ON), 1),
                    t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, cn.LEFT), t.getLocation(1, cn.LEFT), 2),
                    e.setAtLeastIfValid(t.getLocation(0, cn.RIGHT), t.getLocation(1, cn.RIGHT), 2))
                }
                ,
                c(Zn, Nn),
                e(Zn.prototype, {
                    insertBoundaryPoint: function(t, e) {
                        var n = this.nodes.addNode(e)
                          , i = n.getLabel()
                          , r = 1;
                        S.NONE;
                        i.getLocation(t, cn.ON) === S.BOUNDARY && r++;
                        var o = Zn.determineBoundary(this.boundaryNodeRule, r);
                        i.setLocation(t, o)
                    },
                    computeSelfNodes: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return this.computeSelfNodes(t, e, !1)
                        }
                        if (3 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = arguments[2]
                              , o = new An(n,!0,!1);
                            o.setIsDoneIfProperInt(r);
                            var s = this.createEdgeSetIntersector()
                              , a = this.parentGeom instanceof Rt || this.parentGeom instanceof Lt || this.parentGeom instanceof Ot
                              , u = i || !a;
                            return s.computeIntersections(this.edges, o, u),
                            this.addSelfIntersectionNodes(this.argIndex),
                            o
                        }
                    },
                    computeSplitEdges: function(t) {
                        for (var e = this.edges.iterator(); e.hasNext(); ) {
                            e.next().eiList.addSplitEdges(t)
                        }
                    },
                    computeEdgeIntersections: function(t, e, n) {
                        var i = new An(e,n,!0);
                        return i.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()),
                        this.createEdgeSetIntersector().computeIntersections(this.edges, t.edges, i),
                        i
                    },
                    getGeometry: function() {
                        return this.parentGeom
                    },
                    getBoundaryNodeRule: function() {
                        return this.boundaryNodeRule
                    },
                    hasTooFewPoints: function() {
                        return this._hasTooFewPoints
                    },
                    addPoint: function() {
                        if (arguments[0]instanceof St) {
                            var t = arguments[0]
                              , e = t.getCoordinate();
                            this.insertPoint(this.argIndex, e, S.INTERIOR)
                        } else if (arguments[0]instanceof d) {
                            var n = arguments[0];
                            this.insertPoint(this.argIndex, n, S.INTERIOR)
                        }
                    },
                    addPolygon: function(t) {
                        this.addPolygonRing(t.getExteriorRing(), S.EXTERIOR, S.INTERIOR);
                        for (var e = 0; e < t.getNumInteriorRing(); e++) {
                            var n = t.getInteriorRingN(e);
                            this.addPolygonRing(n, S.INTERIOR, S.EXTERIOR)
                        }
                    },
                    addEdge: function(t) {
                        this.insertEdge(t);
                        var e = t.getCoordinates();
                        this.insertPoint(this.argIndex, e[0], S.BOUNDARY),
                        this.insertPoint(this.argIndex, e[e.length - 1], S.BOUNDARY)
                    },
                    addLineString: function(t) {
                        var e = X.removeRepeatedPoints(t.getCoordinates());
                        if (e.length < 2)
                            return this._hasTooFewPoints = !0,
                            this.invalidPoint = e[0],
                            null;
                        var n = new Kn(e,new fn(this.argIndex,S.INTERIOR));
                        this.lineEdgeMap.put(t, n),
                        this.insertEdge(n),
                        f.isTrue(e.length >= 2, "found LineString with single point"),
                        this.insertBoundaryPoint(this.argIndex, e[0]),
                        this.insertBoundaryPoint(this.argIndex, e[e.length - 1])
                    },
                    getInvalidPoint: function() {
                        return this.invalidPoint
                    },
                    getBoundaryPoints: function() {
                        for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, i = t.iterator(); i.hasNext(); ) {
                            var r = i.next();
                            e[n++] = r.getCoordinate().copy()
                        }
                        return e
                    },
                    getBoundaryNodes: function() {
                        return null === this.boundaryNodes && (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)),
                        this.boundaryNodes
                    },
                    addSelfIntersectionNode: function(t, e, n) {
                        return this.isBoundaryNode(t, e) ? null : void (n === S.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n))
                    },
                    addPolygonRing: function(t, e, n) {
                        if (t.isEmpty())
                            return null;
                        var i = X.removeRepeatedPoints(t.getCoordinates());
                        if (i.length < 4)
                            return this._hasTooFewPoints = !0,
                            this.invalidPoint = i[0],
                            null;
                        var r = e
                          , o = n;
                        le.isCCW(i) && (r = n,
                        o = e);
                        var s = new Kn(i,new fn(this.argIndex,S.BOUNDARY,r,o));
                        this.lineEdgeMap.put(t, s),
                        this.insertEdge(s),
                        this.insertPoint(this.argIndex, i[0], S.BOUNDARY)
                    },
                    insertPoint: function(t, e, n) {
                        var i = this.nodes.addNode(e)
                          , r = i.getLabel();
                        null === r ? i.label = new fn(t,n) : r.setLocation(t, n)
                    },
                    createEdgeSetIntersector: function() {
                        return new Dn
                    },
                    addSelfIntersectionNodes: function(t) {
                        for (var e = this.edges.iterator(); e.hasNext(); )
                            for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.eiList.iterator(); r.hasNext(); ) {
                                var o = r.next();
                                this.addSelfIntersectionNode(t, o.coord, i)
                            }
                    },
                    add: function() {
                        if (1 !== arguments.length)
                            return Nn.prototype.add.apply(this, arguments);
                        var t = arguments[0];
                        if (t.isEmpty())
                            return null;
                        if (t instanceof Ot && (this.useBoundaryDeterminationRule = !1),
                        t instanceof Lt)
                            this.addPolygon(t);
                        else if (t instanceof wt)
                            this.addLineString(t);
                        else if (t instanceof St)
                            this.addPoint(t);
                        else if (t instanceof Tt)
                            this.addCollection(t);
                        else if (t instanceof dt)
                            this.addCollection(t);
                        else if (t instanceof Ot)
                            this.addCollection(t);
                        else {
                            if (!(t instanceof ft))
                                throw new UnsupportedOperationException(t.getClass().getName());
                            this.addCollection(t)
                        }
                    },
                    addCollection: function(t) {
                        for (var e = 0; e < t.getNumGeometries(); e++) {
                            var n = t.getGeometryN(e);
                            this.add(n)
                        }
                    },
                    locate: function(t) {
                        return b(this.parentGeom, bt) && this.parentGeom.getNumGeometries() > 50 ? (null === this.areaPtLocator && (this.areaPtLocator = new zn(this.parentGeom)),
                        this.areaPtLocator.locate(t)) : this.ptLocator.locate(t, this.parentGeom)
                    },
                    findEdge: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.lineEdgeMap.get(t)
                        }
                        return Nn.prototype.findEdge.apply(this, arguments)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Zn
                    }
                }),
                Zn.determineBoundary = function(t, e) {
                    return t.isInBoundary(e) ? S.BOUNDARY : S.INTERIOR
                }
                ,
                e(Qn.prototype, {
                    getArgGeometry: function(t) {
                        return this.arg[t].getGeometry()
                    },
                    setComputationPrecision: function(t) {
                        this.resultPrecisionModel = t,
                        this.li.setPrecisionModel(this.resultPrecisionModel)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Qn
                    }
                }),
                e(ti.prototype, {
                    compareTo: function(t) {
                        var e = t;
                        return ti.compareOriented(this.pts, this._orientation, e.pts, e._orientation)
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return ti
                    }
                }),
                ti.orientation = function(t) {
                    return 1 === X.increasingDirection(t)
                }
                ,
                ti.compareOriented = function(t, e, n, i) {
                    for (var r = e ? 1 : -1, o = i ? 1 : -1, s = e ? t.length : -1, a = i ? n.length : -1, u = e ? 0 : t.length - 1, l = i ? 0 : n.length - 1; ; ) {
                        var c = t[u].compareTo(n[l]);
                        if (0 !== c)
                            return c;
                        u += r,
                        l += o;
                        var h = u === s
                          , f = l === a;
                        if (h && !f)
                            return -1;
                        if (!h && f)
                            return 1;
                        if (h && f)
                            return 0
                    }
                }
                ,
                e(ei.prototype, {
                    print: function(t) {
                        t.print("MULTILINESTRING ( ");
                        for (var e = 0; e < this.edges.size(); e++) {
                            var n = this.edges.get(e);
                            e > 0 && t.print(","),
                            t.print("(");
                            for (var i = n.getCoordinates(), r = 0; r < i.length; r++)
                                r > 0 && t.print(","),
                                t.print(i[r].x + " " + i[r].y);
                            t.println(")")
                        }
                        t.print(")  ")
                    },
                    addAll: function(t) {
                        for (var e = t.iterator(); e.hasNext(); )
                            this.add(e.next())
                    },
                    findEdgeIndex: function(t) {
                        for (var e = 0; e < this.edges.size(); e++)
                            if (this.edges.get(e).equals(t))
                                return e;
                        return -1
                    },
                    iterator: function() {
                        return this.edges.iterator()
                    },
                    getEdges: function() {
                        return this.edges
                    },
                    get: function(t) {
                        return this.edges.get(t)
                    },
                    findEqualEdge: function(t) {
                        var e = new ti(t.getCoordinates());
                        return this.ocaMap.get(e)
                    },
                    add: function(t) {
                        this.edges.add(t);
                        var e = new ti(t.getCoordinates());
                        this.ocaMap.put(e, t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ei
                    }
                }),
                c(ni, Qn),
                e(ni.prototype, {
                    insertUniqueEdge: function(t) {
                        var e = this.edgeList.findEqualEdge(t);
                        if (null !== e) {
                            var n = e.getLabel()
                              , i = t.getLabel();
                            e.isPointwiseEqual(t) || (i = new fn(t.getLabel()),
                            i.flip());
                            var r = e.getDepth();
                            r.isNull() && r.add(n),
                            r.add(i),
                            n.merge(i)
                        } else
                            this.edgeList.add(t)
                    },
                    getGraph: function() {
                        return this.graph
                    },
                    cancelDuplicateResultEdges: function() {
                        for (var t = this.graph.getEdgeEnds().iterator(); t.hasNext(); ) {
                            var e = t.next()
                              , n = e.getSym();
                            e.isInResult() && n.isInResult() && (e.setInResult(!1),
                            n.setInResult(!1))
                        }
                    },
                    isCoveredByLA: function(t) {
                        return !!this.isCovered(t, this.resultLineList) || !!this.isCovered(t, this.resultPolyList)
                    },
                    computeGeometry: function(t, e, n, i) {
                        var r = new I;
                        return r.addAll(t),
                        r.addAll(e),
                        r.addAll(n),
                        r.isEmpty() ? ni.createEmptyResult(i, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(r)
                    },
                    mergeSymLabels: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext(); ) {
                            t.next().getEdges().mergeSymLabels()
                        }
                    },
                    isCovered: function(t, e) {
                        for (var n = e.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (this.ptLocator.locate(t, i) !== S.EXTERIOR)
                                return !0
                        }
                        return !1
                    },
                    replaceCollapsedEdges: function() {
                        for (var t = new I, e = this.edgeList.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            n.isCollapsed() && (e.remove(),
                            t.add(n.getCollapsedEdge()))
                        }
                        this.edgeList.addAll(t)
                    },
                    updateNodeLabelling: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext(); ) {
                            var e = t.next()
                              , n = e.getEdges().getLabel();
                            e.getLabel().merge(n)
                        }
                    },
                    getResultGeometry: function(t) {
                        return this.computeOverlay(t),
                        this.resultGeom
                    },
                    insertUniqueEdges: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.insertUniqueEdge(n)
                        }
                    },
                    computeOverlay: function(t) {
                        this.copyPoints(0),
                        this.copyPoints(1),
                        this.arg[0].computeSelfNodes(this.li, !1),
                        this.arg[1].computeSelfNodes(this.li, !1),
                        this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);
                        var e = new I;
                        this.arg[0].computeSplitEdges(e),
                        this.arg[1].computeSplitEdges(e),
                        this.insertUniqueEdges(e),
                        this.computeLabelsFromDepths(),
                        this.replaceCollapsedEdges(),
                        un.checkValid(this.edgeList.getEdges()),
                        this.graph.addEdges(this.edgeList.getEdges()),
                        this.computeLabelling(),
                        this.labelIncompleteNodes(),
                        this.findResultAreaEdges(t),
                        this.cancelDuplicateResultEdges();
                        var n = new Cn(this.geomFact);
                        n.add(this.graph),
                        this.resultPolyList = n.getPolygons();
                        var i = new wn(this,this.geomFact,this.ptLocator);
                        this.resultLineList = i.build(t);
                        var r = new _n(this,this.geomFact,this.ptLocator);
                        this.resultPointList = r.build(t),
                        this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, t)
                    },
                    labelIncompleteNode: function(t, e) {
                        var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
                        t.getLabel().setLocation(e, n)
                    },
                    copyPoints: function(t) {
                        for (var e = this.arg[t].getNodeIterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
                        }
                    },
                    findResultAreaEdges: function(t) {
                        for (var e = this.graph.getEdgeEnds().iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getLabel();
                            i.isArea() && !n.isInteriorAreaEdge() && ni.isResultOfOp(i.getLocation(0, cn.RIGHT), i.getLocation(1, cn.RIGHT), t) && n.setInResult(!0)
                        }
                    },
                    computeLabelsFromDepths: function() {
                        for (var t = this.edgeList.iterator(); t.hasNext(); ) {
                            var e = t.next()
                              , n = e.getLabel()
                              , i = e.getDepth();
                            if (!i.isNull()) {
                                i.normalize();
                                for (var r = 0; r < 2; r++)
                                    n.isNull(r) || !n.isArea() || i.isNull(r) || (0 === i.getDelta(r) ? n.toLine(r) : (f.isTrue(!i.isNull(r, cn.LEFT), "depth of LEFT side has not been initialized"),
                                    n.setLocation(r, cn.LEFT, i.getLocation(r, cn.LEFT)),
                                    f.isTrue(!i.isNull(r, cn.RIGHT), "depth of RIGHT side has not been initialized"),
                                    n.setLocation(r, cn.RIGHT, i.getLocation(r, cn.RIGHT))))
                            }
                        }
                    },
                    computeLabelling: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext(); ) {
                            t.next().getEdges().computeLabelling(this.arg)
                        }
                        this.mergeSymLabels(),
                        this.updateNodeLabelling()
                    },
                    labelIncompleteNodes: function() {
                        for (var t = 0, e = this.graph.getNodes().iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getLabel();
                            n.isIsolated() && (t++,
                            i.isNull(0) ? this.labelIncompleteNode(n, 0) : this.labelIncompleteNode(n, 1)),
                            n.getEdges().updateLabelling(i)
                        }
                    },
                    isCoveredByA: function(t) {
                        return !!this.isCovered(t, this.resultPolyList)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ni
                    }
                }),
                ni.overlayOp = function(t, e, n) {
                    return new ni(t,e).getResultGeometry(n)
                }
                ,
                ni.intersection = function(t, e) {
                    if (t.isEmpty() || e.isEmpty())
                        return ni.createEmptyResult(ni.INTERSECTION, t, e, t.getFactory());
                    if (t.isGeometryCollection()) {
                        var n = e;
                        return ln.map(t, {
                            interfaces_: function() {
                                return [MapOp]
                            },
                            map: function(t) {
                                return t.intersection(n)
                            }
                        })
                    }
                    return t.checkNotGeometryCollection(t),
                    t.checkNotGeometryCollection(e),
                    ri.overlayOp(t, e, ni.INTERSECTION)
                }
                ,
                ni.symDifference = function(t, e) {
                    if (t.isEmpty() || e.isEmpty()) {
                        if (t.isEmpty() && e.isEmpty())
                            return ni.createEmptyResult(ni.SYMDIFFERENCE, t, e, t.getFactory());
                        if (t.isEmpty())
                            return e.copy();
                        if (e.isEmpty())
                            return t.copy()
                    }
                    return t.checkNotGeometryCollection(t),
                    t.checkNotGeometryCollection(e),
                    ri.overlayOp(t, e, ni.SYMDIFFERENCE)
                }
                ,
                ni.resultDimension = function(t, e, n) {
                    var i = e.getDimension()
                      , r = n.getDimension()
                      , o = -1;
                    switch (t) {
                    case ni.INTERSECTION:
                        o = Math.min(i, r);
                        break;
                    case ni.UNION:
                        o = Math.max(i, r);
                        break;
                    case ni.DIFFERENCE:
                        o = i;
                        break;
                    case ni.SYMDIFFERENCE:
                        o = Math.max(i, r)
                    }
                    return o
                }
                ,
                ni.createEmptyResult = function(t, e, n, i) {
                    var r = null;
                    switch (ni.resultDimension(t, e, n)) {
                    case -1:
                        r = i.createGeometryCollection(new Array(0).fill(null));
                        break;
                    case 0:
                        r = i.createPoint();
                        break;
                    case 1:
                        r = i.createLineString();
                        break;
                    case 2:
                        r = i.createPolygon()
                    }
                    return r
                }
                ,
                ni.difference = function(t, e) {
                    return t.isEmpty() ? ni.createEmptyResult(ni.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t),
                    t.checkNotGeometryCollection(e),
                    ri.overlayOp(t, e, ni.DIFFERENCE))
                }
                ,
                ni.isResultOfOp = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = t.getLocation(0)
                          , i = t.getLocation(1);
                        return ni.isResultOfOp(n, i, e)
                    }
                    if (3 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2];
                        switch (r === S.BOUNDARY && (r = S.INTERIOR),
                        o === S.BOUNDARY && (o = S.INTERIOR),
                        s) {
                        case ni.INTERSECTION:
                            return r === S.INTERIOR && o === S.INTERIOR;
                        case ni.UNION:
                            return r === S.INTERIOR || o === S.INTERIOR;
                        case ni.DIFFERENCE:
                            return r === S.INTERIOR && o !== S.INTERIOR;
                        case ni.SYMDIFFERENCE:
                            return r === S.INTERIOR && o !== S.INTERIOR || r !== S.INTERIOR && o === S.INTERIOR
                        }
                        return !1
                    }
                }
                ,
                ni.INTERSECTION = 1,
                ni.UNION = 2,
                ni.DIFFERENCE = 3,
                ni.SYMDIFFERENCE = 4,
                e(ii.prototype, {
                    selfSnap: function(t) {
                        return new xe(t).snapTo(t, this.snapTolerance)
                    },
                    removeCommonBits: function(t) {
                        this.cbr = new Ce,
                        this.cbr.add(t[0]),
                        this.cbr.add(t[1]);
                        var e = new Array(2).fill(null);
                        return e[0] = this.cbr.removeCommonBits(t[0].copy()),
                        e[1] = this.cbr.removeCommonBits(t[1].copy()),
                        e
                    },
                    prepareResult: function(t) {
                        return this.cbr.addCommonBits(t),
                        t
                    },
                    getResultGeometry: function(t) {
                        var e = this.snap(this.geom)
                          , n = ni.overlayOp(e[0], e[1], t);
                        return this.prepareResult(n)
                    },
                    checkValid: function(t) {
                        t.isValid() || D.out.println("Snapped geometry is invalid")
                    },
                    computeSnapTolerance: function() {
                        this.snapTolerance = xe.computeOverlaySnapTolerance(this.geom[0], this.geom[1])
                    },
                    snap: function(t) {
                        var e = this.removeCommonBits(t);
                        return xe.snap(e[0], e[1], this.snapTolerance)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ii
                    }
                }),
                ii.overlayOp = function(t, e, n) {
                    return new ii(t,e).getResultGeometry(n)
                }
                ,
                ii.union = function(t, e) {
                    return ii.overlayOp(t, e, ni.UNION)
                }
                ,
                ii.intersection = function(t, e) {
                    return ii.overlayOp(t, e, ni.INTERSECTION)
                }
                ,
                ii.symDifference = function(t, e) {
                    return ii.overlayOp(t, e, ni.SYMDIFFERENCE)
                }
                ,
                ii.difference = function(t, e) {
                    return ii.overlayOp(t, e, ni.DIFFERENCE)
                }
                ,
                e(ri.prototype, {
                    getResultGeometry: function(t) {
                        var e = null
                          , n = !1
                          , i = null;
                        try {
                            e = ni.overlayOp(this.geom[0], this.geom[1], t);
                            n = !0
                        } catch (t) {
                            if (!(t instanceof l))
                                throw t;
                            i = t
                        }
                        if (!n)
                            try {
                                e = ii.overlayOp(this.geom[0], this.geom[1], t)
                            } catch (t) {
                                throw t instanceof l ? i : t
                            }
                        return e
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ri
                    }
                }),
                ri.overlayOp = function(t, e, n) {
                    return new ri(t,e).getResultGeometry(n)
                }
                ,
                ri.union = function(t, e) {
                    return ri.overlayOp(t, e, ni.UNION)
                }
                ,
                ri.intersection = function(t, e) {
                    return ri.overlayOp(t, e, ni.INTERSECTION)
                }
                ,
                ri.symDifference = function(t, e) {
                    return ri.overlayOp(t, e, ni.SYMDIFFERENCE)
                }
                ,
                ri.difference = function(t, e) {
                    return ri.overlayOp(t, e, ni.DIFFERENCE)
                }
                ,
                e(oi.prototype, {
                    addPolygon: function(t) {
                        if (t.isEmpty())
                            return null;
                        var e = null
                          , n = 0
                          , i = this.horizontalBisector(t);
                        if (0 === i.getLength())
                            n = 0,
                            e = i.getCoordinate();
                        else {
                            var r = ri.overlayOp(i, t, ni.INTERSECTION)
                              , o = this.widestGeometry(r);
                            n = o.getEnvelopeInternal().getWidth(),
                            e = oi.centre(o.getEnvelopeInternal())
                        }
                        (null === this.interiorPoint || n > this.maxWidth) && (this.interiorPoint = e,
                        this.maxWidth = n)
                    },
                    getInteriorPoint: function() {
                        return this.interiorPoint
                    },
                    widestGeometry: function() {
                        if (arguments[0]instanceof ft) {
                            var t = arguments[0];
                            if (t.isEmpty())
                                return t;
                            for (var e = t.getGeometryN(0), n = 1; n < t.getNumGeometries(); n++)
                                t.getGeometryN(n).getEnvelopeInternal().getWidth() > e.getEnvelopeInternal().getWidth() && (e = t.getGeometryN(n));
                            return e
                        }
                        if (arguments[0]instanceof q) {
                            var i = arguments[0];
                            return i instanceof ft ? this.widestGeometry(i) : i
                        }
                    },
                    horizontalBisector: function(t) {
                        var e = t.getEnvelopeInternal()
                          , n = si.getBisectorY(t);
                        return this.factory.createLineString([new d(e.getMinX(),n), new d(e.getMaxX(),n)])
                    },
                    add: function(t) {
                        if (t instanceof Lt)
                            this.addPolygon(t);
                        else if (t instanceof ft)
                            for (var e = t, n = 0; n < e.getNumGeometries(); n++)
                                this.add(e.getGeometryN(n))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return oi
                    }
                }),
                oi.centre = function(t) {
                    return new d(oi.avg(t.getMinX(), t.getMaxX()),oi.avg(t.getMinY(), t.getMaxY()))
                }
                ,
                oi.avg = function(t, e) {
                    return (t + e) / 2
                }
                ,
                e(si.prototype, {
                    updateInterval: function(t) {
                        t <= this.centreY ? t > this.loY && (this.loY = t) : t > this.centreY && t < this.hiY && (this.hiY = t)
                    },
                    getBisectorY: function() {
                        this.process(this.poly.getExteriorRing());
                        for (var t = 0; t < this.poly.getNumInteriorRing(); t++)
                            this.process(this.poly.getInteriorRingN(t));
                        return oi.avg(this.hiY, this.loY)
                    },
                    process: function(t) {
                        for (var e = t.getCoordinateSequence(), n = 0; n < e.size(); n++) {
                            var i = e.getY(n);
                            this.updateInterval(i)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return si
                    }
                }),
                si.getBisectorY = function(t) {
                    return new si(t).getBisectorY()
                }
                ,
                oi.SafeBisectorFinder = si,
                e(ai.prototype, {
                    addEndpoints: function() {
                        if (arguments[0]instanceof q) {
                            var t = arguments[0];
                            if (t instanceof wt)
                                this.addEndpoints(t.getCoordinates());
                            else if (t instanceof ft)
                                for (var e = t, n = 0; n < e.getNumGeometries(); n++)
                                    this.addEndpoints(e.getGeometryN(n))
                        } else if (arguments[0]instanceof Array) {
                            var i = arguments[0];
                            this.add(i[0]),
                            this.add(i[i.length - 1])
                        }
                    },
                    getInteriorPoint: function() {
                        return this.interiorPoint
                    },
                    addInterior: function() {
                        if (arguments[0]instanceof q) {
                            var t = arguments[0];
                            if (t instanceof wt)
                                this.addInterior(t.getCoordinates());
                            else if (t instanceof ft)
                                for (var e = t, n = 0; n < e.getNumGeometries(); n++)
                                    this.addInterior(e.getGeometryN(n))
                        } else if (arguments[0]instanceof Array)
                            for (var i = arguments[0], n = 1; n < i.length - 1; n++)
                                this.add(i[n])
                    },
                    add: function(t) {
                        var e = t.distance(this.centroid);
                        e < this.minDistance && (this.interiorPoint = new d(t),
                        this.minDistance = e)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ai
                    }
                }),
                e(ui.prototype, {
                    getInteriorPoint: function() {
                        return this.interiorPoint
                    },
                    add: function() {
                        if (arguments[0]instanceof q) {
                            var t = arguments[0];
                            if (t instanceof St)
                                this.add(t.getCoordinate());
                            else if (t instanceof ft)
                                for (var e = t, n = 0; n < e.getNumGeometries(); n++)
                                    this.add(e.getGeometryN(n))
                        } else if (arguments[0]instanceof d) {
                            var i = arguments[0]
                              , r = i.distance(this.centroid);
                            r < this.minDistance && (this.interiorPoint = new d(i),
                            this.minDistance = r)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ui
                    }
                }),
                e(li.prototype, {
                    select: function() {
                        if (1 === arguments.length)
                            arguments[0];
                        else if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            t.getLineSegment(e, this.selectedSegment),
                            this.select(this.selectedSegment)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return li
                    }
                }),
                e(ci.prototype, {
                    hasChildren: function() {
                        for (var t = 0; t < 2; t++)
                            if (null !== this.subnode[t])
                                return !0;
                        return !1
                    },
                    isPrunable: function() {
                        return !(this.hasChildren() || this.hasItems())
                    },
                    addAllItems: function(t) {
                        t.addAll(this.items);
                        for (var e = 0; e < 2; e++)
                            null !== this.subnode[e] && this.subnode[e].addAllItems(t);
                        return t
                    },
                    size: function() {
                        for (var t = 0, e = 0; e < 2; e++)
                            null !== this.subnode[e] && (t += this.subnode[e].size());
                        return t + this.items.size()
                    },
                    addAllItemsFromOverlapping: function(t, e) {
                        return null === t || this.isSearchMatch(t) ? (e.addAll(this.items),
                        null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(t, e),
                        void (null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(t, e))) : null
                    },
                    hasItems: function() {
                        return !this.items.isEmpty()
                    },
                    remove: function(t, e) {
                        if (!this.isSearchMatch(t))
                            return !1;
                        for (var n = !1, i = 0; i < 2; i++)
                            if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
                                this.subnode[i].isPrunable() && (this.subnode[i] = null);
                                break
                            }
                        return n || (n = this.items.remove(e))
                    },
                    getItems: function() {
                        return this.items
                    },
                    depth: function() {
                        for (var t = 0, e = 0; e < 2; e++)
                            if (null !== this.subnode[e]) {
                                var n = this.subnode[e].depth();
                                n > t && (t = n)
                            }
                        return t + 1
                    },
                    nodeSize: function() {
                        for (var t = 0, e = 0; e < 2; e++)
                            null !== this.subnode[e] && (t += this.subnode[e].nodeSize());
                        return t + 1
                    },
                    add: function(t) {
                        this.items.add(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ci
                    }
                }),
                ci.getSubnodeIndex = function(t, e) {
                    var n = -1;
                    return t.min >= e && (n = 1),
                    t.max <= e && (n = 0),
                    n
                }
                ,
                e(hi.prototype, {
                    expandToInclude: function(t) {
                        t.max > this.max && (this.max = t.max),
                        t.min < this.min && (this.min = t.min)
                    },
                    getWidth: function() {
                        return this.max - this.min
                    },
                    overlaps: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.overlaps(t.min, t.max)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            return !(this.min > n || this.max < e)
                        }
                    },
                    getMin: function() {
                        return this.min
                    },
                    toString: function() {
                        return "[" + this.min + ", " + this.max + "]"
                    },
                    contains: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof hi) {
                                var t = arguments[0];
                                return this.contains(t.min, t.max)
                            }
                            if ("number" == typeof arguments[0]) {
                                var e = arguments[0];
                                return e >= this.min && e <= this.max
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            return n >= this.min && i <= this.max
                        }
                    },
                    init: function(t, e) {
                        this.min = t,
                        this.max = e,
                        t > e && (this.min = e,
                        this.max = t)
                    },
                    getMax: function() {
                        return this.max
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return hi
                    }
                }),
                fi.exponent = function(t) {
                    return di(64, t) - 1023
                }
                ,
                fi.powerOf2 = function(t) {
                    return Math.pow(2, t)
                }
                ,
                e(gi.prototype, {
                    getInterval: function() {
                        return this.interval
                    },
                    getLevel: function() {
                        return this.level
                    },
                    computeKey: function(t) {
                        for (this.level = gi.computeLevel(t),
                        this.interval = new hi,
                        this.computeInterval(this.level, t); !this.interval.contains(t); )
                            this.level += 1,
                            this.computeInterval(this.level, t)
                    },
                    computeInterval: function(t, e) {
                        var n = fi.powerOf2(t);
                        this.pt = Math.floor(e.getMin() / n) * n,
                        this.interval.init(this.pt, this.pt + n)
                    },
                    getPoint: function() {
                        return this.pt
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return gi
                    }
                }),
                gi.computeLevel = function(t) {
                    var e = t.getWidth();
                    return fi.exponent(e) + 1
                }
                ,
                c(pi, ci),
                e(pi.prototype, {
                    getInterval: function() {
                        return this.interval
                    },
                    find: function(t) {
                        var e = ci.getSubnodeIndex(t, this.centre);
                        if (-1 === e)
                            return this;
                        if (null !== this.subnode[e]) {
                            return this.subnode[e].find(t)
                        }
                        return this
                    },
                    insert: function(t) {
                        f.isTrue(null === this.interval || this.interval.contains(t.interval));
                        var e = ci.getSubnodeIndex(t.interval, this.centre);
                        if (t.level === this.level - 1)
                            this.subnode[e] = t;
                        else {
                            var n = this.createSubnode(e);
                            n.insert(t),
                            this.subnode[e] = n
                        }
                    },
                    isSearchMatch: function(t) {
                        return t.overlaps(this.interval)
                    },
                    getSubnode: function(t) {
                        return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)),
                        this.subnode[t]
                    },
                    getNode: function(t) {
                        var e = ci.getSubnodeIndex(t, this.centre);
                        if (-1 !== e) {
                            return this.getSubnode(e).getNode(t)
                        }
                        return this
                    },
                    createSubnode: function(t) {
                        var e = 0
                          , n = 0;
                        switch (t) {
                        case 0:
                            e = this.interval.getMin(),
                            n = this.centre;
                            break;
                        case 1:
                            e = this.centre,
                            n = this.interval.getMax()
                        }
                        return new pi(new hi(e,n),this.level - 1)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return pi
                    }
                }),
                pi.createNode = function(t) {
                    var e = new gi(t);
                    return new pi(e.getInterval(),e.getLevel())
                }
                ,
                pi.createExpanded = function(t, e) {
                    var n = new hi(e);
                    null !== t && n.expandToInclude(t.interval);
                    var i = pi.createNode(n);
                    return null !== t && i.insert(t),
                    i
                }
                ,
                e(mi.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return mi
                    }
                });
                mi.isZeroWidth = function(t, e) {
                    var n = e - t;
                    if (0 === n)
                        return !0;
                    var i = Math.max(Math.abs(t), Math.abs(e))
                      , r = n / i;
                    return fi.exponent(r) <= mi.MIN_BINARY_EXPONENT
                }
                ,
                mi.MIN_BINARY_EXPONENT = -50,
                c(yi, ci),
                e(yi.prototype, {
                    insert: function(t, e) {
                        var n = ci.getSubnodeIndex(t, yi.origin);
                        if (-1 === n)
                            return this.add(e),
                            null;
                        var i = this.subnode[n];
                        if (null === i || !i.getInterval().contains(t)) {
                            var r = pi.createExpanded(i, t);
                            this.subnode[n] = r
                        }
                        this.insertContained(this.subnode[n], t, e)
                    },
                    isSearchMatch: function(t) {
                        return !0
                    },
                    insertContained: function(t, e, n) {
                        f.isTrue(t.getInterval().contains(e));
                        var i = mi.isZeroWidth(e.getMin(), e.getMax())
                          , r = null;
                        r = i ? t.find(e) : t.getNode(e),
                        r.add(n)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return yi
                    }
                }),
                yi.origin = 0,
                e(vi.prototype, {
                    size: function() {
                        return null !== this.root ? this.root.size() : 0
                    },
                    insert: function(t, e) {
                        this.collectStats(t);
                        var n = vi.ensureExtent(t, this.minExtent);
                        this.root.insert(n, e)
                    },
                    query: function() {
                        if (1 === arguments.length) {
                            if ("number" == typeof arguments[0]) {
                                var t = arguments[0];
                                return this.query(new hi(t,t))
                            }
                            if (arguments[0]instanceof hi) {
                                var e = arguments[0]
                                  , n = new I;
                                return this.query(e, n),
                                n
                            }
                        } else if (2 === arguments.length) {
                            var i = arguments[0]
                              , r = arguments[1];
                            this.root.addAllItemsFromOverlapping(i, r)
                        }
                    },
                    iterator: function() {
                        var t = new I;
                        return this.root.addAllItems(t),
                        t.iterator()
                    },
                    remove: function(t, e) {
                        var n = vi.ensureExtent(t, this.minExtent);
                        return this.root.remove(n, e)
                    },
                    collectStats: function(t) {
                        var e = t.getWidth();
                        e < this.minExtent && e > 0 && (this.minExtent = e)
                    },
                    depth: function() {
                        return null !== this.root ? this.root.depth() : 0
                    },
                    nodeSize: function() {
                        return null !== this.root ? this.root.nodeSize() : 0
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return vi
                    }
                }),
                vi.ensureExtent = function(t, e) {
                    var n = t.getMin()
                      , i = t.getMax();
                    return n !== i ? t : (n === i && (n -= e / 2,
                    i = n + e / 2),
                    new hi(n,i))
                }
                ,
                e(Ei.prototype, {
                    isInside: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ei
                    }
                }),
                e(xi.prototype, {
                    testLineSegment: function(t, e) {
                        var n = null
                          , i = null
                          , r = null
                          , o = null
                          , s = e.p0
                          , a = e.p1;
                        n = s.x - t.x,
                        i = s.y - t.y,
                        r = a.x - t.x,
                        o = a.y - t.y,
                        (i > 0 && o <= 0 || o > 0 && i <= 0) && 0 < ae.signOfDet2x2(n, i, r, o) / (o - i) && this.crossings++
                    },
                    buildIndex: function() {
                        this.tree = new vi;
                        for (var t = X.removeRepeatedPoints(this.ring.getCoordinates()), e = Ze.getChains(t), n = 0; n < e.size(); n++) {
                            var i = e.get(n)
                              , r = i.getEnvelope();
                            this.interval.min = r.getMinY(),
                            this.interval.max = r.getMaxY(),
                            this.tree.insert(this.interval, i)
                        }
                    },
                    testMonotoneChain: function(t, e, n) {
                        n.select(t, e)
                    },
                    isInside: function(t) {
                        this.crossings = 0;
                        var e = new C(r.NEGATIVE_INFINITY,r.POSITIVE_INFINITY,t.y,t.y);
                        this.interval.min = t.y,
                        this.interval.max = t.y;
                        for (var n = this.tree.query(this.interval), i = new Ii(this,t), o = n.iterator(); o.hasNext(); ) {
                            var s = o.next();
                            this.testMonotoneChain(e, i, s)
                        }
                        return this.crossings % 2 == 1
                    },
                    interfaces_: function() {
                        return [Ei]
                    },
                    getClass: function() {
                        return xi
                    }
                }),
                c(Ii, li),
                e(Ii.prototype, {
                    select: function() {
                        if (1 !== arguments.length)
                            return li.prototype.select.apply(this, arguments);
                        var t = arguments[0];
                        this.mcp.testLineSegment(this.p, t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ii
                    }
                }),
                xi.MCSelecter = Ii,
                e(Ni.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ni
                    }
                }),
                Ni.toDegrees = function(t) {
                    return 180 * t / Math.PI
                }
                ,
                Ni.normalize = function(t) {
                    for (; t > Math.PI; )
                        t -= Ni.PI_TIMES_2;
                    for (; t <= -Math.PI; )
                        t += Ni.PI_TIMES_2;
                    return t
                }
                ,
                Ni.angle = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return Math.atan2(t.y, t.x)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1]
                          , i = n.x - e.x
                          , r = n.y - e.y;
                        return Math.atan2(r, i)
                    }
                }
                ,
                Ni.isAcute = function(t, e, n) {
                    var i = t.x - e.x
                      , r = t.y - e.y;
                    return i * (n.x - e.x) + r * (n.y - e.y) > 0
                }
                ,
                Ni.isObtuse = function(t, e, n) {
                    var i = t.x - e.x
                      , r = t.y - e.y;
                    return i * (n.x - e.x) + r * (n.y - e.y) < 0
                }
                ,
                Ni.interiorAngle = function(t, e, n) {
                    var i = Ni.angle(e, t)
                      , r = Ni.angle(e, n);
                    return Math.abs(r - i)
                }
                ,
                Ni.normalizePositive = function(t) {
                    if (t < 0) {
                        for (; t < 0; )
                            t += Ni.PI_TIMES_2;
                        t >= Ni.PI_TIMES_2 && (t = 0)
                    } else {
                        for (; t >= Ni.PI_TIMES_2; )
                            t -= Ni.PI_TIMES_2;
                        t < 0 && (t = 0)
                    }
                    return t
                }
                ,
                Ni.angleBetween = function(t, e, n) {
                    var i = Ni.angle(e, t)
                      , r = Ni.angle(e, n);
                    return Ni.diff(i, r)
                }
                ,
                Ni.diff = function(t, e) {
                    var n = null;
                    return n = t < e ? e - t : t - e,
                    n > Math.PI && (n = 2 * Math.PI - n),
                    n
                }
                ,
                Ni.toRadians = function(t) {
                    return t * Math.PI / 180
                }
                ,
                Ni.getTurn = function(t, e) {
                    var n = Math.sin(e - t);
                    return n > 0 ? Ni.COUNTERCLOCKWISE : n < 0 ? Ni.CLOCKWISE : Ni.NONE
                }
                ,
                Ni.angleBetweenOriented = function(t, e, n) {
                    var i = Ni.angle(e, t)
                      , r = Ni.angle(e, n)
                      , o = r - i;
                    return o <= -Math.PI ? o + Ni.PI_TIMES_2 : o > Math.PI ? o - Ni.PI_TIMES_2 : o
                }
                ,
                Ni.PI_TIMES_2 = 2 * Math.PI,
                Ni.PI_OVER_2 = Math.PI / 2,
                Ni.PI_OVER_4 = Math.PI / 4,
                Ni.COUNTERCLOCKWISE = le.COUNTERCLOCKWISE,
                Ni.CLOCKWISE = le.CLOCKWISE,
                Ni.NONE = le.COLLINEAR,
                e(Ci.prototype, {
                    area: function() {
                        return Ci.area(this.p0, this.p1, this.p2)
                    },
                    signedArea: function() {
                        return Ci.signedArea(this.p0, this.p1, this.p2)
                    },
                    interpolateZ: function(t) {
                        if (null === t)
                            throw new i("Supplied point is null.");
                        return Ci.interpolateZ(t, this.p0, this.p1, this.p2)
                    },
                    longestSideLength: function() {
                        return Ci.longestSideLength(this.p0, this.p1, this.p2)
                    },
                    isAcute: function() {
                        return Ci.isAcute(this.p0, this.p1, this.p2)
                    },
                    circumcentre: function() {
                        return Ci.circumcentre(this.p0, this.p1, this.p2)
                    },
                    area3D: function() {
                        return Ci.area3D(this.p0, this.p1, this.p2)
                    },
                    centroid: function() {
                        return Ci.centroid(this.p0, this.p1, this.p2)
                    },
                    inCentre: function() {
                        return Ci.inCentre(this.p0, this.p1, this.p2)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ci
                    }
                }),
                Ci.area = function(t, e, n) {
                    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
                }
                ,
                Ci.signedArea = function(t, e, n) {
                    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
                }
                ,
                Ci.det = function(t, e, n, i) {
                    return t * i - e * n
                }
                ,
                Ci.interpolateZ = function(t, e, n, i) {
                    var r = e.x
                      , o = e.y
                      , s = n.x - r
                      , a = i.x - r
                      , u = n.y - o
                      , l = i.y - o
                      , c = s * l - a * u
                      , h = t.x - r
                      , f = t.y - o
                      , d = (l * h - a * f) / c
                      , g = (-u * h + s * f) / c;
                    return e.z + d * (n.z - e.z) + g * (i.z - e.z)
                }
                ,
                Ci.longestSideLength = function(t, e, n) {
                    var i = t.distance(e)
                      , r = e.distance(n)
                      , o = n.distance(t)
                      , s = i;
                    return r > s && (s = r),
                    o > s && (s = o),
                    s
                }
                ,
                Ci.isAcute = function(t, e, n) {
                    return !!Ni.isAcute(t, e, n) && !!Ni.isAcute(e, n, t) && !!Ni.isAcute(n, t, e)
                }
                ,
                Ci.circumcentre = function(t, e, n) {
                    var i = n.x
                      , r = n.y
                      , o = t.x - i
                      , s = t.y - r
                      , a = e.x - i
                      , u = e.y - r
                      , l = 2 * Ci.det(o, s, a, u);
                    return new d(i - Ci.det(s, o * o + s * s, u, a * a + u * u) / l,r + Ci.det(o, o * o + s * s, a, a * a + u * u) / l)
                }
                ,
                Ci.perpendicularBisector = function(t, e) {
                    var n = e.x - t.x
                      , i = e.y - t.y;
                    return new F(new F(t.x + n / 2,t.y + i / 2,1),new F(t.x - i + n / 2,t.y + n + i / 2,1))
                }
                ,
                Ci.angleBisector = function(t, e, n) {
                    var i = e.distance(t)
                      , r = e.distance(n)
                      , o = i / (i + r)
                      , s = n.x - t.x
                      , a = n.y - t.y;
                    return new d(t.x + o * s,t.y + o * a)
                }
                ,
                Ci.area3D = function(t, e, n) {
                    var i = e.x - t.x
                      , r = e.y - t.y
                      , o = e.z - t.z
                      , s = n.x - t.x
                      , a = n.y - t.y
                      , u = n.z - t.z
                      , l = r * u - o * a
                      , c = o * s - i * u
                      , h = i * a - r * s
                      , f = l * l + c * c + h * h;
                    return Math.sqrt(f) / 2
                }
                ,
                Ci.centroid = function(t, e, n) {
                    return new d((t.x + e.x + n.x) / 3,(t.y + e.y + n.y) / 3)
                }
                ,
                Ci.inCentre = function(t, e, n) {
                    var i = e.distance(n)
                      , r = t.distance(n)
                      , o = t.distance(e)
                      , s = i + r + o;
                    return new d((i * t.x + r * e.x + o * n.x) / s,(i * t.y + r * e.y + o * n.y) / s)
                }
                ,
                e(wi.prototype, {
                    getRadius: function() {
                        return this.compute(),
                        this.radius
                    },
                    getDiameter: function() {
                        switch (this.compute(),
                        this.extremalPts.length) {
                        case 0:
                            return this.input.getFactory().createLineString();
                        case 1:
                            return this.input.getFactory().createPoint(this.centre)
                        }
                        var t = this.extremalPts[0]
                          , e = this.extremalPts[1];
                        return this.input.getFactory().createLineString([t, e])
                    },
                    getExtremalPoints: function() {
                        return this.compute(),
                        this.extremalPts
                    },
                    computeCirclePoints: function() {
                        if (this.input.isEmpty())
                            return this.extremalPts = new Array(0).fill(null),
                            null;
                        if (1 === this.input.getNumPoints()) {
                            var t = this.input.getCoordinates();
                            return this.extremalPts = [new d(t[0])],
                            null
                        }
                        var e = this.input.convexHull()
                          , n = e.getCoordinates()
                          , t = n;
                        if (n[0].equals2D(n[n.length - 1]) && (t = new Array(n.length - 1).fill(null),
                        X.copyDeep(n, 0, t, 0, n.length - 1)),
                        t.length <= 2)
                            return this.extremalPts = X.copyDeep(t),
                            null;
                        for (var i = wi.lowestPoint(t), r = wi.pointWitMinAngleWithX(t, i), o = 0; o < t.length; o++) {
                            var s = wi.pointWithMinAngleWithSegment(t, i, r);
                            if (Ni.isObtuse(i, s, r))
                                return this.extremalPts = [new d(i), new d(r)],
                                null;
                            if (Ni.isObtuse(s, i, r))
                                i = s;
                            else {
                                if (!Ni.isObtuse(s, r, i))
                                    return this.extremalPts = [new d(i), new d(r), new d(s)],
                                    null;
                                r = s
                            }
                        }
                        f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")
                    },
                    compute: function() {
                        return null !== this.extremalPts ? null : (this.computeCirclePoints(),
                        this.computeCentre(),
                        void (null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0]))))
                    },
                    getFarthestPoints: function() {
                        switch (this.compute(),
                        this.extremalPts.length) {
                        case 0:
                            return this.input.getFactory().createLineString();
                        case 1:
                            return this.input.getFactory().createPoint(this.centre)
                        }
                        var t = this.extremalPts[0]
                          , e = this.extremalPts[this.extremalPts.length - 1];
                        return this.input.getFactory().createLineString([t, e])
                    },
                    getCircle: function() {
                        if (this.compute(),
                        null === this.centre)
                            return this.input.getFactory().createPolygon();
                        var t = this.input.getFactory().createPoint(this.centre);
                        return 0 === this.radius ? t : t.buffer(this.radius)
                    },
                    getCentre: function() {
                        return this.compute(),
                        this.centre
                    },
                    computeCentre: function() {
                        switch (this.extremalPts.length) {
                        case 0:
                            this.centre = null;
                            break;
                        case 1:
                            this.centre = this.extremalPts[0];
                            break;
                        case 2:
                            this.centre = new d((this.extremalPts[0].x + this.extremalPts[1].x) / 2,(this.extremalPts[0].y + this.extremalPts[1].y) / 2);
                            break;
                        case 3:
                            this.centre = Ci.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2])
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return wi
                    }
                }),
                wi.pointWitMinAngleWithX = function(t, e) {
                    for (var n = r.MAX_VALUE, i = null, o = 0; o < t.length; o++) {
                        var s = t[o];
                        if (s !== e) {
                            var a = s.x - e.x
                              , u = s.y - e.y;
                            u < 0 && (u = -u);
                            var l = Math.sqrt(a * a + u * u)
                              , c = u / l;
                            c < n && (n = c,
                            i = s)
                        }
                    }
                    return i
                }
                ,
                wi.lowestPoint = function(t) {
                    for (var e = t[0], n = 1; n < t.length; n++)
                        t[n].y < e.y && (e = t[n]);
                    return e
                }
                ,
                wi.pointWithMinAngleWithSegment = function(t, e, n) {
                    for (var i = r.MAX_VALUE, o = null, s = 0; s < t.length; s++) {
                        var a = t[s];
                        if (a !== e && a !== n) {
                            var u = Ni.angleBetween(e, a, n);
                            u < i && (i = u,
                            o = a)
                        }
                    }
                    return o
                }
                ,
                e(_i.prototype, {
                    getWidthCoordinate: function() {
                        return this.computeMinimumDiameter(),
                        this.minWidthPt
                    },
                    getSupportingSegment: function() {
                        return this.computeMinimumDiameter(),
                        this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1])
                    },
                    getDiameter: function() {
                        if (this.computeMinimumDiameter(),
                        null === this.minWidthPt)
                            return this.inputGeom.getFactory().createLineString(null);
                        var t = this.minBaseSeg.project(this.minWidthPt);
                        return this.inputGeom.getFactory().createLineString([t, this.minWidthPt])
                    },
                    computeWidthConvex: function(t) {
                        this.convexHullPts = t instanceof Lt ? t.getExteriorRing().getCoordinates() : t.getCoordinates(),
                        0 === this.convexHullPts.length ? (this.minWidth = 0,
                        this.minWidthPt = null,
                        this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0,
                        this.minWidthPt = this.convexHullPts[0],
                        this.minBaseSeg.p0 = this.convexHullPts[0],
                        this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 === this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0,
                        this.minWidthPt = this.convexHullPts[0],
                        this.minBaseSeg.p0 = this.convexHullPts[0],
                        this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts)
                    },
                    computeConvexRingMinDiameter: function(t) {
                        this.minWidth = r.MAX_VALUE;
                        for (var e = 1, n = new ce, i = 0; i < t.length - 1; i++)
                            n.p0 = t[i],
                            n.p1 = t[i + 1],
                            e = this.findMaxPerpDistance(t, n, e)
                    },
                    computeMinimumDiameter: function() {
                        if (null !== this.minWidthPt)
                            return null;
                        if (this.isConvex)
                            this.computeWidthConvex(this.inputGeom);
                        else {
                            var t = new me(this.inputGeom).getConvexHull();
                            this.computeWidthConvex(t)
                        }
                    },
                    getLength: function() {
                        return this.computeMinimumDiameter(),
                        this.minWidth
                    },
                    findMaxPerpDistance: function(t, e, n) {
                        for (var i = e.distancePerpendicular(t[n]), r = i, o = n, s = o; r >= i; )
                            i = r,
                            o = s,
                            s = _i.nextIndex(t, o),
                            r = e.distancePerpendicular(t[s]);
                        return i < this.minWidth && (this.minPtIndex = o,
                        this.minWidth = i,
                        this.minWidthPt = t[this.minPtIndex],
                        this.minBaseSeg = new ce(e)),
                        o
                    },
                    getMinimumRectangle: function() {
                        if (this.computeMinimumDiameter(),
                        0 === this.minWidth)
                            return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ? this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(this.inputGeom.getFactory());
                        for (var t = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, e = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, n = r.MAX_VALUE, i = -r.MAX_VALUE, o = r.MAX_VALUE, s = -r.MAX_VALUE, a = 0; a < this.convexHullPts.length; a++) {
                            var u = _i.computeC(t, e, this.convexHullPts[a]);
                            u > i && (i = u),
                            u < n && (n = u);
                            var l = _i.computeC(-e, t, this.convexHullPts[a]);
                            l > s && (s = l),
                            l < o && (o = l)
                        }
                        var c = _i.computeSegmentForLine(-t, -e, s)
                          , h = _i.computeSegmentForLine(-t, -e, o)
                          , f = _i.computeSegmentForLine(-e, t, i)
                          , d = _i.computeSegmentForLine(-e, t, n)
                          , g = f.lineIntersection(c)
                          , p = d.lineIntersection(c)
                          , m = d.lineIntersection(h)
                          , y = f.lineIntersection(h)
                          , v = this.inputGeom.getFactory().createLinearRing([g, p, m, y, g]);
                        return this.inputGeom.getFactory().createPolygon(v, null)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return _i
                    }
                }),
                _i.nextIndex = function(t, e) {
                    return e++,
                    e >= t.length && (e = 0),
                    e
                }
                ,
                _i.computeC = function(t, e, n) {
                    return t * n.y - e * n.x
                }
                ,
                _i.getMinimumDiameter = function(t) {
                    return new _i(t).getDiameter()
                }
                ,
                _i.getMinimumRectangle = function(t) {
                    return new _i(t).getMinimumRectangle()
                }
                ,
                _i.computeSegmentForLine = function(t, e, n) {
                    var i = null
                      , r = null;
                    return Math.abs(e) > Math.abs(t) ? (i = new d(0,n / e),
                    r = new d(1,n / e - t / e)) : (i = new d(n / t,0),
                    r = new d(n / t - e / t,1)),
                    new ce(i,r)
                }
                ;
                var cs = Object.freeze({
                    Centroid: fe,
                    CGAlgorithms: le,
                    ConvexHull: me,
                    InteriorPointArea: oi,
                    InteriorPointLine: ai,
                    InteriorPointPoint: ui,
                    RobustLineIntersector: se,
                    MCPointInRing: xi,
                    MinimumBoundingCircle: wi,
                    MinimumDiameter: _i
                });
                e(Si.prototype, {
                    getResultGeometry: function() {
                        return new bi(this.distanceTolerance).transform(this.inputGeom)
                    },
                    setDistanceTolerance: function(t) {
                        if (t <= 0)
                            throw new i("Tolerance must be positive");
                        this.distanceTolerance = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Si
                    }
                }),
                Si.densifyPoints = function(t, e, n) {
                    for (var i = new ce, r = new N, o = 0; o < t.length - 1; o++) {
                        i.p0 = t[o],
                        i.p1 = t[o + 1],
                        r.add(i.p0, !1);
                        var s = i.getLength()
                          , a = Math.trunc(s / e) + 1;
                        if (a > 1)
                            for (var u = s / a, l = 1; l < a; l++) {
                                var c = l * u / s
                                  , h = i.pointAlong(c);
                                n.makePrecise(h),
                                r.add(h, !1)
                            }
                    }
                    return r.add(t[t.length - 1], !1),
                    r.toCoordinateArray()
                }
                ,
                Si.densify = function(t, e) {
                    var n = new Si(t);
                    return n.setDistanceTolerance(e),
                    n.getResultGeometry()
                }
                ,
                c(bi, ve),
                e(bi.prototype, {
                    transformMultiPolygon: function(t, e) {
                        var n = ve.prototype.transformMultiPolygon.call(this, t, e);
                        return this.createValidArea(n)
                    },
                    transformPolygon: function(t, e) {
                        var n = ve.prototype.transformPolygon.call(this, t, e);
                        return e instanceof Ot ? n : this.createValidArea(n)
                    },
                    transformCoordinates: function(t, e) {
                        var n = t.toCoordinateArray()
                          , i = Si.densifyPoints(n, this.distanceTolerance, e.getPrecisionModel());
                        return e instanceof wt && 1 === i.length && (i = new Array(0).fill(null)),
                        this.factory.getCoordinateSequenceFactory().create(i)
                    },
                    createValidArea: function(t) {
                        return t.buffer(0)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return bi
                    }
                }),
                Si.DensifyTransformer = bi;
                var hs = Object.freeze({
                    Densifier: Si
                });
                e(Li.prototype, {
                    find: function(t) {
                        var e = this;
                        do {
                            if (null === e)
                                return null;
                            if (e.dest().equals2D(t))
                                return e;
                            e = e.oNext()
                        } while (e !== this);return null
                    },
                    dest: function() {
                        return this._sym._orig
                    },
                    oNext: function() {
                        return this._sym._next
                    },
                    insert: function(t) {
                        if (this.oNext() === this)
                            return this.insertAfter(t),
                            null;
                        var e = this.compareTo(t)
                          , n = this;
                        do {
                            var i = n.oNext();
                            if (i.compareTo(t) !== e || i === this)
                                return n.insertAfter(t),
                                null;
                            n = i
                        } while (n !== this);f.shouldNeverReachHere()
                    },
                    insertAfter: function(t) {
                        f.equals(this._orig, t.orig());
                        var e = this.oNext();
                        this._sym.setNext(t),
                        t.sym().setNext(e)
                    },
                    degree: function() {
                        var t = 0
                          , e = this;
                        do {
                            t++,
                            e = e.oNext()
                        } while (e !== this);return t
                    },
                    equals: function() {
                        if (2 === arguments.length) {
                            var t = arguments[0]
                              , e = arguments[1];
                            return this._orig.equals2D(t) && this._sym._orig.equals(e)
                        }
                    },
                    deltaY: function() {
                        return this._sym._orig.y - this._orig.y
                    },
                    sym: function() {
                        return this._sym
                    },
                    prev: function() {
                        return this._sym.next()._sym
                    },
                    compareAngularDirection: function(t) {
                        var e = this.deltaX()
                          , n = this.deltaY()
                          , i = t.deltaX()
                          , r = t.deltaY();
                        if (e === i && n === r)
                            return 0;
                        var o = Ke.quadrant(e, n)
                          , s = Ke.quadrant(i, r);
                        return o > s ? 1 : o < s ? -1 : le.computeOrientation(t._orig, t.dest(), this.dest())
                    },
                    prevNode: function() {
                        for (var t = this; 2 === t.degree(); )
                            if ((t = t.prev()) === this)
                                return null;
                        return t
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.compareAngularDirection(e)
                    },
                    next: function() {
                        return this._next
                    },
                    setSym: function(t) {
                        this._sym = t
                    },
                    orig: function() {
                        return this._orig
                    },
                    toString: function() {
                        return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")"
                    },
                    setNext: function(t) {
                        this._next = t
                    },
                    init: function(t) {
                        this.setSym(t),
                        t.setSym(this),
                        this.setNext(t),
                        t.setNext(this)
                    },
                    deltaX: function() {
                        return this._sym._orig.x - this._orig.x
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Li
                    }
                }),
                Li.init = function(t, e) {
                    if (null !== t._sym || null !== e._sym || null !== t._next || null !== e._next)
                        throw new IllegalStateException("Edges are already initialized");
                    return t.init(e),
                    t
                }
                ,
                Li.create = function(t, e) {
                    var n = new Li(t)
                      , i = new Li(e);
                    return n.init(i),
                    n
                }
                ,
                c(Ti, Li),
                e(Ti.prototype, {
                    mark: function() {
                        this._isMarked = !0
                    },
                    setMark: function(t) {
                        this._isMarked = t
                    },
                    isMarked: function() {
                        return this._isMarked
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ti
                    }
                }),
                Ti.setMarkBoth = function(t, e) {
                    t.setMark(e),
                    t.sym().setMark(e)
                }
                ,
                Ti.isMarked = function(t) {
                    return t.isMarked()
                }
                ,
                Ti.setMark = function(t, e) {
                    t.setMark(e)
                }
                ,
                Ti.markBoth = function(t) {
                    t.mark(),
                    t.sym().mark()
                }
                ,
                Ti.mark = function(t) {
                    t.mark()
                }
                ,
                e(Ri.prototype, {
                    insert: function(t, e, n) {
                        var i = this.create(t, e);
                        null !== n ? n.insert(i) : this.vertexMap.put(t, i);
                        var r = this.vertexMap.get(e);
                        return null !== r ? r.insert(i.sym()) : this.vertexMap.put(e, i.sym()),
                        i
                    },
                    create: function(t, e) {
                        var n = this.createEdge(t)
                          , i = this.createEdge(e);
                        return Li.init(n, i),
                        n
                    },
                    createEdge: function(t) {
                        return new Li(t)
                    },
                    addEdge: function(t, e) {
                        if (!Ri.isValidEdge(t, e))
                            return null;
                        var n = this.vertexMap.get(t)
                          , i = null;
                        return null !== n && (i = n.find(e)),
                        null !== i ? i : this.insert(t, e, n)
                    },
                    getVertexEdges: function() {
                        return this.vertexMap.values()
                    },
                    findEdge: function(t, e) {
                        var n = this.vertexMap.get(t);
                        return null === n ? null : n.find(e)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ri
                    }
                }),
                Ri.isValidEdge = function(t, e) {
                    return 0 !== e.compareTo(t)
                }
                ,
                c(Oi, Ti),
                e(Oi.prototype, {
                    setStart: function() {
                        this._isStart = !0
                    },
                    isStart: function() {
                        return this._isStart
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Oi
                    }
                }),
                c(Pi, Ri),
                e(Pi.prototype, {
                    createEdge: function(t) {
                        return new Oi(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Pi
                    }
                }),
                e(Mi.prototype, {
                    addLine: function(t) {
                        this.lines.add(this.factory.createLineString(t.toCoordinateArray()))
                    },
                    updateRingStartEdge: function(t) {
                        return t.isStart() || (t = t.sym(),
                        t.isStart()) ? null === this.ringStartEdge ? (this.ringStartEdge = t,
                        null) : void (t.orig().compareTo(this.ringStartEdge.orig()) < 0 && (this.ringStartEdge = t)) : null
                    },
                    getResult: function() {
                        return null === this.result && this.computeResult(),
                        this.result
                    },
                    process: function(t) {
                        var e = t.prevNode();
                        null === e && (e = t),
                        this.stackEdges(e),
                        this.buildLines()
                    },
                    buildRing: function(t) {
                        var e = new N
                          , n = t;
                        for (e.add(n.orig().copy(), !1); 2 === n.sym().degree(); ) {
                            var i = n.next();
                            if (i === t)
                                break;
                            e.add(i.orig().copy(), !1),
                            n = i
                        }
                        e.add(n.dest().copy(), !1),
                        this.addLine(e)
                    },
                    buildLine: function(t) {
                        var e = new N
                          , n = t;
                        for (this.ringStartEdge = null,
                        Ti.markBoth(n),
                        e.add(n.orig().copy(), !1); 2 === n.sym().degree(); ) {
                            this.updateRingStartEdge(n);
                            var i = n.next();
                            if (i === t)
                                return this.buildRing(this.ringStartEdge),
                                null;
                            e.add(i.orig().copy(), !1),
                            n = i,
                            Ti.markBoth(n)
                        }
                        e.add(n.dest().copy(), !1),
                        this.stackEdges(n.sym()),
                        this.addLine(e)
                    },
                    stackEdges: function(t) {
                        var e = t;
                        do {
                            Ti.isMarked(e) || this.nodeEdgeStack.add(e),
                            e = e.oNext()
                        } while (e !== t)
                    },
                    computeResult: function() {
                        for (var t = this.graph.getVertexEdges(), e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            Ti.isMarked(n) || this.process(n)
                        }
                        this.result = this.factory.buildGeometry(this.lines)
                    },
                    buildLines: function() {
                        for (; !this.nodeEdgeStack.empty(); ) {
                            var t = this.nodeEdgeStack.pop();
                            Ti.isMarked(t) || this.buildLine(t)
                        }
                    },
                    add: function() {
                        if (arguments[0]instanceof q) {
                            arguments[0].apply({
                                interfaces_: function() {
                                    return [k]
                                },
                                filter: function(t) {
                                    t instanceof wt && this.add(t)
                                }
                            })
                        } else if (b(arguments[0], m))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.add(n)
                            }
                        else if (arguments[0]instanceof wt) {
                            var i = arguments[0];
                            null === this.factory && (this.factory = i.getFactory());
                            for (var r = i.getCoordinateSequence(), o = !1, e = 1; e < r.size(); e++) {
                                var s = this.graph.addEdge(r.getCoordinate(e - 1), r.getCoordinate(e));
                                null !== s && (o || (s.setStart(),
                                o = !0))
                            }
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Mi
                    }
                }),
                Mi.dissolve = function(t) {
                    var e = new Mi;
                    return e.add(t),
                    e.getResult()
                }
                ;
                var fs = Object.freeze({
                    LineDissolver: Mi
                })
                  , ds = Object.freeze({
                    GeometryGraph: Zn
                });
                e(Ai.prototype, {
                    hasChildren: function() {
                        for (var t = 0; t < 4; t++)
                            if (null !== this.subnode[t])
                                return !0;
                        return !1
                    },
                    isPrunable: function() {
                        return !(this.hasChildren() || this.hasItems())
                    },
                    addAllItems: function(t) {
                        t.addAll(this.items);
                        for (var e = 0; e < 4; e++)
                            null !== this.subnode[e] && this.subnode[e].addAllItems(t);
                        return t
                    },
                    getNodeCount: function() {
                        for (var t = 0, e = 0; e < 4; e++)
                            null !== this.subnode[e] && (t += this.subnode[e].size());
                        return t + 1
                    },
                    size: function() {
                        for (var t = 0, e = 0; e < 4; e++)
                            null !== this.subnode[e] && (t += this.subnode[e].size());
                        return t + this.items.size()
                    },
                    addAllItemsFromOverlapping: function(t, e) {
                        if (!this.isSearchMatch(t))
                            return null;
                        e.addAll(this.items);
                        for (var n = 0; n < 4; n++)
                            null !== this.subnode[n] && this.subnode[n].addAllItemsFromOverlapping(t, e)
                    },
                    visitItems: function(t, e) {
                        for (var n = this.items.iterator(); n.hasNext(); )
                            e.visitItem(n.next())
                    },
                    hasItems: function() {
                        return !this.items.isEmpty()
                    },
                    remove: function(t, e) {
                        if (!this.isSearchMatch(t))
                            return !1;
                        for (var n = !1, i = 0; i < 4; i++)
                            if (null !== this.subnode[i] && (n = this.subnode[i].remove(t, e))) {
                                this.subnode[i].isPrunable() && (this.subnode[i] = null);
                                break
                            }
                        return n || (n = this.items.remove(e))
                    },
                    visit: function(t, e) {
                        if (!this.isSearchMatch(t))
                            return null;
                        this.visitItems(t, e);
                        for (var n = 0; n < 4; n++)
                            null !== this.subnode[n] && this.subnode[n].visit(t, e)
                    },
                    getItems: function() {
                        return this.items
                    },
                    depth: function() {
                        for (var t = 0, e = 0; e < 4; e++)
                            if (null !== this.subnode[e]) {
                                var n = this.subnode[e].depth();
                                n > t && (t = n)
                            }
                        return t + 1
                    },
                    isEmpty: function() {
                        var t = !0;
                        this.items.isEmpty() || (t = !1);
                        for (var e = 0; e < 4; e++)
                            null !== this.subnode[e] && (this.subnode[e].isEmpty() || (t = !1));
                        return t
                    },
                    add: function(t) {
                        this.items.add(t)
                    },
                    interfaces_: function() {
                        return [u]
                    },
                    getClass: function() {
                        return Ai
                    }
                }),
                Ai.getSubnodeIndex = function(t, e, n) {
                    var i = -1;
                    return t.getMinX() >= e && (t.getMinY() >= n && (i = 3),
                    t.getMaxY() <= n && (i = 1)),
                    t.getMaxX() <= e && (t.getMinY() >= n && (i = 2),
                    t.getMaxY() <= n && (i = 0)),
                    i
                }
                ,
                e(Di.prototype, {
                    getLevel: function() {
                        return this.level
                    },
                    computeKey: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            for (this.level = Di.computeQuadLevel(t),
                            this.env = new C,
                            this.computeKey(this.level, t); !this.env.contains(t); )
                                this.level += 1,
                                this.computeKey(this.level, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1]
                              , i = fi.powerOf2(e);
                            this.pt.x = Math.floor(n.getMinX() / i) * i,
                            this.pt.y = Math.floor(n.getMinY() / i) * i,
                            this.env.init(this.pt.x, this.pt.x + i, this.pt.y, this.pt.y + i)
                        }
                    },
                    getEnvelope: function() {
                        return this.env
                    },
                    getCentre: function() {
                        return new d((this.env.getMinX() + this.env.getMaxX()) / 2,(this.env.getMinY() + this.env.getMaxY()) / 2)
                    },
                    getPoint: function() {
                        return this.pt
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Di
                    }
                }),
                Di.computeQuadLevel = function(t) {
                    var e = t.getWidth()
                      , n = t.getHeight()
                      , i = e > n ? e : n;
                    return fi.exponent(i) + 1
                }
                ,
                c(Fi, Ai),
                e(Fi.prototype, {
                    find: function(t) {
                        var e = Ai.getSubnodeIndex(t, this.centrex, this.centrey);
                        if (-1 === e)
                            return this;
                        if (null !== this.subnode[e]) {
                            return this.subnode[e].find(t)
                        }
                        return this
                    },
                    isSearchMatch: function(t) {
                        return this.env.intersects(t)
                    },
                    getSubnode: function(t) {
                        return null === this.subnode[t] && (this.subnode[t] = this.createSubnode(t)),
                        this.subnode[t]
                    },
                    getEnvelope: function() {
                        return this.env
                    },
                    getNode: function(t) {
                        var e = Ai.getSubnodeIndex(t, this.centrex, this.centrey);
                        if (-1 !== e) {
                            return this.getSubnode(e).getNode(t)
                        }
                        return this
                    },
                    createSubnode: function(t) {
                        var e = 0
                          , n = 0
                          , i = 0
                          , r = 0;
                        switch (t) {
                        case 0:
                            e = this.env.getMinX(),
                            n = this.centrex,
                            i = this.env.getMinY(),
                            r = this.centrey;
                            break;
                        case 1:
                            e = this.centrex,
                            n = this.env.getMaxX(),
                            i = this.env.getMinY(),
                            r = this.centrey;
                            break;
                        case 2:
                            e = this.env.getMinX(),
                            n = this.centrex,
                            i = this.centrey,
                            r = this.env.getMaxY();
                            break;
                        case 3:
                            e = this.centrex,
                            n = this.env.getMaxX(),
                            i = this.centrey,
                            r = this.env.getMaxY()
                        }
                        return new Fi(new C(e,n,i,r),this.level - 1)
                    },
                    insertNode: function(t) {
                        f.isTrue(null === this.env || this.env.contains(t.env));
                        var e = Ai.getSubnodeIndex(t.env, this.centrex, this.centrey);
                        if (t.level === this.level - 1)
                            this.subnode[e] = t;
                        else {
                            var n = this.createSubnode(e);
                            n.insertNode(t),
                            this.subnode[e] = n
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Fi
                    }
                }),
                Fi.createNode = function(t) {
                    var e = new Di(t);
                    return new Fi(e.getEnvelope(),e.getLevel())
                }
                ,
                Fi.createExpanded = function(t, e) {
                    var n = new C(e);
                    null !== t && n.expandToInclude(t.env);
                    var i = Fi.createNode(n);
                    return null !== t && i.insertNode(t),
                    i
                }
                ,
                c(Gi, Ai),
                e(Gi.prototype, {
                    insert: function(t, e) {
                        var n = Ai.getSubnodeIndex(t, Gi.origin.x, Gi.origin.y);
                        if (-1 === n)
                            return this.add(e),
                            null;
                        var i = this.subnode[n];
                        if (null === i || !i.getEnvelope().contains(t)) {
                            var r = Fi.createExpanded(i, t);
                            this.subnode[n] = r
                        }
                        this.insertContained(this.subnode[n], t, e)
                    },
                    isSearchMatch: function(t) {
                        return !0
                    },
                    insertContained: function(t, e, n) {
                        f.isTrue(t.getEnvelope().contains(e));
                        var i = mi.isZeroWidth(e.getMinX(), e.getMaxX())
                          , r = mi.isZeroWidth(e.getMinY(), e.getMaxY())
                          , o = null;
                        o = i || r ? t.find(e) : t.getNode(e),
                        o.add(n)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Gi
                    }
                }),
                Gi.origin = new d(0,0),
                e(ki.prototype, {
                    size: function() {
                        return null !== this.root ? this.root.size() : 0
                    },
                    insert: function(t, e) {
                        this.collectStats(t);
                        var n = ki.ensureExtent(t, this.minExtent);
                        this.root.insert(n, e)
                    },
                    query: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = new Vn;
                            return this.query(t, e),
                            e.getItems()
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1];
                            this.root.visit(n, i)
                        }
                    },
                    queryAll: function() {
                        var t = new I;
                        return this.root.addAllItems(t),
                        t
                    },
                    remove: function(t, e) {
                        var n = ki.ensureExtent(t, this.minExtent);
                        return this.root.remove(n, e)
                    },
                    collectStats: function(t) {
                        var e = t.getWidth();
                        e < this.minExtent && e > 0 && (this.minExtent = e);
                        var n = t.getHeight();
                        n < this.minExtent && n > 0 && (this.minExtent = n)
                    },
                    depth: function() {
                        return null !== this.root ? this.root.depth() : 0
                    },
                    isEmpty: function() {
                        return null === this.root
                    },
                    interfaces_: function() {
                        return [De, u]
                    },
                    getClass: function() {
                        return ki
                    }
                }),
                ki.ensureExtent = function(t, e) {
                    var n = t.getMinX()
                      , i = t.getMaxX()
                      , r = t.getMinY()
                      , o = t.getMaxY();
                    return n !== i && r !== o ? t : (n === i && (n -= e / 2,
                    i = n + e / 2),
                    r === o && (r -= e / 2,
                    o = r + e / 2),
                    new C(n,i,r,o))
                }
                ,
                ki.serialVersionUID = -0x678b60c967a25400;
                var gs = Object.freeze({
                    Quadtree: ki
                })
                  , ps = Object.freeze({
                    STRtree: Ue
                })
                  , ms = Object.freeze({
                    quadtree: gs,
                    strtree: ps
                })
                  , ys = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"];
                e(qi.prototype, {
                    read: function(t) {
                        var e = void 0;
                        e = "string" == typeof t ? JSON.parse(t) : t;
                        var n = e.type;
                        if (!vs[n])
                            throw new Error("Unknown GeoJSON type: " + e.type);
                        return -1 !== ys.indexOf(n) ? vs[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? vs[n].apply(this, [e.geometries]) : vs[n].apply(this, [e])
                    },
                    write: function(t) {
                        var e = t.getGeometryType();
                        if (!Es[e])
                            throw new Error("Geometry is not supported");
                        return Es[e].apply(this, [t])
                    }
                });
                var vs = {
                    Feature: function(t) {
                        var e = {};
                        for (var n in t)
                            e[n] = t[n];
                        if (t.geometry) {
                            var i = t.geometry.type;
                            if (!vs[i])
                                throw new Error("Unknown GeoJSON type: " + t.type);
                            e.geometry = this.read(t.geometry)
                        }
                        return t.bbox && (e.bbox = vs.bbox.apply(this, [t.bbox])),
                        e
                    },
                    FeatureCollection: function(t) {
                        var e = {};
                        if (t.features) {
                            e.features = [];
                            for (var n = 0; n < t.features.length; ++n)
                                e.features.push(this.read(t.features[n]))
                        }
                        return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])),
                        e
                    },
                    coordinates: function(t) {
                        for (var e = [], n = 0; n < t.length; ++n) {
                            var i = t[n];
                            e.push(new d(i[0],i[1]))
                        }
                        return e
                    },
                    bbox: function(t) {
                        return this.geometryFactory.createLinearRing([new d(t[0],t[1]), new d(t[2],t[1]), new d(t[2],t[3]), new d(t[0],t[3]), new d(t[0],t[1])])
                    },
                    Point: function(t) {
                        var e = new d(t[0],t[1]);
                        return this.geometryFactory.createPoint(e)
                    },
                    MultiPoint: function(t) {
                        for (var e = [], n = 0; n < t.length; ++n)
                            e.push(vs.Point.apply(this, [t[n]]));
                        return this.geometryFactory.createMultiPoint(e)
                    },
                    LineString: function(t) {
                        var e = vs.coordinates.apply(this, [t]);
                        return this.geometryFactory.createLineString(e)
                    },
                    MultiLineString: function(t) {
                        for (var e = [], n = 0; n < t.length; ++n)
                            e.push(vs.LineString.apply(this, [t[n]]));
                        return this.geometryFactory.createMultiLineString(e)
                    },
                    Polygon: function(t) {
                        for (var e = vs.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), i = [], r = 1; r < t.length; ++r) {
                            var o = t[r]
                              , s = vs.coordinates.apply(this, [o])
                              , a = this.geometryFactory.createLinearRing(s);
                            i.push(a)
                        }
                        return this.geometryFactory.createPolygon(n, i)
                    },
                    MultiPolygon: function(t) {
                        for (var e = [], n = 0; n < t.length; ++n) {
                            var i = t[n];
                            e.push(vs.Polygon.apply(this, [i]))
                        }
                        return this.geometryFactory.createMultiPolygon(e)
                    },
                    GeometryCollection: function(t) {
                        for (var e = [], n = 0; n < t.length; ++n) {
                            var i = t[n];
                            e.push(this.read(i))
                        }
                        return this.geometryFactory.createGeometryCollection(e)
                    }
                }
                  , Es = {
                    coordinate: function(t) {
                        return [t.x, t.y]
                    },
                    Point: function(t) {
                        return {
                            type: "Point",
                            coordinates: Es.coordinate.apply(this, [t.getCoordinate()])
                        }
                    },
                    MultiPoint: function(t) {
                        for (var e = [], n = 0; n < t.geometries.length; ++n) {
                            var i = t.geometries[n]
                              , r = Es.Point.apply(this, [i]);
                            e.push(r.coordinates)
                        }
                        return {
                            type: "MultiPoint",
                            coordinates: e
                        }
                    },
                    LineString: function(t) {
                        for (var e = [], n = t.getCoordinates(), i = 0; i < n.length; ++i) {
                            var r = n[i];
                            e.push(Es.coordinate.apply(this, [r]))
                        }
                        return {
                            type: "LineString",
                            coordinates: e
                        }
                    },
                    MultiLineString: function(t) {
                        for (var e = [], n = 0; n < t.geometries.length; ++n) {
                            var i = t.geometries[n]
                              , r = Es.LineString.apply(this, [i]);
                            e.push(r.coordinates)
                        }
                        return {
                            type: "MultiLineString",
                            coordinates: e
                        }
                    },
                    Polygon: function(t) {
                        var e = []
                          , n = Es.LineString.apply(this, [t.shell]);
                        e.push(n.coordinates);
                        for (var i = 0; i < t.holes.length; ++i) {
                            var r = t.holes[i]
                              , o = Es.LineString.apply(this, [r]);
                            e.push(o.coordinates)
                        }
                        return {
                            type: "Polygon",
                            coordinates: e
                        }
                    },
                    MultiPolygon: function(t) {
                        for (var e = [], n = 0; n < t.geometries.length; ++n) {
                            var i = t.geometries[n]
                              , r = Es.Polygon.apply(this, [i]);
                            e.push(r.coordinates)
                        }
                        return {
                            type: "MultiPolygon",
                            coordinates: e
                        }
                    },
                    GeometryCollection: function(t) {
                        for (var e = [], n = 0; n < t.geometries.length; ++n) {
                            var i = t.geometries[n]
                              , r = i.getGeometryType();
                            e.push(Es[r].apply(this, [i]))
                        }
                        return {
                            type: "GeometryCollection",
                            geometries: e
                        }
                    }
                };
                e(Bi.prototype, {
                    read: function(t) {
                        var e = this.parser.read(t);
                        return this.precisionModel.getType() === te.FIXED && this.reducePrecision(e),
                        e
                    },
                    reducePrecision: function(t) {
                        var e, n;
                        if (t.coordinate)
                            this.precisionModel.makePrecise(t.coordinate);
                        else if (t.points)
                            for (e = 0,
                            n = t.points.length; e < n; e++)
                                this.precisionModel.makePrecise(t.points[e]);
                        else if (t.geometries)
                            for (e = 0,
                            n = t.geometries.length; e < n; e++)
                                this.reducePrecision(t.geometries[e])
                    }
                }),
                e(Ui.prototype, {
                    write: function(t) {
                        return this.parser.write(t)
                    }
                }),
                e(Vi.prototype, {
                    read: function(t) {
                        var e = this.parser.read(t);
                        return this.precisionModel.getType() === te.FIXED && this.reducePrecision(e),
                        e
                    },
                    reducePrecision: function(t) {
                        if (t.coordinate)
                            this.precisionModel.makePrecise(t.coordinate);
                        else if (t.points)
                            for (var e = 0, n = t.points.coordinates.length; e < n; e++)
                                this.precisionModel.makePrecise(t.points.coordinates[e]);
                        else if (t.geometries)
                            for (var i = 0, r = t.geometries.length; i < r; i++)
                                this.reducePrecision(t.geometries[i])
                    }
                }),
                e(ji.prototype, {
                    read: function(t) {
                        var e = this.ol;
                        return t instanceof e.geom.Point ? this.convertFromPoint(t) : t instanceof e.geom.LineString ? this.convertFromLineString(t) : t instanceof e.geom.LinearRing ? this.convertFromLinearRing(t) : t instanceof e.geom.Polygon ? this.convertFromPolygon(t) : t instanceof e.geom.MultiPoint ? this.convertFromMultiPoint(t) : t instanceof e.geom.MultiLineString ? this.convertFromMultiLineString(t) : t instanceof e.geom.MultiPolygon ? this.convertFromMultiPolygon(t) : t instanceof e.geom.GeometryCollection ? this.convertFromCollection(t) : void 0
                    },
                    convertFromPoint: function(t) {
                        var e = t.getCoordinates();
                        return this.geometryFactory.createPoint(new d(e[0],e[1]))
                    },
                    convertFromLineString: function(t) {
                        return this.geometryFactory.createLineString(t.getCoordinates().map(function(t) {
                            return new d(t[0],t[1])
                        }))
                    },
                    convertFromLinearRing: function(t) {
                        return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t) {
                            return new d(t[0],t[1])
                        }))
                    },
                    convertFromPolygon: function(t) {
                        for (var e = t.getLinearRings(), n = null, i = [], r = 0; r < e.length; r++) {
                            var o = this.convertFromLinearRing(e[r]);
                            0 === r ? n = o : i.push(o)
                        }
                        return this.geometryFactory.createPolygon(n, i)
                    },
                    convertFromMultiPoint: function(t) {
                        var e = t.getPoints().map(function(t) {
                            return this.convertFromPoint(t)
                        }, this);
                        return this.geometryFactory.createMultiPoint(e)
                    },
                    convertFromMultiLineString: function(t) {
                        var e = t.getLineStrings().map(function(t) {
                            return this.convertFromLineString(t)
                        }, this);
                        return this.geometryFactory.createMultiLineString(e)
                    },
                    convertFromMultiPolygon: function(t) {
                        var e = t.getPolygons().map(function(t) {
                            return this.convertFromPolygon(t)
                        }, this);
                        return this.geometryFactory.createMultiPolygon(e)
                    },
                    convertFromCollection: function(t) {
                        var e = t.getGeometries().map(function(t) {
                            return this.read(t)
                        }, this);
                        return this.geometryFactory.createGeometryCollection(e)
                    },
                    write: function(t) {
                        return "Point" === t.getGeometryType() ? this.convertToPoint(t.getCoordinate()) : "LineString" === t.getGeometryType() ? this.convertToLineString(t) : "LinearRing" === t.getGeometryType() ? this.convertToLinearRing(t) : "Polygon" === t.getGeometryType() ? this.convertToPolygon(t) : "MultiPoint" === t.getGeometryType() ? this.convertToMultiPoint(t) : "MultiLineString" === t.getGeometryType() ? this.convertToMultiLineString(t) : "MultiPolygon" === t.getGeometryType() ? this.convertToMultiPolygon(t) : "GeometryCollection" === t.getGeometryType() ? this.convertToCollection(t) : void 0
                    },
                    convertToPoint: function(t) {
                        return new this.ol.geom.Point([t.x, t.y])
                    },
                    convertToLineString: function(t) {
                        var e = t.points.coordinates.map(zi);
                        return new this.ol.geom.LineString(e)
                    },
                    convertToLinearRing: function(t) {
                        var e = t.points.coordinates.map(zi);
                        return new this.ol.geom.LinearRing(e)
                    },
                    convertToPolygon: function(t) {
                        for (var e = [t.shell.points.coordinates.map(zi)], n = 0; n < t.holes.length; n++)
                            e.push(t.holes[n].points.coordinates.map(zi));
                        return new this.ol.geom.Polygon(e)
                    },
                    convertToMultiPoint: function(t) {
                        return new this.ol.geom.MultiPoint(t.getCoordinates().map(zi))
                    },
                    convertToMultiLineString: function(t) {
                        for (var e = [], n = 0; n < t.geometries.length; n++)
                            e.push(this.convertToLineString(t.geometries[n]).getCoordinates());
                        return new this.ol.geom.MultiLineString(e)
                    },
                    convertToMultiPolygon: function(t) {
                        for (var e = [], n = 0; n < t.geometries.length; n++)
                            e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());
                        return new this.ol.geom.MultiPolygon(e)
                    },
                    convertToCollection: function(t) {
                        for (var e = [], n = 0; n < t.geometries.length; n++) {
                            var i = t.geometries[n];
                            e.push(this.write(i))
                        }
                        return new this.ol.geom.GeometryCollection(e)
                    }
                });
                var xs = Object.freeze({
                    GeoJSONReader: Bi,
                    GeoJSONWriter: Ui,
                    OL3Parser: ji,
                    WKTReader: Vi,
                    WKTWriter: re
                });
                e(Yi.prototype, {
                    rescale: function() {
                        if (b(arguments[0], m))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.rescale(n.getCoordinates())
                            }
                        else if (arguments[0]instanceof Array) {
                            var i = arguments[0];
                            2 === i.length && (new d(i[0]),
                            new d(i[1]));
                            for (var e = 0; e < i.length; e++)
                                i[e].x = i[e].x / this.scaleFactor + this.offsetX,
                                i[e].y = i[e].y / this.scaleFactor + this.offsetY;
                            2 === i.length && i[0].equals2D(i[1]) && D.out.println(i)
                        }
                    },
                    scale: function() {
                        if (b(arguments[0], m)) {
                            for (var t = arguments[0], e = new I, n = t.iterator(); n.hasNext(); ) {
                                var i = n.next();
                                e.add(new We(this.scale(i.getCoordinates()),i.getData()))
                            }
                            return e
                        }
                        if (arguments[0]instanceof Array) {
                            for (var r = arguments[0], o = new Array(r.length).fill(null), n = 0; n < r.length; n++)
                                o[n] = new d(Math.round((r[n].x - this.offsetX) * this.scaleFactor),Math.round((r[n].y - this.offsetY) * this.scaleFactor),r[n].z);
                            return X.removeRepeatedPoints(o)
                        }
                    },
                    isIntegerPrecision: function() {
                        return 1 === this.scaleFactor
                    },
                    getNodedSubstrings: function() {
                        var t = this.noder.getNodedSubstrings();
                        return this.isScaled && this.rescale(t),
                        t
                    },
                    computeNodes: function(t) {
                        var e = t;
                        this.isScaled && (e = this.scale(t)),
                        this.noder.computeNodes(e)
                    },
                    interfaces_: function() {
                        return [Qe]
                    },
                    getClass: function() {
                        return Yi
                    }
                });
                var Is = Object.freeze({
                    MCIndexNoder: en,
                    ScaledNoder: Yi,
                    SegmentString: Te
                });
                e(Xi.prototype, {
                    isSimpleMultiPoint: function(t) {
                        if (t.isEmpty())
                            return !0;
                        for (var e = new at, n = 0; n < t.getNumGeometries(); n++) {
                            var i = t.getGeometryN(n)
                              , r = i.getCoordinate();
                            if (e.contains(r))
                                return this.nonSimpleLocation = r,
                                !1;
                            e.add(r)
                        }
                        return !0
                    },
                    isSimplePolygonal: function(t) {
                        for (var e = Un.getLines(t), n = e.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (!this.isSimpleLinearGeometry(i))
                                return !1
                        }
                        return !0
                    },
                    hasClosedEndpointIntersection: function(t) {
                        for (var e = new rt, n = t.getEdgeIterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = (i.getMaximumSegmentIndex(),
                            i.isClosed())
                              , o = i.getCoordinate(0);
                            this.addEndpoint(e, o, r);
                            var s = i.getCoordinate(i.getNumPoints() - 1);
                            this.addEndpoint(e, s, r)
                        }
                        for (var n = e.values().iterator(); n.hasNext(); ) {
                            var a = n.next();
                            if (a.isClosed && 2 !== a.degree)
                                return this.nonSimpleLocation = a.getCoordinate(),
                                !0
                        }
                        return !1
                    },
                    getNonSimpleLocation: function() {
                        return this.nonSimpleLocation
                    },
                    isSimpleLinearGeometry: function(t) {
                        if (t.isEmpty())
                            return !0;
                        var e = new Zn(0,t)
                          , n = new se
                          , i = e.computeSelfNodes(n, !0);
                        return !(i.hasIntersection() && (i.hasProperIntersection() ? (this.nonSimpleLocation = i.getProperIntersectionPoint(),
                        1) : this.hasNonEndpointIntersection(e) || this.isClosedEndpointsInInterior && this.hasClosedEndpointIntersection(e)))
                    },
                    hasNonEndpointIntersection: function(t) {
                        for (var e = t.getEdgeIterator(); e.hasNext(); )
                            for (var n = e.next(), i = n.getMaximumSegmentIndex(), r = n.getEdgeIntersectionList().iterator(); r.hasNext(); ) {
                                var o = r.next();
                                if (!o.isEndPoint(i))
                                    return this.nonSimpleLocation = o.getCoordinate(),
                                    !0
                            }
                        return !1
                    },
                    addEndpoint: function(t, e, n) {
                        var i = t.get(e);
                        null === i && (i = new Hi(e),
                        t.put(e, i)),
                        i.addEndpoint(n)
                    },
                    computeSimple: function(t) {
                        return this.nonSimpleLocation = null,
                        !!t.isEmpty() || (t instanceof wt ? this.isSimpleLinearGeometry(t) : t instanceof dt ? this.isSimpleLinearGeometry(t) : t instanceof Tt ? this.isSimpleMultiPoint(t) : b(t, bt) ? this.isSimplePolygonal(t) : !(t instanceof ft) || this.isSimpleGeometryCollection(t))
                    },
                    isSimple: function() {
                        return this.nonSimpleLocation = null,
                        this.computeSimple(this.inputGeom)
                    },
                    isSimpleGeometryCollection: function(t) {
                        for (var e = 0; e < t.getNumGeometries(); e++) {
                            var n = t.getGeometryN(e);
                            if (!this.computeSimple(n))
                                return !1
                        }
                        return !0
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Xi
                    }
                }),
                e(Hi.prototype, {
                    addEndpoint: function(t) {
                        this.degree++,
                        this.isClosed |= t
                    },
                    getCoordinate: function() {
                        return this.pt
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Hi
                    }
                }),
                Xi.EndpointInfo = Hi,
                e(Wi.prototype, {
                    getEndCapStyle: function() {
                        return this.endCapStyle
                    },
                    isSingleSided: function() {
                        return this._isSingleSided
                    },
                    setQuadrantSegments: function(t) {
                        this.quadrantSegments = t,
                        0 === this.quadrantSegments && (this.joinStyle = Wi.JOIN_BEVEL),
                        this.quadrantSegments < 0 && (this.joinStyle = Wi.JOIN_MITRE,
                        this.mitreLimit = Math.abs(this.quadrantSegments)),
                        t <= 0 && (this.quadrantSegments = 1),
                        this.joinStyle !== Wi.JOIN_ROUND && (this.quadrantSegments = Wi.DEFAULT_QUADRANT_SEGMENTS)
                    },
                    getJoinStyle: function() {
                        return this.joinStyle
                    },
                    setJoinStyle: function(t) {
                        this.joinStyle = t
                    },
                    setSimplifyFactor: function(t) {
                        this.simplifyFactor = t < 0 ? 0 : t
                    },
                    getSimplifyFactor: function() {
                        return this.simplifyFactor
                    },
                    getQuadrantSegments: function() {
                        return this.quadrantSegments
                    },
                    setEndCapStyle: function(t) {
                        this.endCapStyle = t
                    },
                    getMitreLimit: function() {
                        return this.mitreLimit
                    },
                    setMitreLimit: function(t) {
                        this.mitreLimit = t
                    },
                    setSingleSided: function(t) {
                        this._isSingleSided = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Wi
                    }
                }),
                Wi.bufferDistanceError = function(t) {
                    var e = Math.PI / 2 / t;
                    return 1 - Math.cos(e / 2)
                }
                ,
                Wi.CAP_ROUND = 1,
                Wi.CAP_FLAT = 2,
                Wi.CAP_SQUARE = 3,
                Wi.JOIN_ROUND = 1,
                Wi.JOIN_MITRE = 2,
                Wi.JOIN_BEVEL = 3,
                Wi.DEFAULT_QUADRANT_SEGMENTS = 8,
                Wi.DEFAULT_MITRE_LIMIT = 5,
                Wi.DEFAULT_SIMPLIFY_FACTOR = .01,
                e(Ji.prototype, {
                    getCoordinate: function() {
                        return this.minCoord
                    },
                    getRightmostSide: function(t, e) {
                        var n = this.getRightmostSideOfSegment(t, e);
                        return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)),
                        n < 0 && (this.minCoord = null,
                        this.checkForRightmostCoordinate(t)),
                        n
                    },
                    findRightmostEdgeAtVertex: function() {
                        var t = this.minDe.getEdge().getCoordinates();
                        f.isTrue(this.minIndex > 0 && this.minIndex < t.length, "rightmost point expected to be interior vertex of edge");
                        var e = t[this.minIndex - 1]
                          , n = t[this.minIndex + 1]
                          , i = le.computeOrientation(this.minCoord, n, e)
                          , r = !1;
                        e.y < this.minCoord.y && n.y < this.minCoord.y && i === le.COUNTERCLOCKWISE ? r = !0 : e.y > this.minCoord.y && n.y > this.minCoord.y && i === le.CLOCKWISE && (r = !0),
                        r && (this.minIndex = this.minIndex - 1)
                    },
                    getRightmostSideOfSegment: function(t, e) {
                        var n = t.getEdge()
                          , i = n.getCoordinates();
                        if (e < 0 || e + 1 >= i.length)
                            return -1;
                        if (i[e].y === i[e + 1].y)
                            return -1;
                        var r = cn.LEFT;
                        return i[e].y < i[e + 1].y && (r = cn.RIGHT),
                        r
                    },
                    getEdge: function() {
                        return this.orientedDe
                    },
                    checkForRightmostCoordinate: function(t) {
                        for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++)
                            (null === this.minCoord || e[n].x > this.minCoord.x) && (this.minDe = t,
                            this.minIndex = n,
                            this.minCoord = e[n])
                    },
                    findRightmostEdgeAtNode: function() {
                        var t = this.minDe.getNode()
                          , e = t.getEdges();
                        this.minDe = e.getRightmostEdge(),
                        this.minDe.isForward() || (this.minDe = this.minDe.getSym(),
                        this.minIndex = this.minDe.getEdge().getCoordinates().length - 1)
                    },
                    findEdge: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            n.isForward() && this.checkForRightmostCoordinate(n)
                        }
                        f.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing"),
                        0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(),
                        this.orientedDe = this.minDe,
                        this.getRightmostSide(this.minDe, this.minIndex) === cn.LEFT && (this.orientedDe = this.minDe.getSym())
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ji
                    }
                }),
                $i.prototype.addLast = function(t) {
                    this.array_.push(t)
                }
                ,
                $i.prototype.removeFirst = function() {
                    return this.array_.shift()
                }
                ,
                $i.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                }
                ,
                e(Ki.prototype, {
                    clearVisitedEdges: function() {
                        for (var t = this.dirEdgeList.iterator(); t.hasNext(); ) {
                            t.next().setVisited(!1)
                        }
                    },
                    getRightmostCoordinate: function() {
                        return this.rightMostCoord
                    },
                    computeNodeDepth: function(t) {
                        for (var e = null, n = t.getEdges().iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (i.isVisited() || i.getSym().isVisited()) {
                                e = i;
                                break
                            }
                        }
                        if (null === e)
                            throw new rn("unable to find edge to compute depths at " + t.getCoordinate());
                        t.getEdges().computeDepths(e);
                        for (var n = t.getEdges().iterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.setVisited(!0),
                            this.copySymDepths(i)
                        }
                    },
                    computeDepth: function(t) {
                        this.clearVisitedEdges();
                        var e = this.finder.getEdge();
                        e.getNode(),
                        e.getLabel(),
                        e.setEdgeDepths(cn.RIGHT, t),
                        this.copySymDepths(e),
                        this.computeDepths(e)
                    },
                    create: function(t) {
                        this.addReachable(t),
                        this.finder.findEdge(this.dirEdgeList),
                        this.rightMostCoord = this.finder.getCoordinate()
                    },
                    findResultEdges: function() {
                        for (var t = this.dirEdgeList.iterator(); t.hasNext(); ) {
                            var e = t.next();
                            e.getDepth(cn.RIGHT) >= 1 && e.getDepth(cn.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
                        }
                    },
                    computeDepths: function(t) {
                        var e = new Z
                          , n = new $i
                          , i = t.getNode();
                        for (n.addLast(i),
                        e.add(i),
                        t.setVisited(!0); !n.isEmpty(); ) {
                            var r = n.removeFirst();
                            e.add(r),
                            this.computeNodeDepth(r);
                            for (var o = r.getEdges().iterator(); o.hasNext(); ) {
                                var s = o.next()
                                  , a = s.getSym();
                                if (!a.isVisited()) {
                                    var u = a.getNode();
                                    e.contains(u) || (n.addLast(u),
                                    e.add(u))
                                }
                            }
                        }
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.rightMostCoord.x < e.rightMostCoord.x ? -1 : this.rightMostCoord.x > e.rightMostCoord.x ? 1 : 0
                    },
                    getEnvelope: function() {
                        if (null === this.env) {
                            for (var t = new C, e = this.dirEdgeList.iterator(); e.hasNext(); )
                                for (var n = e.next(), i = n.getEdge().getCoordinates(), r = 0; r < i.length - 1; r++)
                                    t.expandToInclude(i[r]);
                            this.env = t
                        }
                        return this.env
                    },
                    addReachable: function(t) {
                        var e = new ge;
                        for (e.add(t); !e.empty(); ) {
                            var n = e.pop();
                            this.add(n, e)
                        }
                    },
                    copySymDepths: function(t) {
                        var e = t.getSym();
                        e.setDepth(cn.LEFT, t.getDepth(cn.RIGHT)),
                        e.setDepth(cn.RIGHT, t.getDepth(cn.LEFT))
                    },
                    add: function(t, e) {
                        t.setVisited(!0),
                        this.nodes.add(t);
                        for (var n = t.getEdges().iterator(); n.hasNext(); ) {
                            var i = n.next();
                            this.dirEdgeList.add(i);
                            var r = i.getSym()
                              , o = r.getNode();
                            o.isVisited() || e.push(o)
                        }
                    },
                    getNodes: function() {
                        return this.nodes
                    },
                    getDirectedEdges: function() {
                        return this.dirEdgeList
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return Ki
                    }
                }),
                e(Zi.prototype, {
                    isDeletable: function(t, e, n, i) {
                        var r = this.inputLine[t]
                          , o = this.inputLine[e]
                          , s = this.inputLine[n];
                        return !!this.isConcave(r, o, s) && !!this.isShallow(r, o, s, i) && this.isShallowSampled(r, o, t, n, i)
                    },
                    deleteShallowConcavities: function() {
                        for (var t = 1, e = (this.inputLine.length,
                        this.findNextNonDeletedIndex(t)), n = this.findNextNonDeletedIndex(e), i = !1; n < this.inputLine.length; ) {
                            var r = !1;
                            this.isDeletable(t, e, n, this.distanceTol) && (this.isDeleted[e] = Zi.DELETE,
                            r = !0,
                            i = !0),
                            t = r ? n : e,
                            e = this.findNextNonDeletedIndex(t),
                            n = this.findNextNonDeletedIndex(e)
                        }
                        return i
                    },
                    isShallowConcavity: function(t, e, n, i) {
                        return le.computeOrientation(t, e, n) === this.angleOrientation && le.distancePointLine(e, t, n) < i
                    },
                    isShallowSampled: function(t, e, n, i, r) {
                        var o = Math.trunc((i - n) / Zi.NUM_PTS_TO_CHECK);
                        o <= 0 && (o = 1);
                        for (var s = n; s < i; s += o)
                            if (!this.isShallow(t, e, this.inputLine[s], r))
                                return !1;
                        return !0
                    },
                    isConcave: function(t, e, n) {
                        return le.computeOrientation(t, e, n) === this.angleOrientation
                    },
                    simplify: function(t) {
                        this.distanceTol = Math.abs(t),
                        t < 0 && (this.angleOrientation = le.CLOCKWISE),
                        this.isDeleted = new Array(this.inputLine.length).fill(null);
                        var e = !1;
                        do {
                            e = this.deleteShallowConcavities()
                        } while (e);return this.collapseLine()
                    },
                    findNextNonDeletedIndex: function(t) {
                        for (var e = t + 1; e < this.inputLine.length && this.isDeleted[e] === Zi.DELETE; )
                            e++;
                        return e
                    },
                    isShallow: function(t, e, n, i) {
                        return le.distancePointLine(e, t, n) < i
                    },
                    collapseLine: function() {
                        for (var t = new N, e = 0; e < this.inputLine.length; e++)
                            this.isDeleted[e] !== Zi.DELETE && t.add(this.inputLine[e]);
                        return t.toCoordinateArray()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Zi
                    }
                }),
                Zi.simplify = function(t, e) {
                    return new Zi(t).simplify(e)
                }
                ,
                Zi.INIT = 0,
                Zi.DELETE = 1,
                Zi.KEEP = 1,
                Zi.NUM_PTS_TO_CHECK = 10,
                e(Qi.prototype, {
                    getCoordinates: function() {
                        return this.ptList.toArray(Qi.COORDINATE_ARRAY_TYPE)
                    },
                    setPrecisionModel: function(t) {
                        this.precisionModel = t
                    },
                    addPt: function(t) {
                        var e = new d(t);
                        return this.precisionModel.makePrecise(e),
                        this.isRedundant(e) ? null : void this.ptList.add(e)
                    },
                    reverse: function() {},
                    addPts: function(t, e) {
                        if (e)
                            for (var n = 0; n < t.length; n++)
                                this.addPt(t[n]);
                        else
                            for (var n = t.length - 1; n >= 0; n--)
                                this.addPt(t[n])
                    },
                    isRedundant: function(t) {
                        if (this.ptList.size() < 1)
                            return !1;
                        var e = this.ptList.get(this.ptList.size() - 1);
                        return t.distance(e) < this.minimimVertexDistance
                    },
                    toString: function() {
                        return (new ne).createLineString(this.getCoordinates()).toString()
                    },
                    closeRing: function() {
                        if (this.ptList.size() < 1)
                            return null;
                        var t = new d(this.ptList.get(0))
                          , e = this.ptList.get(this.ptList.size() - 1);
                        return this.ptList.size() >= 2 && this.ptList.get(this.ptList.size() - 2),
                        t.equals(e) ? null : void this.ptList.add(t)
                    },
                    setMinimumVertexDistance: function(t) {
                        this.minimimVertexDistance = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Qi
                    }
                }),
                Qi.COORDINATE_ARRAY_TYPE = new Array(0).fill(null),
                e(tr.prototype, {
                    addNextSegment: function(t, e) {
                        if (this.s0 = this.s1,
                        this.s1 = this.s2,
                        this.s2 = t,
                        this.seg0.setCoordinates(this.s0, this.s1),
                        this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0),
                        this.seg1.setCoordinates(this.s1, this.s2),
                        this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1),
                        this.s1.equals(this.s2))
                            return null;
                        var n = le.computeOrientation(this.s0, this.s1, this.s2)
                          , i = n === le.CLOCKWISE && this.side === cn.LEFT || n === le.COUNTERCLOCKWISE && this.side === cn.RIGHT;
                        0 === n ? this.addCollinear(e) : i ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
                    },
                    addLineEndCap: function(t, e) {
                        var n = new ce(t,e)
                          , i = new ce;
                        this.computeOffsetSegment(n, cn.LEFT, this.distance, i);
                        var r = new ce;
                        this.computeOffsetSegment(n, cn.RIGHT, this.distance, r);
                        var o = e.x - t.x
                          , s = e.y - t.y
                          , a = Math.atan2(s, o);
                        switch (this.bufParams.getEndCapStyle()) {
                        case Wi.CAP_ROUND:
                            this.segList.addPt(i.p1),
                            this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, le.CLOCKWISE, this.distance),
                            this.segList.addPt(r.p1);
                            break;
                        case Wi.CAP_FLAT:
                            this.segList.addPt(i.p1),
                            this.segList.addPt(r.p1);
                            break;
                        case Wi.CAP_SQUARE:
                            var u = new d;
                            u.x = Math.abs(this.distance) * Math.cos(a),
                            u.y = Math.abs(this.distance) * Math.sin(a);
                            var l = new d(i.p1.x + u.x,i.p1.y + u.y)
                              , c = new d(r.p1.x + u.x,r.p1.y + u.y);
                            this.segList.addPt(l),
                            this.segList.addPt(c)
                        }
                    },
                    getCoordinates: function() {
                        return this.segList.getCoordinates()
                    },
                    addMitreJoin: function(t, e, n, i) {
                        var r = !0
                          , o = null;
                        try {
                            o = F.intersection(e.p0, e.p1, n.p0, n.p1);
                            (i <= 0 ? 1 : o.distance(t) / Math.abs(i)) > this.bufParams.getMitreLimit() && (r = !1)
                        } catch (t) {
                            if (!(t instanceof _))
                                throw t;
                            o = new d(0,0),
                            r = !1
                        }
                        r ? this.segList.addPt(o) : this.addLimitedMitreJoin(e, n, i, this.bufParams.getMitreLimit())
                    },
                    addFilletCorner: function(t, e, n, i, r) {
                        var o = e.x - t.x
                          , s = e.y - t.y
                          , a = Math.atan2(s, o)
                          , u = n.x - t.x
                          , l = n.y - t.y
                          , c = Math.atan2(l, u);
                        i === le.CLOCKWISE ? a <= c && (a += 2 * Math.PI) : a >= c && (a -= 2 * Math.PI),
                        this.segList.addPt(e),
                        this.addFilletArc(t, a, c, i, r),
                        this.segList.addPt(n)
                    },
                    addOutsideTurn: function(t, e) {
                        return this.offset0.p1.distance(this.offset1.p0) < this.distance * tr.OFFSET_SEGMENT_SEPARATION_FACTOR ? (this.segList.addPt(this.offset0.p1),
                        null) : void (this.bufParams.getJoinStyle() === Wi.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === Wi.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (e && this.segList.addPt(this.offset0.p1),
                        this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, t, this.distance),
                        this.segList.addPt(this.offset1.p0)))
                    },
                    createSquare: function(t) {
                        this.segList.addPt(new d(t.x + this.distance,t.y + this.distance)),
                        this.segList.addPt(new d(t.x + this.distance,t.y - this.distance)),
                        this.segList.addPt(new d(t.x - this.distance,t.y - this.distance)),
                        this.segList.addPt(new d(t.x - this.distance,t.y + this.distance)),
                        this.segList.closeRing()
                    },
                    addSegments: function(t, e) {
                        this.segList.addPts(t, e)
                    },
                    addFirstSegment: function() {
                        this.segList.addPt(this.offset1.p0)
                    },
                    addLastSegment: function() {
                        this.segList.addPt(this.offset1.p1)
                    },
                    initSideSegments: function(t, e, n) {
                        this.s1 = t,
                        this.s2 = e,
                        this.side = n,
                        this.seg1.setCoordinates(t, e),
                        this.computeOffsetSegment(this.seg1, n, this.distance, this.offset1)
                    },
                    addLimitedMitreJoin: function(t, e, n, i) {
                        var r = this.seg0.p1
                          , o = Ni.angle(r, this.seg0.p0)
                          , s = (Ni.angle(r, this.seg1.p1),
                        Ni.angleBetweenOriented(this.seg0.p0, r, this.seg1.p1))
                          , a = s / 2
                          , u = Ni.normalize(o + a)
                          , l = Ni.normalize(u + Math.PI)
                          , c = i * n
                          , h = c * Math.abs(Math.sin(a))
                          , f = n - h
                          , g = r.x + c * Math.cos(l)
                          , p = r.y + c * Math.sin(l)
                          , m = new d(g,p)
                          , y = new ce(r,m)
                          , v = y.pointAlongOffset(1, f)
                          , E = y.pointAlongOffset(1, -f);
                        this.side === cn.LEFT ? (this.segList.addPt(v),
                        this.segList.addPt(E)) : (this.segList.addPt(E),
                        this.segList.addPt(v))
                    },
                    computeOffsetSegment: function(t, e, n, i) {
                        var r = e === cn.LEFT ? 1 : -1
                          , o = t.p1.x - t.p0.x
                          , s = t.p1.y - t.p0.y
                          , a = Math.sqrt(o * o + s * s)
                          , u = r * n * o / a
                          , l = r * n * s / a;
                        i.p0.x = t.p0.x - l,
                        i.p0.y = t.p0.y + u,
                        i.p1.x = t.p1.x - l,
                        i.p1.y = t.p1.y + u
                    },
                    addFilletArc: function(t, e, n, i, r) {
                        var o = i === le.CLOCKWISE ? -1 : 1
                          , s = Math.abs(e - n)
                          , a = Math.trunc(s / this.filletAngleQuantum + .5);
                        if (a < 1)
                            return null;
                        var u = null
                          , l = null;
                        u = 0,
                        l = s / a;
                        for (var c = u, h = new d; c < s; ) {
                            var f = e + o * c;
                            h.x = t.x + r * Math.cos(f),
                            h.y = t.y + r * Math.sin(f),
                            this.segList.addPt(h),
                            c += l
                        }
                    },
                    addInsideTurn: function(t, e) {
                        if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1),
                        this.li.hasIntersection())
                            this.segList.addPt(this.li.getIntersection(0));
                        else if (this._hasNarrowConcaveAngle = !0,
                        this.offset0.p1.distance(this.offset1.p0) < this.distance * tr.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
                            this.segList.addPt(this.offset0.p1);
                        else {
                            if (this.segList.addPt(this.offset0.p1),
                            this.closingSegLengthFactor > 0) {
                                var n = new d((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1),(this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));
                                this.segList.addPt(n);
                                var i = new d((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1),(this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));
                                this.segList.addPt(i)
                            } else
                                this.segList.addPt(this.s1);
                            this.segList.addPt(this.offset1.p0)
                        }
                    },
                    createCircle: function(t) {
                        var e = new d(t.x + this.distance,t.y);
                        this.segList.addPt(e),
                        this.addFilletArc(t, 0, 2 * Math.PI, -1, this.distance),
                        this.segList.closeRing()
                    },
                    addBevelJoin: function(t, e) {
                        this.segList.addPt(t.p1),
                        this.segList.addPt(e.p0)
                    },
                    init: function(t) {
                        this.distance = t,
                        this.maxCurveSegmentError = t * (1 - Math.cos(this.filletAngleQuantum / 2)),
                        this.segList = new Qi,
                        this.segList.setPrecisionModel(this.precisionModel),
                        this.segList.setMinimumVertexDistance(t * tr.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
                    },
                    addCollinear: function(t) {
                        this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2),
                        this.li.getIntersectionNum() >= 2 && (this.bufParams.getJoinStyle() === Wi.JOIN_BEVEL || this.bufParams.getJoinStyle() === Wi.JOIN_MITRE ? (t && this.segList.addPt(this.offset0.p1),
                        this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, le.CLOCKWISE, this.distance))
                    },
                    closeRing: function() {
                        this.segList.closeRing()
                    },
                    hasNarrowConcaveAngle: function() {
                        return this._hasNarrowConcaveAngle
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return tr
                    }
                }),
                tr.OFFSET_SEGMENT_SEPARATION_FACTOR = .001,
                tr.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001,
                tr.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6,
                tr.MAX_CLOSING_SEG_LEN_FACTOR = 80,
                e(er.prototype, {
                    getOffsetCurve: function(t, e) {
                        if (this.distance = e,
                        0 === e)
                            return null;
                        var n = e < 0
                          , i = Math.abs(e)
                          , r = this.getSegGen(i);
                        t.length <= 1 ? this.computePointCurve(t[0], r) : this.computeOffsetCurve(t, n, r);
                        var o = r.getCoordinates();
                        return n && X.reverse(o),
                        o
                    },
                    computeSingleSidedBufferCurve: function(t, e, n) {
                        var i = this.simplifyTolerance(this.distance);
                        if (e) {
                            n.addSegments(t, !0);
                            var r = Zi.simplify(t, -i)
                              , o = r.length - 1;
                            n.initSideSegments(r[o], r[o - 1], cn.LEFT),
                            n.addFirstSegment();
                            for (var s = o - 2; s >= 0; s--)
                                n.addNextSegment(r[s], !0)
                        } else {
                            n.addSegments(t, !1);
                            var a = Zi.simplify(t, i)
                              , u = a.length - 1;
                            n.initSideSegments(a[0], a[1], cn.LEFT),
                            n.addFirstSegment();
                            for (var s = 2; s <= u; s++)
                                n.addNextSegment(a[s], !0)
                        }
                        n.addLastSegment(),
                        n.closeRing()
                    },
                    computeRingBufferCurve: function(t, e, n) {
                        var i = this.simplifyTolerance(this.distance);
                        e === cn.RIGHT && (i = -i);
                        var r = Zi.simplify(t, i)
                          , o = r.length - 1;
                        n.initSideSegments(r[o - 1], r[0], e);
                        for (var s = 1; s <= o; s++) {
                            var a = 1 !== s;
                            n.addNextSegment(r[s], a)
                        }
                        n.closeRing()
                    },
                    computeLineBufferCurve: function(t, e) {
                        var n = this.simplifyTolerance(this.distance)
                          , i = Zi.simplify(t, n)
                          , r = i.length - 1;
                        e.initSideSegments(i[0], i[1], cn.LEFT);
                        for (var o = 2; o <= r; o++)
                            e.addNextSegment(i[o], !0);
                        e.addLastSegment(),
                        e.addLineEndCap(i[r - 1], i[r]);
                        var s = Zi.simplify(t, -n)
                          , a = s.length - 1;
                        e.initSideSegments(s[a], s[a - 1], cn.LEFT);
                        for (var o = a - 2; o >= 0; o--)
                            e.addNextSegment(s[o], !0);
                        e.addLastSegment(),
                        e.addLineEndCap(s[1], s[0]),
                        e.closeRing()
                    },
                    computePointCurve: function(t, e) {
                        switch (this.bufParams.getEndCapStyle()) {
                        case Wi.CAP_ROUND:
                            e.createCircle(t);
                            break;
                        case Wi.CAP_SQUARE:
                            e.createSquare(t)
                        }
                    },
                    getLineCurve: function(t, e) {
                        if (this.distance = e,
                        e < 0 && !this.bufParams.isSingleSided())
                            return null;
                        if (0 === e)
                            return null;
                        var n = Math.abs(e)
                          , i = this.getSegGen(n);
                        if (t.length <= 1)
                            this.computePointCurve(t[0], i);
                        else if (this.bufParams.isSingleSided()) {
                            var r = e < 0;
                            this.computeSingleSidedBufferCurve(t, r, i)
                        } else
                            this.computeLineBufferCurve(t, i);
                        return i.getCoordinates()
                    },
                    getBufferParameters: function() {
                        return this.bufParams
                    },
                    simplifyTolerance: function(t) {
                        return t * this.bufParams.getSimplifyFactor()
                    },
                    getRingCurve: function(t, e, n) {
                        if (this.distance = n,
                        t.length <= 2)
                            return this.getLineCurve(t, n);
                        if (0 === n)
                            return er.copyCoordinates(t);
                        var i = this.getSegGen(n);
                        return this.computeRingBufferCurve(t, e, i),
                        i.getCoordinates()
                    },
                    computeOffsetCurve: function(t, e, n) {
                        var i = this.simplifyTolerance(this.distance);
                        if (e) {
                            var r = Zi.simplify(t, -i)
                              , o = r.length - 1;
                            n.initSideSegments(r[o], r[o - 1], cn.LEFT),
                            n.addFirstSegment();
                            for (var s = o - 2; s >= 0; s--)
                                n.addNextSegment(r[s], !0)
                        } else {
                            var a = Zi.simplify(t, i)
                              , u = a.length - 1;
                            n.initSideSegments(a[0], a[1], cn.LEFT),
                            n.addFirstSegment();
                            for (var s = 2; s <= u; s++)
                                n.addNextSegment(a[s], !0)
                        }
                        n.addLastSegment()
                    },
                    getSegGen: function(t) {
                        return new tr(this.precisionModel,this.bufParams,t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return er
                    }
                }),
                er.copyCoordinates = function(t) {
                    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++)
                        e[n] = new d(t[n]);
                    return e
                }
                ,
                e(nr.prototype, {
                    findStabbedSegments: function() {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = new I, n = this.subgraphs.iterator(); n.hasNext(); ) {
                                var i = n.next()
                                  , r = i.getEnvelope();
                                t.y < r.getMinY() || t.y > r.getMaxY() || this.findStabbedSegments(t, i.getDirectedEdges(), e)
                            }
                            return e
                        }
                        if (3 === arguments.length)
                            if (b(arguments[2], v) && arguments[0]instanceof d && arguments[1]instanceof xn)
                                for (var o = arguments[0], s = arguments[1], a = arguments[2], u = s.getEdge().getCoordinates(), n = 0; n < u.length - 1; n++) {
                                    this.seg.p0 = u[n],
                                    this.seg.p1 = u[n + 1],
                                    this.seg.p0.y > this.seg.p1.y && this.seg.reverse();
                                    var l = Math.max(this.seg.p0.x, this.seg.p1.x);
                                    if (!(l < o.x || this.seg.isHorizontal() || o.y < this.seg.p0.y || o.y > this.seg.p1.y || le.computeOrientation(this.seg.p0, this.seg.p1, o) === le.RIGHT)) {
                                        var c = s.getDepth(cn.LEFT);
                                        this.seg.p0.equals(u[n]) || (c = s.getDepth(cn.RIGHT));
                                        var h = new ir(this.seg,c);
                                        a.add(h)
                                    }
                                }
                            else if (b(arguments[2], v) && arguments[0]instanceof d && b(arguments[1], v))
                                for (var f = arguments[0], g = arguments[1], p = arguments[2], n = g.iterator(); n.hasNext(); ) {
                                    var m = n.next();
                                    m.isForward() && this.findStabbedSegments(f, m, p)
                                }
                    },
                    getDepth: function(t) {
                        var e = this.findStabbedSegments(t);
                        return 0 === e.size() ? 0 : ls.min(e).leftDepth
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return nr
                    }
                }),
                e(ir.prototype, {
                    compareTo: function(t) {
                        var e = t;
                        if (this.upwardSeg.minX() >= e.upwardSeg.maxX())
                            return 1;
                        if (this.upwardSeg.maxX() <= e.upwardSeg.minX())
                            return -1;
                        var n = this.upwardSeg.orientationIndex(e.upwardSeg);
                        return 0 !== n ? n : (n = -1 * e.upwardSeg.orientationIndex(this.upwardSeg),
                        0 !== n ? n : this.upwardSeg.compareTo(e.upwardSeg))
                    },
                    compareX: function(t, e) {
                        var n = t.p0.compareTo(e.p0);
                        return 0 !== n ? n : t.p1.compareTo(e.p1)
                    },
                    toString: function() {
                        return this.upwardSeg.toString()
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return ir
                    }
                }),
                nr.DepthSegment = ir,
                e(rr.prototype, {
                    addPoint: function(t) {
                        if (this.distance <= 0)
                            return null;
                        var e = t.getCoordinates()
                          , n = this.curveBuilder.getLineCurve(e, this.distance);
                        this.addCurve(n, S.EXTERIOR, S.INTERIOR)
                    },
                    addPolygon: function(t) {
                        var e = this.distance
                          , n = cn.LEFT;
                        this.distance < 0 && (e = -this.distance,
                        n = cn.RIGHT);
                        var i = t.getExteriorRing()
                          , r = X.removeRepeatedPoints(i.getCoordinates());
                        if (this.distance < 0 && this.isErodedCompletely(i, this.distance))
                            return null;
                        if (this.distance <= 0 && r.length < 3)
                            return null;
                        this.addPolygonRing(r, e, n, S.EXTERIOR, S.INTERIOR);
                        for (var o = 0; o < t.getNumInteriorRing(); o++) {
                            var s = t.getInteriorRingN(o)
                              , a = X.removeRepeatedPoints(s.getCoordinates());
                            this.distance > 0 && this.isErodedCompletely(s, -this.distance) || this.addPolygonRing(a, e, cn.opposite(n), S.INTERIOR, S.EXTERIOR)
                        }
                    },
                    isTriangleErodedCompletely: function(t, e) {
                        var n = new Ci(t[0],t[1],t[2])
                          , i = n.inCentre();
                        return le.distancePointLine(i, n.p0, n.p1) < Math.abs(e)
                    },
                    addLineString: function(t) {
                        if (this.distance <= 0 && !this.curveBuilder.getBufferParameters().isSingleSided())
                            return null;
                        var e = X.removeRepeatedPoints(t.getCoordinates())
                          , n = this.curveBuilder.getLineCurve(e, this.distance);
                        this.addCurve(n, S.EXTERIOR, S.INTERIOR)
                    },
                    addCurve: function(t, e, n) {
                        if (null === t || t.length < 2)
                            return null;
                        var i = new We(t,new fn(0,S.BOUNDARY,e,n));
                        this.curveList.add(i)
                    },
                    getCurves: function() {
                        return this.add(this.inputGeom),
                        this.curveList
                    },
                    addPolygonRing: function(t, e, n, i, r) {
                        if (0 === e && t.length < Rt.MINIMUM_VALID_SIZE)
                            return null;
                        var o = i
                          , s = r;
                        t.length >= Rt.MINIMUM_VALID_SIZE && le.isCCW(t) && (o = r,
                        s = i,
                        n = cn.opposite(n));
                        var a = this.curveBuilder.getRingCurve(t, n, e);
                        this.addCurve(a, o, s)
                    },
                    add: function(t) {
                        if (t.isEmpty())
                            return null;
                        if (t instanceof Lt)
                            this.addPolygon(t);
                        else if (t instanceof wt)
                            this.addLineString(t);
                        else if (t instanceof St)
                            this.addPoint(t);
                        else if (t instanceof Tt)
                            this.addCollection(t);
                        else if (t instanceof dt)
                            this.addCollection(t);
                        else if (t instanceof Ot)
                            this.addCollection(t);
                        else {
                            if (!(t instanceof ft))
                                throw new UnsupportedOperationException(t.getClass().getName());
                            this.addCollection(t)
                        }
                    },
                    isErodedCompletely: function(t, e) {
                        var n = t.getCoordinates();
                        if (n.length < 4)
                            return e < 0;
                        if (4 === n.length)
                            return this.isTriangleErodedCompletely(n, e);
                        var i = t.getEnvelopeInternal()
                          , r = Math.min(i.getHeight(), i.getWidth());
                        return e < 0 && 2 * Math.abs(e) > r
                    },
                    addCollection: function(t) {
                        for (var e = 0; e < t.getNumGeometries(); e++) {
                            var n = t.getGeometryN(e);
                            this.add(n)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return rr
                    }
                }),
                e(or.prototype, {
                    isTrivialIntersection: function(t, e, n, i) {
                        if (t === n && 1 === this.li.getIntersectionNum()) {
                            if (or.isAdjacentSegments(e, i))
                                return !0;
                            if (t.isClosed()) {
                                var r = t.size() - 1;
                                if (0 === e && i === r || 0 === i && e === r)
                                    return !0
                            }
                        }
                        return !1
                    },
                    getProperIntersectionPoint: function() {
                        return this.properIntersectionPoint
                    },
                    hasProperInteriorIntersection: function() {
                        return this.hasProperInterior
                    },
                    getLineIntersector: function() {
                        return this.li
                    },
                    hasProperIntersection: function() {
                        return this.hasProper
                    },
                    processIntersections: function(t, e, n, i) {
                        if (t === n && e === i)
                            return null;
                        this.numTests++;
                        var r = t.getCoordinates()[e]
                          , o = t.getCoordinates()[e + 1]
                          , s = n.getCoordinates()[i]
                          , a = n.getCoordinates()[i + 1];
                        this.li.computeIntersection(r, o, s, a),
                        this.li.hasIntersection() && (this.numIntersections++,
                        this.li.isInteriorIntersection() && (this.numInteriorIntersections++,
                        this.hasInterior = !0),
                        this.isTrivialIntersection(t, e, n, i) || (this._hasIntersection = !0,
                        t.addIntersections(this.li, e, 0),
                        n.addIntersections(this.li, i, 1),
                        this.li.isProper() && (this.numProperIntersections++,
                        this.hasProper = !0,
                        this.hasProperInterior = !0)))
                    },
                    hasIntersection: function() {
                        return this._hasIntersection
                    },
                    isDone: function() {
                        return !1
                    },
                    hasInteriorIntersection: function() {
                        return this.hasInterior
                    },
                    interfaces_: function() {
                        return [on]
                    },
                    getClass: function() {
                        return or
                    }
                }),
                or.isAdjacentSegments = function(t, e) {
                    return 1 === Math.abs(t - e)
                }
                ,
                e(sr.prototype, {
                    setWorkingPrecisionModel: function(t) {
                        this.workingPrecisionModel = t
                    },
                    insertUniqueEdge: function(t) {
                        var e = this.edgeList.findEqualEdge(t);
                        if (null !== e) {
                            var n = e.getLabel()
                              , i = t.getLabel();
                            e.isPointwiseEqual(t) || (i = new fn(t.getLabel()),
                            i.flip()),
                            n.merge(i);
                            var r = sr.depthDelta(i)
                              , o = e.getDepthDelta()
                              , s = o + r;
                            e.setDepthDelta(s)
                        } else
                            this.edgeList.add(t),
                            t.setDepthDelta(sr.depthDelta(t.getLabel()))
                    },
                    buildSubgraphs: function(t, e) {
                        for (var n = new I, i = t.iterator(); i.hasNext(); ) {
                            var r = i.next()
                              , o = r.getRightmostCoordinate()
                              , s = new nr(n)
                              , a = s.getDepth(o);
                            r.computeDepth(a),
                            r.findResultEdges(),
                            n.add(r),
                            e.add(r.getDirectedEdges(), r.getNodes())
                        }
                    },
                    createSubgraphs: function(t) {
                        for (var e = new I, n = t.getNodes().iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (!i.isVisited()) {
                                var r = new Ki;
                                r.create(i),
                                e.add(r)
                            }
                        }
                        return ls.sort(e, ls.reverseOrder()),
                        e
                    },
                    createEmptyResultGeometry: function() {
                        return this.geomFact.createPolygon()
                    },
                    getNoder: function(t) {
                        if (null !== this.workingNoder)
                            return this.workingNoder;
                        var e = new en
                          , n = new se;
                        return n.setPrecisionModel(t),
                        e.setSegmentIntersector(new or(n)),
                        e
                    },
                    buffer: function(t, e) {
                        var n = this.workingPrecisionModel;
                        null === n && (n = t.getPrecisionModel()),
                        this.geomFact = t.getFactory();
                        var i = new er(n,this.bufParams)
                          , r = new rr(t,e,i)
                          , o = r.getCurves();
                        if (o.size() <= 0)
                            return this.createEmptyResultGeometry();
                        this.computeNodedEdges(o, n),
                        this.graph = new Nn(new Rn),
                        this.graph.addEdges(this.edgeList.getEdges());
                        var s = this.createSubgraphs(this.graph)
                          , a = new Cn(this.geomFact);
                        this.buildSubgraphs(s, a);
                        var u = a.getPolygons();
                        return u.size() <= 0 ? this.createEmptyResultGeometry() : this.geomFact.buildGeometry(u)
                    },
                    computeNodedEdges: function(t, e) {
                        var n = this.getNoder(e);
                        n.computeNodes(t);
                        for (var i = n.getNodedSubstrings(), r = i.iterator(); r.hasNext(); ) {
                            var o = r.next()
                              , s = o.getCoordinates();
                            if (2 !== s.length || !s[0].equals2D(s[1])) {
                                var a = o.getData()
                                  , u = new Kn(o.getCoordinates(),new fn(a));
                                this.insertUniqueEdge(u)
                            }
                        }
                    },
                    setNoder: function(t) {
                        this.workingNoder = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return sr
                    }
                }),
                sr.depthDelta = function(t) {
                    var e = t.getLocation(0, cn.LEFT)
                      , n = t.getLocation(0, cn.RIGHT);
                    return e === S.INTERIOR && n === S.EXTERIOR ? 1 : e === S.EXTERIOR && n === S.INTERIOR ? -1 : 0
                }
                ,
                sr.convertSegStrings = function(t) {
                    for (var e = new ne, n = new I; t.hasNext(); ) {
                        var i = t.next()
                          , r = e.createLineString(i.getCoordinates());
                        n.add(r)
                    }
                    return e.buildGeometry(n)
                }
                ,
                e(ar.prototype, {
                    checkEndPtVertexIntersections: function() {
                        if (0 === arguments.length)
                            for (var t = this.segStrings.iterator(); t.hasNext(); ) {
                                var e = t.next()
                                  , n = e.getCoordinates();
                                this.checkEndPtVertexIntersections(n[0], this.segStrings),
                                this.checkEndPtVertexIntersections(n[n.length - 1], this.segStrings)
                            }
                        else if (2 === arguments.length)
                            for (var i = arguments[0], r = arguments[1], t = r.iterator(); t.hasNext(); )
                                for (var e = t.next(), n = e.getCoordinates(), o = 1; o < n.length - 1; o++)
                                    if (n[o].equals(i))
                                        throw new l("found endpt/interior pt intersection at index " + o + " :pt " + i)
                    },
                    checkInteriorIntersections: function() {
                        if (0 === arguments.length)
                            for (var t = this.segStrings.iterator(); t.hasNext(); )
                                for (var e = t.next(), n = this.segStrings.iterator(); n.hasNext(); ) {
                                    var i = n.next();
                                    this.checkInteriorIntersections(e, i)
                                }
                        else if (2 === arguments.length)
                            for (var r = arguments[0], o = arguments[1], s = r.getCoordinates(), a = o.getCoordinates(), u = 0; u < s.length - 1; u++)
                                for (var c = 0; c < a.length - 1; c++)
                                    this.checkInteriorIntersections(r, u, o, c);
                        else if (4 === arguments.length) {
                            var h = arguments[0]
                              , f = arguments[1]
                              , d = arguments[2]
                              , g = arguments[3];
                            if (h === d && f === g)
                                return null;
                            var p = h.getCoordinates()[f]
                              , m = h.getCoordinates()[f + 1]
                              , y = d.getCoordinates()[g]
                              , v = d.getCoordinates()[g + 1];
                            if (this.li.computeIntersection(p, m, y, v),
                            this.li.hasIntersection() && (this.li.isProper() || this.hasInteriorIntersection(this.li, p, m) || this.hasInteriorIntersection(this.li, y, v)))
                                throw new l("found non-noded intersection at " + p + "-" + m + " and " + y + "-" + v)
                        }
                    },
                    checkValid: function() {
                        this.checkEndPtVertexIntersections(),
                        this.checkInteriorIntersections(),
                        this.checkCollapses()
                    },
                    checkCollapses: function() {
                        if (0 === arguments.length)
                            for (var t = this.segStrings.iterator(); t.hasNext(); ) {
                                var e = t.next();
                                this.checkCollapses(e)
                            }
                        else if (1 === arguments.length)
                            for (var n = arguments[0], i = n.getCoordinates(), t = 0; t < i.length - 2; t++)
                                this.checkCollapse(i[t], i[t + 1], i[t + 2])
                    },
                    hasInteriorIntersection: function(t, e, n) {
                        for (var i = 0; i < t.getIntersectionNum(); i++) {
                            var r = t.getIntersection(i);
                            if (!r.equals(e) && !r.equals(n))
                                return !0
                        }
                        return !1
                    },
                    checkCollapse: function(t, e, n) {
                        if (t.equals(n))
                            throw new l("found non-noded collapse at " + ar.fact.createLineString([t, e, n]))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ar
                    }
                }),
                ar.fact = new ne,
                e(ur.prototype, {
                    intersectsScaled: function(t, e) {
                        var n = Math.min(t.x, e.x)
                          , i = Math.max(t.x, e.x)
                          , r = Math.min(t.y, e.y)
                          , o = Math.max(t.y, e.y)
                          , s = this.maxx < n || this.minx > i || this.maxy < r || this.miny > o;
                        if (s)
                            return !1;
                        var a = this.intersectsToleranceSquare(t, e);
                        return f.isTrue(!(s && a), "Found bad envelope test"),
                        a
                    },
                    initCorners: function(t) {
                        this.minx = t.x - .5,
                        this.maxx = t.x + .5,
                        this.miny = t.y - .5,
                        this.maxy = t.y + .5,
                        this.corner[0] = new d(this.maxx,this.maxy),
                        this.corner[1] = new d(this.minx,this.maxy),
                        this.corner[2] = new d(this.minx,this.miny),
                        this.corner[3] = new d(this.maxx,this.miny)
                    },
                    intersects: function(t, e) {
                        return 1 === this.scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this.p0Scaled),
                        this.copyScaled(e, this.p1Scaled),
                        this.intersectsScaled(this.p0Scaled, this.p1Scaled))
                    },
                    scale: function(t) {
                        return Math.round(t * this.scaleFactor)
                    },
                    getCoordinate: function() {
                        return this.originalPt
                    },
                    copyScaled: function(t, e) {
                        e.x = this.scale(t.x),
                        e.y = this.scale(t.y)
                    },
                    getSafeEnvelope: function() {
                        if (null === this.safeEnv) {
                            var t = ur.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;
                            this.safeEnv = new C(this.originalPt.x - t,this.originalPt.x + t,this.originalPt.y - t,this.originalPt.y + t)
                        }
                        return this.safeEnv
                    },
                    intersectsPixelClosure: function(t, e) {
                        return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]),
                        !!(this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]),
                        this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[2], this.corner[3]),
                        this.li.hasIntersection() || (this.li.computeIntersection(t, e, this.corner[3], this.corner[0]),
                        this.li.hasIntersection()))))
                    },
                    intersectsToleranceSquare: function(t, e) {
                        var n = !1
                          , i = !1;
                        return this.li.computeIntersection(t, e, this.corner[0], this.corner[1]),
                        !!(this.li.isProper() || (this.li.computeIntersection(t, e, this.corner[1], this.corner[2]),
                        this.li.isProper() || (this.li.hasIntersection() && (n = !0),
                        this.li.computeIntersection(t, e, this.corner[2], this.corner[3]),
                        this.li.isProper() || (this.li.hasIntersection() && (i = !0),
                        this.li.computeIntersection(t, e, this.corner[3], this.corner[0]),
                        this.li.isProper() || n && i || t.equals(this.pt) || e.equals(this.pt)))))
                    },
                    addSnappedNode: function(t, e) {
                        var n = t.getCoordinate(e)
                          , i = t.getCoordinate(e + 1);
                        return !!this.intersects(n, i) && (t.addIntersection(this.getCoordinate(), e),
                        !0)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ur
                    }
                }),
                ur.SAFE_ENV_EXPANSION_FACTOR = .75,
                e(lr.prototype, {
                    snap: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.snap(t, null, -1)
                        }
                        if (3 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1]
                              , i = arguments[2]
                              , r = e.getSafeEnvelope()
                              , o = new cr(e,n,i);
                            return this.index.query(r, {
                                interfaces_: function() {
                                    return [Ae]
                                },
                                visitItem: function(t) {
                                    t.select(r, o)
                                }
                            }),
                            o.isNodeAdded()
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return lr
                    }
                }),
                c(cr, li),
                e(cr.prototype, {
                    isNodeAdded: function() {
                        return this._isNodeAdded
                    },
                    select: function() {
                        if (2 !== arguments.length)
                            return li.prototype.select.apply(this, arguments);
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = t.getContext();
                        return null !== this.parentEdge && n === this.parentEdge && e === this.hotPixelVertexIndex ? null : void (this._isNodeAdded = this.hotPixel.addSnappedNode(n, e))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return cr
                    }
                }),
                lr.HotPixelSnapAction = cr,
                e(hr.prototype, {
                    processIntersections: function(t, e, n, i) {
                        if (t === n && e === i)
                            return null;
                        var r = t.getCoordinates()[e]
                          , o = t.getCoordinates()[e + 1]
                          , s = n.getCoordinates()[i]
                          , a = n.getCoordinates()[i + 1];
                        if (this.li.computeIntersection(r, o, s, a),
                        this.li.hasIntersection() && this.li.isInteriorIntersection()) {
                            for (var u = 0; u < this.li.getIntersectionNum(); u++)
                                this.interiorIntersections.add(this.li.getIntersection(u));
                            t.addIntersections(this.li, e, 0),
                            n.addIntersections(this.li, i, 1)
                        }
                    },
                    isDone: function() {
                        return !1
                    },
                    getInteriorIntersections: function() {
                        return this.interiorIntersections
                    },
                    interfaces_: function() {
                        return [on]
                    },
                    getClass: function() {
                        return hr
                    }
                }),
                e(fr.prototype, {
                    checkCorrectness: function(t) {
                        var e = We.getNodedSubstrings(t)
                          , n = new ar(e);
                        try {
                            n.checkValid()
                        } catch (t) {
                            if (!(t instanceof w))
                                throw t;
                            t.printStackTrace()
                        }
                    },
                    getNodedSubstrings: function() {
                        return We.getNodedSubstrings(this.nodedSegStrings)
                    },
                    snapRound: function(t, e) {
                        var n = this.findInteriorIntersections(t, e);
                        this.computeIntersectionSnaps(n),
                        this.computeVertexSnaps(t)
                    },
                    findInteriorIntersections: function(t, e) {
                        var n = new hr(e);
                        return this.noder.setSegmentIntersector(n),
                        this.noder.computeNodes(t),
                        n.getInteriorIntersections()
                    },
                    computeVertexSnaps: function() {
                        if (b(arguments[0], m))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.computeVertexSnaps(n)
                            }
                        else if (arguments[0]instanceof We)
                            for (var i = arguments[0], r = i.getCoordinates(), o = 0; o < r.length; o++) {
                                var s = new ur(r[o],this.scaleFactor,this.li)
                                  , a = this.pointSnapper.snap(s, i, o);
                                a && i.addIntersection(r[o], o)
                            }
                    },
                    computeNodes: function(t) {
                        this.nodedSegStrings = t,
                        this.noder = new en,
                        this.pointSnapper = new lr(this.noder.getIndex()),
                        this.snapRound(t, this.li)
                    },
                    computeIntersectionSnaps: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = new ur(n,this.scaleFactor,this.li);
                            this.pointSnapper.snap(i)
                        }
                    },
                    interfaces_: function() {
                        return [Qe]
                    },
                    getClass: function() {
                        return fr
                    }
                }),
                e(dr.prototype, {
                    bufferFixedPrecision: function(t) {
                        var e = new Yi(new fr(new te(1)),t.getScale())
                          , n = new sr(this.bufParams);
                        n.setWorkingPrecisionModel(t),
                        n.setNoder(e),
                        this.resultGeometry = n.buffer(this.argGeom, this.distance)
                    },
                    bufferReducedPrecision: function() {
                        if (0 === arguments.length) {
                            for (var t = dr.MAX_PRECISION_DIGITS; t >= 0; t--) {
                                try {
                                    this.bufferReducedPrecision(t)
                                } catch (t) {
                                    if (!(t instanceof rn))
                                        throw t;
                                    this.saveException = t
                                }
                                if (null !== this.resultGeometry)
                                    return null
                            }
                            throw this.saveException
                        }
                        if (1 === arguments.length) {
                            var e = arguments[0]
                              , n = dr.precisionScaleFactor(this.argGeom, this.distance, e)
                              , i = new te(n);
                            this.bufferFixedPrecision(i)
                        }
                    },
                    computeGeometry: function() {
                        if (this.bufferOriginalPrecision(),
                        null !== this.resultGeometry)
                            return null;
                        var t = this.argGeom.getFactory().getPrecisionModel();
                        t.getType() === te.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
                    },
                    setQuadrantSegments: function(t) {
                        this.bufParams.setQuadrantSegments(t)
                    },
                    bufferOriginalPrecision: function() {
                        try {
                            var t = new sr(this.bufParams);
                            this.resultGeometry = t.buffer(this.argGeom, this.distance)
                        } catch (t) {
                            if (!(t instanceof l))
                                throw t;
                            this.saveException = t
                        }
                    },
                    getResultGeometry: function(t) {
                        return this.distance = t,
                        this.computeGeometry(),
                        this.resultGeometry
                    },
                    setEndCapStyle: function(t) {
                        this.bufParams.setEndCapStyle(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return dr
                    }
                }),
                dr.bufferOp = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = new dr(t)
                          , i = n.getResultGeometry(e);
                        return i
                    }
                    if (3 === arguments.length) {
                        if (Number.isInteger(arguments[2]) && arguments[0]instanceof q && "number" == typeof arguments[1]) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = arguments[2]
                              , a = new dr(r);
                            a.setQuadrantSegments(s);
                            var i = a.getResultGeometry(o);
                            return i
                        }
                        if (arguments[2]instanceof Wi && arguments[0]instanceof q && "number" == typeof arguments[1]) {
                            var u = arguments[0]
                              , l = arguments[1]
                              , c = arguments[2]
                              , a = new dr(u,c)
                              , i = a.getResultGeometry(l);
                            return i
                        }
                    } else if (4 === arguments.length) {
                        var h = arguments[0]
                          , f = arguments[1]
                          , d = arguments[2]
                          , g = arguments[3]
                          , a = new dr(h);
                        a.setQuadrantSegments(d),
                        a.setEndCapStyle(g);
                        var i = a.getResultGeometry(f);
                        return i
                    }
                }
                ,
                dr.precisionScaleFactor = function(t, e, n) {
                    var i = t.getEnvelopeInternal()
                      , r = L.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY()))
                      , o = e > 0 ? e : 0
                      , s = r + 2 * o
                      , a = Math.trunc(Math.log(s) / Math.log(10) + 1)
                      , u = n - a;
                    return Math.pow(10, u)
                }
                ,
                dr.CAP_ROUND = Wi.CAP_ROUND,
                dr.CAP_BUTT = Wi.CAP_FLAT,
                dr.CAP_FLAT = Wi.CAP_FLAT,
                dr.CAP_SQUARE = Wi.CAP_SQUARE,
                dr.MAX_PRECISION_DIGITS = 12;
                var Ns = Object.freeze({
                    BufferOp: dr,
                    BufferParameters: Wi
                });
                e(gr.prototype, {
                    filter: function(t) {
                        t instanceof Lt && this.comps.add(t)
                    },
                    interfaces_: function() {
                        return [ct]
                    },
                    getClass: function() {
                        return gr
                    }
                }),
                gr.getPolygons = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return gr.getPolygons(t, new I)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        return e instanceof Lt ? n.add(e) : e instanceof ft && e.apply(new gr(n)),
                        n
                    }
                }
                ,
                e(pr.prototype, {
                    isInsideArea: function() {
                        return this.segIndex === pr.INSIDE_AREA
                    },
                    getCoordinate: function() {
                        return this.pt
                    },
                    getGeometryComponent: function() {
                        return this.component
                    },
                    getSegmentIndex: function() {
                        return this.segIndex
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return pr
                    }
                }),
                pr.INSIDE_AREA = -1,
                e(mr.prototype, {
                    filter: function(t) {
                        t instanceof St && this.pts.add(t)
                    },
                    interfaces_: function() {
                        return [ct]
                    },
                    getClass: function() {
                        return mr
                    }
                }),
                mr.getPoints = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return t instanceof St ? ls.singletonList(t) : mr.getPoints(t, new I)
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0]
                          , n = arguments[1];
                        return e instanceof St ? n.add(e) : e instanceof ft && e.apply(new mr(n)),
                        n
                    }
                }
                ,
                e(yr.prototype, {
                    filter: function(t) {
                        (t instanceof St || t instanceof wt || t instanceof Lt) && this.locations.add(new pr(t,0,t.getCoordinate()))
                    },
                    interfaces_: function() {
                        return [ct]
                    },
                    getClass: function() {
                        return yr
                    }
                }),
                yr.getLocations = function(t) {
                    var e = new I;
                    return t.apply(new yr(e)),
                    e
                }
                ,
                e(vr.prototype, {
                    computeContainmentDistance: function() {
                        if (0 === arguments.length) {
                            var t = new Array(2).fill(null);
                            if (this.computeContainmentDistance(0, t),
                            this.minDistance <= this.terminateDistance)
                                return null;
                            this.computeContainmentDistance(1, t)
                        } else if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1]
                              , i = 1 - e
                              , r = gr.getPolygons(this.geom[e]);
                            if (r.size() > 0) {
                                var o = yr.getLocations(this.geom[i]);
                                if (this.computeContainmentDistance(o, r, n),
                                this.minDistance <= this.terminateDistance)
                                    return this.minDistanceLocation[i] = n[0],
                                    this.minDistanceLocation[e] = n[1],
                                    null
                            }
                        } else if (3 === arguments.length)
                            if (arguments[2]instanceof Array && b(arguments[0], v) && b(arguments[1], v)) {
                                for (var s = arguments[0], a = arguments[1], u = arguments[2], l = 0; l < s.size(); l++)
                                    for (var c = s.get(l), h = 0; h < a.size(); h++)
                                        if (this.computeContainmentDistance(c, a.get(h), u),
                                        this.minDistance <= this.terminateDistance)
                                            return null
                            } else if (arguments[2]instanceof Array && arguments[0]instanceof pr && arguments[1]instanceof Lt) {
                                var f = arguments[0]
                                  , d = arguments[1]
                                  , g = arguments[2]
                                  , p = f.getCoordinate();
                                if (S.EXTERIOR !== this.ptLocator.locate(p, d))
                                    return this.minDistance = 0,
                                    g[0] = f,
                                    g[1] = new pr(d,p),
                                    null
                            }
                    },
                    computeMinDistanceLinesPoints: function(t, e, n) {
                        for (var i = 0; i < t.size(); i++)
                            for (var r = t.get(i), o = 0; o < e.size(); o++) {
                                var s = e.get(o);
                                if (this.computeMinDistance(r, s, n),
                                this.minDistance <= this.terminateDistance)
                                    return null
                            }
                    },
                    computeFacetDistance: function() {
                        var t = new Array(2).fill(null)
                          , e = Un.getLines(this.geom[0])
                          , n = Un.getLines(this.geom[1])
                          , i = mr.getPoints(this.geom[0])
                          , r = mr.getPoints(this.geom[1]);
                        return this.computeMinDistanceLines(e, n, t),
                        this.updateMinDistance(t, !1),
                        this.minDistance <= this.terminateDistance ? null : (t[0] = null,
                        t[1] = null,
                        this.computeMinDistanceLinesPoints(e, r, t),
                        this.updateMinDistance(t, !1),
                        this.minDistance <= this.terminateDistance ? null : (t[0] = null,
                        t[1] = null,
                        this.computeMinDistanceLinesPoints(n, i, t),
                        this.updateMinDistance(t, !0),
                        this.minDistance <= this.terminateDistance ? null : (t[0] = null,
                        t[1] = null,
                        this.computeMinDistancePoints(i, r, t),
                        void this.updateMinDistance(t, !1))))
                    },
                    nearestLocations: function() {
                        return this.computeMinDistance(),
                        this.minDistanceLocation
                    },
                    updateMinDistance: function(t, e) {
                        return null === t[0] ? null : void (e ? (this.minDistanceLocation[0] = t[1],
                        this.minDistanceLocation[1] = t[0]) : (this.minDistanceLocation[0] = t[0],
                        this.minDistanceLocation[1] = t[1]))
                    },
                    nearestPoints: function() {
                        return this.computeMinDistance(),
                        [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()]
                    },
                    computeMinDistance: function() {
                        if (0 === arguments.length) {
                            if (null !== this.minDistanceLocation)
                                return null;
                            if (this.minDistanceLocation = new Array(2).fill(null),
                            this.computeContainmentDistance(),
                            this.minDistance <= this.terminateDistance)
                                return null;
                            this.computeFacetDistance()
                        } else if (3 === arguments.length)
                            if (arguments[2]instanceof Array && arguments[0]instanceof wt && arguments[1]instanceof St) {
                                var t = arguments[0]
                                  , e = arguments[1]
                                  , n = arguments[2];
                                if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this.minDistance)
                                    return null;
                                for (var i = t.getCoordinates(), r = e.getCoordinate(), o = 0; o < i.length - 1; o++) {
                                    var s = le.distancePointLine(r, i[o], i[o + 1]);
                                    if (s < this.minDistance) {
                                        this.minDistance = s;
                                        var a = new ce(i[o],i[o + 1])
                                          , u = a.closestPoint(r);
                                        n[0] = new pr(t,o,u),
                                        n[1] = new pr(e,0,r)
                                    }
                                    if (this.minDistance <= this.terminateDistance)
                                        return null
                                }
                            } else if (arguments[2]instanceof Array && arguments[0]instanceof wt && arguments[1]instanceof wt) {
                                var l = arguments[0]
                                  , c = arguments[1]
                                  , h = arguments[2];
                                if (l.getEnvelopeInternal().distance(c.getEnvelopeInternal()) > this.minDistance)
                                    return null;
                                for (var i = l.getCoordinates(), f = c.getCoordinates(), o = 0; o < i.length - 1; o++)
                                    for (var d = 0; d < f.length - 1; d++) {
                                        var s = le.distanceLineLine(i[o], i[o + 1], f[d], f[d + 1]);
                                        if (s < this.minDistance) {
                                            this.minDistance = s;
                                            var g = new ce(i[o],i[o + 1])
                                              , p = new ce(f[d],f[d + 1])
                                              , m = g.closestPoints(p);
                                            h[0] = new pr(l,o,m[0]),
                                            h[1] = new pr(c,d,m[1])
                                        }
                                        if (this.minDistance <= this.terminateDistance)
                                            return null
                                    }
                            }
                    },
                    computeMinDistancePoints: function(t, e, n) {
                        for (var i = 0; i < t.size(); i++)
                            for (var r = t.get(i), o = 0; o < e.size(); o++) {
                                var s = e.get(o)
                                  , a = r.getCoordinate().distance(s.getCoordinate());
                                if (a < this.minDistance && (this.minDistance = a,
                                n[0] = new pr(r,0,r.getCoordinate()),
                                n[1] = new pr(s,0,s.getCoordinate())),
                                this.minDistance <= this.terminateDistance)
                                    return null
                            }
                    },
                    distance: function() {
                        if (null === this.geom[0] || null === this.geom[1])
                            throw new i("null geometries are not supported");
                        return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(),
                        this.minDistance)
                    },
                    computeMinDistanceLines: function(t, e, n) {
                        for (var i = 0; i < t.size(); i++)
                            for (var r = t.get(i), o = 0; o < e.size(); o++) {
                                var s = e.get(o);
                                if (this.computeMinDistance(r, s, n),
                                this.minDistance <= this.terminateDistance)
                                    return null
                            }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return vr
                    }
                }),
                vr.distance = function(t, e) {
                    return new vr(t,e).distance()
                }
                ,
                vr.isWithinDistance = function(t, e, n) {
                    return new vr(t,e,n).distance() <= n
                }
                ,
                vr.nearestPoints = function(t, e) {
                    return new vr(t,e).nearestPoints()
                }
                ;
                var Cs = Object.freeze({
                    DistanceOp: vr
                });
                e(Er.prototype, {
                    getCoordinates: function() {
                        if (null === this.coordinates) {
                            for (var t = 0, e = 0, n = new N, i = this.directedEdges.iterator(); i.hasNext(); ) {
                                var r = i.next();
                                r.getEdgeDirection() ? t++ : e++,
                                n.add(r.getEdge().getLine().getCoordinates(), !1, r.getEdgeDirection())
                            }
                            this.coordinates = n.toCoordinateArray(),
                            e > t && X.reverse(this.coordinates)
                        }
                        return this.coordinates
                    },
                    toLineString: function() {
                        return this.factory.createLineString(this.getCoordinates())
                    },
                    add: function(t) {
                        this.directedEdges.add(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Er
                    }
                }),
                e(xr.prototype, {
                    setVisited: function(t) {
                        this._isVisited = t
                    },
                    isMarked: function() {
                        return this._isMarked
                    },
                    setData: function(t) {
                        this.data = t
                    },
                    getData: function() {
                        return this.data
                    },
                    setMarked: function(t) {
                        this._isMarked = t
                    },
                    getContext: function() {
                        return this.data
                    },
                    isVisited: function() {
                        return this._isVisited
                    },
                    setContext: function(t) {
                        this.data = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return xr
                    }
                }),
                xr.getComponentWithVisitedState = function(t, e) {
                    for (; t.hasNext(); ) {
                        var n = t.next();
                        if (n.isVisited() === e)
                            return n
                    }
                    return null
                }
                ,
                xr.setVisited = function(t, e) {
                    for (; t.hasNext(); ) {
                        t.next().setVisited(e)
                    }
                }
                ,
                xr.setMarked = function(t, e) {
                    for (; t.hasNext(); ) {
                        t.next().setMarked(e)
                    }
                }
                ,
                c(Ir, xr),
                e(Ir.prototype, {
                    isRemoved: function() {
                        return null === this.parentEdge
                    },
                    compareDirection: function(t) {
                        return this.quadrant > t.quadrant ? 1 : this.quadrant < t.quadrant ? -1 : le.computeOrientation(t.p0, t.p1, this.p1)
                    },
                    getCoordinate: function() {
                        return this.from.getCoordinate()
                    },
                    print: function(t) {
                        var e = this.getClass().getName()
                          , n = e.lastIndexOf(".")
                          , i = e.substring(n + 1);
                        t.print("  " + i + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + this.angle)
                    },
                    getDirectionPt: function() {
                        return this.p1
                    },
                    getAngle: function() {
                        return this.angle
                    },
                    compareTo: function(t) {
                        var e = t;
                        return this.compareDirection(e)
                    },
                    getFromNode: function() {
                        return this.from
                    },
                    getSym: function() {
                        return this.sym
                    },
                    setEdge: function(t) {
                        this.parentEdge = t
                    },
                    remove: function() {
                        this.sym = null,
                        this.parentEdge = null
                    },
                    getEdge: function() {
                        return this.parentEdge
                    },
                    getQuadrant: function() {
                        return this.quadrant
                    },
                    setSym: function(t) {
                        this.sym = t
                    },
                    getToNode: function() {
                        return this.to
                    },
                    getEdgeDirection: function() {
                        return this.edgeDirection
                    },
                    interfaces_: function() {
                        return [o]
                    },
                    getClass: function() {
                        return Ir
                    }
                }),
                Ir.toEdges = function(t) {
                    for (var e = new I, n = t.iterator(); n.hasNext(); )
                        e.add(n.next().parentEdge);
                    return e
                }
                ,
                c(Nr, Ir),
                e(Nr.prototype, {
                    getNext: function() {
                        return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) === this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (f.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()),
                        this.getToNode().getOutEdges().getEdges().get(0))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Nr
                    }
                }),
                c(Cr, xr),
                e(Cr.prototype, {
                    isRemoved: function() {
                        return null === this.dirEdge
                    },
                    setDirectedEdges: function(t, e) {
                        this.dirEdge = [t, e],
                        t.setEdge(this),
                        e.setEdge(this),
                        t.setSym(e),
                        e.setSym(t),
                        t.getFromNode().addOutEdge(t),
                        e.getFromNode().addOutEdge(e)
                    },
                    getDirEdge: function() {
                        if (Number.isInteger(arguments[0])) {
                            var t = arguments[0];
                            return this.dirEdge[t]
                        }
                        if (arguments[0]instanceof _r) {
                            var e = arguments[0];
                            return this.dirEdge[0].getFromNode() === e ? this.dirEdge[0] : this.dirEdge[1].getFromNode() === e ? this.dirEdge[1] : null
                        }
                    },
                    remove: function() {
                        this.dirEdge = null
                    },
                    getOppositeNode: function(t) {
                        return this.dirEdge[0].getFromNode() === t ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() === t ? this.dirEdge[1].getToNode() : null
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Cr
                    }
                }),
                e(wr.prototype, {
                    getNextEdge: function(t) {
                        var e = this.getIndex(t);
                        return this.outEdges.get(this.getIndex(e + 1))
                    },
                    getCoordinate: function() {
                        var t = this.iterator();
                        return t.hasNext() ? t.next().getCoordinate() : null
                    },
                    iterator: function() {
                        return this.sortEdges(),
                        this.outEdges.iterator()
                    },
                    sortEdges: function() {
                        this.sorted || (ls.sort(this.outEdges),
                        this.sorted = !0)
                    },
                    remove: function(t) {
                        this.outEdges.remove(t)
                    },
                    getEdges: function() {
                        return this.sortEdges(),
                        this.outEdges
                    },
                    getNextCWEdge: function(t) {
                        var e = this.getIndex(t);
                        return this.outEdges.get(this.getIndex(e - 1))
                    },
                    getIndex: function() {
                        if (arguments[0]instanceof Cr) {
                            var t = arguments[0];
                            this.sortEdges();
                            for (var e = 0; e < this.outEdges.size(); e++) {
                                var n = this.outEdges.get(e);
                                if (n.getEdge() === t)
                                    return e
                            }
                            return -1
                        }
                        if (arguments[0]instanceof Ir) {
                            var i = arguments[0];
                            this.sortEdges();
                            for (var e = 0; e < this.outEdges.size(); e++) {
                                var n = this.outEdges.get(e);
                                if (n === i)
                                    return e
                            }
                            return -1
                        }
                        if (Number.isInteger(arguments[0])) {
                            var r = arguments[0]
                              , o = r % this.outEdges.size();
                            return o < 0 && (o += this.outEdges.size()),
                            o
                        }
                    },
                    add: function(t) {
                        this.outEdges.add(t),
                        this.sorted = !1
                    },
                    getDegree: function() {
                        return this.outEdges.size()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return wr
                    }
                }),
                c(_r, xr),
                e(_r.prototype, {
                    isRemoved: function() {
                        return null === this.pt
                    },
                    addOutEdge: function(t) {
                        this.deStar.add(t)
                    },
                    getCoordinate: function() {
                        return this.pt
                    },
                    getOutEdges: function() {
                        return this.deStar
                    },
                    remove: function() {
                        if (0 === arguments.length)
                            this.pt = null;
                        else if (1 === arguments.length) {
                            var t = arguments[0];
                            this.deStar.remove(t)
                        }
                    },
                    getIndex: function(t) {
                        return this.deStar.getIndex(t)
                    },
                    getDegree: function() {
                        return this.deStar.getDegree()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return _r
                    }
                }),
                _r.getEdgesBetween = function(t, e) {
                    var n = Ir.toEdges(t.getOutEdges().getEdges())
                      , i = new Z(n)
                      , r = Ir.toEdges(e.getOutEdges().getEdges());
                    return i.retainAll(r),
                    i
                }
                ,
                c(Sr, Cr),
                e(Sr.prototype, {
                    getLine: function() {
                        return this.line
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Sr
                    }
                }),
                e(br.prototype, {
                    find: function(t) {
                        return this.nodeMap.get(t)
                    },
                    iterator: function() {
                        return this.nodeMap.values().iterator()
                    },
                    remove: function(t) {
                        return this.nodeMap.remove(t)
                    },
                    values: function() {
                        return this.nodeMap.values()
                    },
                    add: function(t) {
                        return this.nodeMap.put(t.getCoordinate(), t),
                        t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return br
                    }
                }),
                e(Lr.prototype, {
                    findNodesOfDegree: function(t) {
                        for (var e = new I, n = this.nodeIterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.getDegree() === t && e.add(i)
                        }
                        return e
                    },
                    dirEdgeIterator: function() {
                        return this.dirEdges.iterator()
                    },
                    edgeIterator: function() {
                        return this.edges.iterator()
                    },
                    remove: function() {
                        if (arguments[0]instanceof Cr) {
                            var t = arguments[0];
                            this.remove(t.getDirEdge(0)),
                            this.remove(t.getDirEdge(1)),
                            this.edges.remove(t),
                            t.remove()
                        } else if (arguments[0]instanceof Ir) {
                            var e = arguments[0]
                              , n = e.getSym();
                            null !== n && n.setSym(null),
                            e.getFromNode().remove(e),
                            e.remove(),
                            this.dirEdges.remove(e)
                        } else if (arguments[0]instanceof _r) {
                            for (var i = arguments[0], r = i.getOutEdges().getEdges(), o = r.iterator(); o.hasNext(); ) {
                                var s = o.next()
                                  , n = s.getSym();
                                null !== n && this.remove(n),
                                this.dirEdges.remove(s);
                                var a = s.getEdge();
                                null !== a && this.edges.remove(a)
                            }
                            this.nodeMap.remove(i.getCoordinate()),
                            i.remove()
                        }
                    },
                    findNode: function(t) {
                        return this.nodeMap.find(t)
                    },
                    getEdges: function() {
                        return this.edges
                    },
                    nodeIterator: function() {
                        return this.nodeMap.iterator()
                    },
                    contains: function() {
                        if (arguments[0]instanceof Cr) {
                            var t = arguments[0];
                            return this.edges.contains(t)
                        }
                        if (arguments[0]instanceof Ir) {
                            var e = arguments[0];
                            return this.dirEdges.contains(e)
                        }
                    },
                    add: function() {
                        if (arguments[0]instanceof _r) {
                            var t = arguments[0];
                            this.nodeMap.add(t)
                        } else if (arguments[0]instanceof Cr) {
                            var e = arguments[0];
                            this.edges.add(e),
                            this.add(e.getDirEdge(0)),
                            this.add(e.getDirEdge(1))
                        } else if (arguments[0]instanceof Ir) {
                            var n = arguments[0];
                            this.dirEdges.add(n)
                        }
                    },
                    getNodes: function() {
                        return this.nodeMap.values()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Lr
                    }
                }),
                c(Tr, Lr),
                e(Tr.prototype, {
                    addEdge: function(t) {
                        if (t.isEmpty())
                            return null;
                        var e = X.removeRepeatedPoints(t.getCoordinates());
                        if (e.length <= 1)
                            return null;
                        var n = e[0]
                          , i = e[e.length - 1]
                          , r = this.getNode(n)
                          , o = this.getNode(i)
                          , s = new Nr(r,o,e[1],!0)
                          , a = new Nr(o,r,e[e.length - 2],!1)
                          , u = new Sr(t);
                        u.setDirectedEdges(s, a),
                        this.add(u)
                    },
                    getNode: function(t) {
                        var e = this.findNode(t);
                        return null === e && (e = new _r(t),
                        this.add(e)),
                        e
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Tr
                    }
                }),
                e(Rr.prototype, {
                    buildEdgeStringsForUnprocessedNodes: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext(); ) {
                            var e = t.next();
                            e.isMarked() || (f.isTrue(2 === e.getDegree()),
                            this.buildEdgeStringsStartingAt(e),
                            e.setMarked(!0))
                        }
                    },
                    buildEdgeStringsForNonDegree2Nodes: function() {
                        for (var t = this.graph.getNodes().iterator(); t.hasNext(); ) {
                            var e = t.next();
                            2 !== e.getDegree() && (this.buildEdgeStringsStartingAt(e),
                            e.setMarked(!0))
                        }
                    },
                    buildEdgeStringsForObviousStartNodes: function() {
                        this.buildEdgeStringsForNonDegree2Nodes()
                    },
                    getMergedLineStrings: function() {
                        return this.merge(),
                        this.mergedLineStrings
                    },
                    buildEdgeStringsStartingAt: function(t) {
                        for (var e = t.getOutEdges().iterator(); e.hasNext(); ) {
                            var n = e.next();
                            n.getEdge().isMarked() || this.edgeStrings.add(this.buildEdgeStringStartingWith(n))
                        }
                    },
                    merge: function() {
                        if (null !== this.mergedLineStrings)
                            return null;
                        xr.setMarked(this.graph.nodeIterator(), !1),
                        xr.setMarked(this.graph.edgeIterator(), !1),
                        this.edgeStrings = new I,
                        this.buildEdgeStringsForObviousStartNodes(),
                        this.buildEdgeStringsForIsolatedLoops(),
                        this.mergedLineStrings = new I;
                        for (var t = this.edgeStrings.iterator(); t.hasNext(); ) {
                            var e = t.next();
                            this.mergedLineStrings.add(e.toLineString())
                        }
                    },
                    buildEdgeStringStartingWith: function(t) {
                        var e = new Er(this.factory)
                          , n = t;
                        do {
                            e.add(n),
                            n.getEdge().setMarked(!0),
                            n = n.getNext()
                        } while (null !== n && n !== t);return e
                    },
                    add: function() {
                        if (arguments[0]instanceof q) {
                            arguments[0].apply({
                                interfaces_: function() {
                                    return [k]
                                },
                                filter: function(t) {
                                    t instanceof wt && this.add(t)
                                }
                            })
                        } else if (b(arguments[0], m)) {
                            var t = arguments[0];
                            this.mergedLineStrings = null;
                            for (var e = t.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.add(n)
                            }
                        } else if (arguments[0]instanceof wt) {
                            var i = arguments[0];
                            null === this.factory && (this.factory = i.getFactory()),
                            this.graph.addEdge(i)
                        }
                    },
                    buildEdgeStringsForIsolatedLoops: function() {
                        this.buildEdgeStringsForUnprocessedNodes()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Rr
                    }
                });
                var ws = Object.freeze({
                    LineMerger: Rr
                })
                  , _s = Object.freeze({
                    OverlayOp: ni
                });
                c(Or, Ir),
                e(Or.prototype, {
                    getNext: function() {
                        return this.next
                    },
                    isInRing: function() {
                        return null !== this.edgeRing
                    },
                    setRing: function(t) {
                        this.edgeRing = t
                    },
                    setLabel: function(t) {
                        this.label = t
                    },
                    getLabel: function() {
                        return this.label
                    },
                    setNext: function(t) {
                        this.next = t
                    },
                    getRing: function() {
                        return this.edgeRing
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Or
                    }
                }),
                c(Pr, Cr),
                e(Pr.prototype, {
                    getLine: function() {
                        return this.line
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Pr
                    }
                }),
                e(Mr.prototype, {
                    visitInteriorRing: function(t, e) {
                        var n = t.getCoordinates()
                          , i = n[0]
                          , r = Mr.findDifferentPoint(n, i)
                          , o = e.findEdgeInSameDirection(i, r)
                          , s = e.findEdgeEnd(o)
                          , a = null;
                        s.getLabel().getLocation(0, cn.RIGHT) === S.INTERIOR ? a = s : s.getSym().getLabel().getLocation(0, cn.RIGHT) === S.INTERIOR && (a = s.getSym()),
                        f.isTrue(null !== a, "unable to find dirEdge with Interior on RHS"),
                        this.visitLinkedDirectedEdges(a)
                    },
                    visitShellInteriors: function(t, e) {
                        if (t instanceof Lt) {
                            var n = t;
                            this.visitInteriorRing(n.getExteriorRing(), e)
                        }
                        if (t instanceof Ot)
                            for (var i = t, r = 0; r < i.getNumGeometries(); r++) {
                                var n = i.getGeometryN(r);
                                this.visitInteriorRing(n.getExteriorRing(), e)
                            }
                    },
                    getCoordinate: function() {
                        return this.disconnectedRingcoord
                    },
                    setInteriorEdgesInResult: function(t) {
                        for (var e = t.getEdgeEnds().iterator(); e.hasNext(); ) {
                            var n = e.next();
                            n.getLabel().getLocation(0, cn.RIGHT) === S.INTERIOR && n.setInResult(!0)
                        }
                    },
                    visitLinkedDirectedEdges: function(t) {
                        var e = t
                          , n = t;
                        do {
                            f.isTrue(null !== n, "found null Directed Edge"),
                            n.setVisited(!0),
                            n = n.getNext()
                        } while (n !== e)
                    },
                    buildEdgeRings: function(t) {
                        for (var e = new I, n = t.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (i.isInResult() && null === i.getEdgeRing()) {
                                var r = new pn(i,this.geometryFactory);
                                r.linkDirectedEdgesForMinimalEdgeRings();
                                var o = r.buildMinimalRings();
                                e.addAll(o)
                            }
                        }
                        return e
                    },
                    hasUnvisitedShellEdge: function(t) {
                        for (var e = 0; e < t.size(); e++) {
                            var n = t.get(e);
                            if (!n.isHole()) {
                                var i = n.getEdges()
                                  , r = i.get(0);
                                if (r.getLabel().getLocation(0, cn.RIGHT) === S.INTERIOR)
                                    for (var o = 0; o < i.size(); o++)
                                        if (r = i.get(o),
                                        !r.isVisited())
                                            return this.disconnectedRingcoord = r.getCoordinate(),
                                            !0
                            }
                        }
                        return !1
                    },
                    isInteriorsConnected: function() {
                        var t = new I;
                        this.geomGraph.computeSplitEdges(t);
                        var e = new Nn(new Rn);
                        e.addEdges(t),
                        this.setInteriorEdgesInResult(e),
                        e.linkResultDirectedEdges();
                        var n = this.buildEdgeRings(e.getEdgeEnds());
                        return this.visitShellInteriors(this.geomGraph.getGeometry(), e),
                        !this.hasUnvisitedShellEdge(n)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Mr
                    }
                }),
                Mr.findDifferentPoint = function(t, e) {
                    for (var n = 0; n < t.length; n++)
                        if (!t[n].equals(e))
                            return t[n];
                    return null
                }
                ,
                e(Ar.prototype, {
                    createEdgeEndForNext: function(t, e, n, i) {
                        var r = n.segmentIndex + 1;
                        if (r >= t.getNumPoints() && null === i)
                            return null;
                        var o = t.getCoordinate(r);
                        null !== i && i.segmentIndex === n.segmentIndex && (o = i.coord);
                        var s = new En(t,n.coord,o,new fn(t.getLabel()));
                        e.add(s)
                    },
                    createEdgeEndForPrev: function(t, e, n, i) {
                        var r = n.segmentIndex;
                        if (0 === n.dist) {
                            if (0 === r)
                                return null;
                            r--
                        }
                        var o = t.getCoordinate(r);
                        null !== i && i.segmentIndex >= r && (o = i.coord);
                        var s = new fn(t.getLabel());
                        s.flip();
                        var a = new En(t,n.coord,o,s);
                        e.add(a)
                    },
                    computeEdgeEnds: function() {
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = new I, n = t; n.hasNext(); ) {
                                var i = n.next();
                                this.computeEdgeEnds(i, e)
                            }
                            return e
                        }
                        if (2 === arguments.length) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = r.getEdgeIntersectionList();
                            s.addEndpoints();
                            var a = s.iterator()
                              , u = null
                              , l = null;
                            if (!a.hasNext())
                                return null;
                            var c = a.next();
                            do {
                                u = l,
                                l = c,
                                c = null,
                                a.hasNext() && (c = a.next()),
                                null !== l && (this.createEdgeEndForPrev(r, o, l, u),
                                this.createEdgeEndForNext(r, o, l, c))
                            } while (null !== l)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ar
                    }
                }),
                c(Dr, En),
                e(Dr.prototype, {
                    insert: function(t) {
                        this.edgeEnds.add(t)
                    },
                    print: function(t) {
                        t.println("EdgeEndBundle--\x3e Label: " + this.label);
                        for (var e = this.iterator(); e.hasNext(); ) {
                            e.next().print(t),
                            t.println()
                        }
                    },
                    iterator: function() {
                        return this.edgeEnds.iterator()
                    },
                    getEdgeEnds: function() {
                        return this.edgeEnds
                    },
                    computeLabelOn: function(t, e) {
                        for (var n = 0, i = !1, r = this.iterator(); r.hasNext(); ) {
                            var o = r.next()
                              , s = o.getLabel().getLocation(t);
                            s === S.BOUNDARY && n++,
                            s === S.INTERIOR && (i = !0)
                        }
                        var s = S.NONE;
                        i && (s = S.INTERIOR),
                        n > 0 && (s = Zn.determineBoundary(e, n)),
                        this.label.setLocation(t, s)
                    },
                    computeLabelSide: function(t, e) {
                        for (var n = this.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (i.getLabel().isArea()) {
                                var r = i.getLabel().getLocation(t, e);
                                if (r === S.INTERIOR)
                                    return this.label.setLocation(t, e, S.INTERIOR),
                                    null;
                                r === S.EXTERIOR && this.label.setLocation(t, e, S.EXTERIOR)
                            }
                        }
                    },
                    getLabel: function() {
                        return this.label
                    },
                    computeLabelSides: function(t) {
                        this.computeLabelSide(t, cn.LEFT),
                        this.computeLabelSide(t, cn.RIGHT)
                    },
                    updateIM: function(t) {
                        Kn.updateIM(this.label, t)
                    },
                    computeLabel: function(t) {
                        for (var e = !1, n = this.iterator(); n.hasNext(); ) {
                            n.next().getLabel().isArea() && (e = !0)
                        }
                        this.label = e ? new fn(S.NONE,S.NONE,S.NONE) : new fn(S.NONE);
                        for (var i = 0; i < 2; i++)
                            this.computeLabelOn(i, t),
                            e && this.computeLabelSides(i)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Dr
                    }
                }),
                c(Fr, Ln),
                e(Fr.prototype, {
                    updateIM: function(t) {
                        for (var e = this.iterator(); e.hasNext(); ) {
                            e.next().updateIM(t)
                        }
                    },
                    insert: function(t) {
                        var e = this.edgeMap.get(t);
                        null === e ? (e = new Dr(t),
                        this.insertEdgeEnd(t, e)) : e.insert(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Fr
                    }
                }),
                c(Gr, yn),
                e(Gr.prototype, {
                    updateIMFromEdges: function(t) {
                        this.edges.updateIM(t)
                    },
                    computeIM: function(t) {
                        t.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Gr
                    }
                }),
                c(kr, In),
                e(kr.prototype, {
                    createNode: function(t) {
                        return new Gr(t,new Fr)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return kr
                    }
                }),
                e(qr.prototype, {
                    insertEdgeEnds: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.nodes.add(n)
                        }
                    },
                    getNodeIterator: function() {
                        return this.nodes.iterator()
                    },
                    copyNodesAndLabels: function(t, e) {
                        for (var n = t.getNodeIterator(); n.hasNext(); ) {
                            var i = n.next();
                            this.nodes.addNode(i.getCoordinate()).setLabel(e, i.getLabel().getLocation(e))
                        }
                    },
                    build: function(t) {
                        this.computeIntersectionNodes(t, 0),
                        this.copyNodesAndLabels(t, 0);
                        var e = new Ar
                          , n = e.computeEdgeEnds(t.getEdgeIterator());
                        this.insertEdgeEnds(n)
                    },
                    computeIntersectionNodes: function(t, e) {
                        for (var n = t.getEdgeIterator(); n.hasNext(); )
                            for (var i = n.next(), r = i.getLabel().getLocation(e), o = i.getEdgeIntersectionList().iterator(); o.hasNext(); ) {
                                var s = o.next()
                                  , a = this.nodes.addNode(s.coord);
                                r === S.BOUNDARY ? a.setLabelBoundary(e) : a.getLabel().isNull(e) && a.setLabel(e, S.INTERIOR)
                            }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return qr
                    }
                }),
                e(Br.prototype, {
                    isNodeEdgeAreaLabelsConsistent: function() {
                        for (var t = this.nodeGraph.getNodeIterator(); t.hasNext(); ) {
                            var e = t.next();
                            if (!e.getEdges().isAreaLabelsConsistent(this.geomGraph))
                                return this.invalidPoint = e.getCoordinate().copy(),
                                !1
                        }
                        return !0
                    },
                    getInvalidPoint: function() {
                        return this.invalidPoint
                    },
                    hasDuplicateRings: function() {
                        for (var t = this.nodeGraph.getNodeIterator(); t.hasNext(); )
                            for (var e = t.next(), n = e.getEdges().iterator(); n.hasNext(); ) {
                                var i = n.next();
                                if (i.getEdgeEnds().size() > 1)
                                    return this.invalidPoint = i.getEdge().getCoordinate(0),
                                    !0
                            }
                        return !1
                    },
                    isNodeConsistentArea: function() {
                        var t = this.geomGraph.computeSelfNodes(this.li, !0, !0);
                        return t.hasProperIntersection() ? (this.invalidPoint = t.getProperIntersectionPoint(),
                        !1) : (this.nodeGraph.build(this.geomGraph),
                        this.isNodeEdgeAreaLabelsConsistent())
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Br
                    }
                }),
                e(Ur.prototype, {
                    buildIndex: function() {
                        this.index = new Ue;
                        for (var t = 0; t < this.rings.size(); t++) {
                            var e = this.rings.get(t)
                              , n = e.getEnvelopeInternal();
                            this.index.insert(n, e)
                        }
                    },
                    getNestedPoint: function() {
                        return this.nestedPt
                    },
                    isNonNested: function() {
                        this.buildIndex();
                        for (var t = 0; t < this.rings.size(); t++)
                            for (var e = this.rings.get(t), n = e.getCoordinates(), i = this.index.query(e.getEnvelopeInternal()), r = 0; r < i.size(); r++) {
                                var o = i.get(r)
                                  , s = o.getCoordinates();
                                if (e !== o && e.getEnvelopeInternal().intersects(o.getEnvelopeInternal())) {
                                    var a = zr.findPtNotNode(n, o, this.graph);
                                    if (null !== a) {
                                        var u = le.isPointInRing(a, s);
                                        if (u)
                                            return this.nestedPt = a,
                                            !1
                                    }
                                }
                            }
                        return !0
                    },
                    add: function(t) {
                        this.rings.add(t),
                        this.totalEnv.expandToInclude(t.getEnvelopeInternal())
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ur
                    }
                }),
                e(Vr.prototype, {
                    getErrorType: function() {
                        return this.errorType
                    },
                    getMessage: function() {
                        return Vr.errMsg[this.errorType]
                    },
                    getCoordinate: function() {
                        return this.pt
                    },
                    toString: function() {
                        var t = "";
                        return null !== this.pt && (t = " at or near point " + this.pt),
                        this.getMessage() + t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Vr
                    }
                }),
                Vr.ERROR = 0,
                Vr.REPEATED_POINT = 1,
                Vr.HOLE_OUTSIDE_SHELL = 2,
                Vr.NESTED_HOLES = 3,
                Vr.DISCONNECTED_INTERIOR = 4,
                Vr.SELF_INTERSECTION = 5,
                Vr.RING_SELF_INTERSECTION = 6,
                Vr.NESTED_SHELLS = 7,
                Vr.DUPLICATE_RINGS = 8,
                Vr.TOO_FEW_POINTS = 9,
                Vr.INVALID_COORDINATE = 10,
                Vr.RING_NOT_CLOSED = 11,
                Vr.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"],
                e(zr.prototype, {
                    checkInvalidCoordinates: function() {
                        if (arguments[0]instanceof Array) {
                            for (var t = arguments[0], e = 0; e < t.length; e++)
                                if (!zr.isValid(t[e]))
                                    return this.validErr = new Vr(Vr.INVALID_COORDINATE,t[e]),
                                    null
                        } else if (arguments[0]instanceof Lt) {
                            var n = arguments[0];
                            if (this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()),
                            null !== this.validErr)
                                return null;
                            for (var e = 0; e < n.getNumInteriorRing(); e++)
                                if (this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()),
                                null !== this.validErr)
                                    return null
                        }
                    },
                    checkHolesNotNested: function(t, e) {
                        for (var n = new Ur(e), i = 0; i < t.getNumInteriorRing(); i++) {
                            var r = t.getInteriorRingN(i);
                            n.add(r)
                        }
                        n.isNonNested() || (this.validErr = new Vr(Vr.NESTED_HOLES,n.getNestedPoint()))
                    },
                    checkConsistentArea: function(t) {
                        var e = new Br(t);
                        return e.isNodeConsistentArea() ? void (e.hasDuplicateRings() && (this.validErr = new Vr(Vr.DUPLICATE_RINGS,e.getInvalidPoint()))) : (this.validErr = new Vr(Vr.SELF_INTERSECTION,e.getInvalidPoint()),
                        null)
                    },
                    isValid: function() {
                        return this.checkValid(this.parentGeometry),
                        null === this.validErr
                    },
                    checkShellInsideHole: function(t, e, n) {
                        var i = t.getCoordinates()
                          , r = e.getCoordinates()
                          , o = zr.findPtNotNode(i, e, n);
                        if (null !== o) {
                            if (!le.isPointInRing(o, r))
                                return o
                        }
                        var s = zr.findPtNotNode(r, t, n);
                        if (null !== s) {
                            return le.isPointInRing(s, i) ? s : null
                        }
                        return f.shouldNeverReachHere("points in shell and hole appear to be equal"),
                        null
                    },
                    checkNoSelfIntersectingRings: function(t) {
                        for (var e = t.getEdgeIterator(); e.hasNext(); ) {
                            var n = e.next();
                            if (this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()),
                            null !== this.validErr)
                                return null
                        }
                    },
                    checkConnectedInteriors: function(t) {
                        var e = new Mr(t);
                        e.isInteriorsConnected() || (this.validErr = new Vr(Vr.DISCONNECTED_INTERIOR,e.getCoordinate()))
                    },
                    checkNoSelfIntersectingRing: function(t) {
                        for (var e = new at, n = !0, i = t.iterator(); i.hasNext(); ) {
                            var r = i.next();
                            if (n)
                                n = !1;
                            else {
                                if (e.contains(r.coord))
                                    return this.validErr = new Vr(Vr.RING_SELF_INTERSECTION,r.coord),
                                    null;
                                e.add(r.coord)
                            }
                        }
                    },
                    checkHolesInShell: function(t, e) {
                        for (var n = t.getExteriorRing(), i = new xi(n), r = 0; r < t.getNumInteriorRing(); r++) {
                            var o = t.getInteriorRingN(r)
                              , s = zr.findPtNotNode(o.getCoordinates(), n, e);
                            if (null === s)
                                return null;
                            if (!i.isInside(s))
                                return this.validErr = new Vr(Vr.HOLE_OUTSIDE_SHELL,s),
                                null
                        }
                    },
                    checkTooFewPoints: function(t) {
                        if (t.hasTooFewPoints())
                            return this.validErr = new Vr(Vr.TOO_FEW_POINTS,t.getInvalidPoint()),
                            null
                    },
                    getValidationError: function() {
                        return this.checkValid(this.parentGeometry),
                        this.validErr
                    },
                    checkValid: function() {
                        if (arguments[0]instanceof St) {
                            var t = arguments[0];
                            this.checkInvalidCoordinates(t.getCoordinates())
                        } else if (arguments[0]instanceof Tt) {
                            var e = arguments[0];
                            this.checkInvalidCoordinates(e.getCoordinates())
                        } else if (arguments[0]instanceof Rt) {
                            var n = arguments[0];
                            if (this.checkInvalidCoordinates(n.getCoordinates()),
                            null !== this.validErr)
                                return null;
                            if (this.checkClosedRing(n),
                            null !== this.validErr)
                                return null;
                            var i = new Zn(0,n);
                            if (this.checkTooFewPoints(i),
                            null !== this.validErr)
                                return null;
                            var r = new se;
                            i.computeSelfNodes(r, !0, !0),
                            this.checkNoSelfIntersectingRings(i)
                        } else if (arguments[0]instanceof wt) {
                            var o = arguments[0];
                            if (this.checkInvalidCoordinates(o.getCoordinates()),
                            null !== this.validErr)
                                return null;
                            var i = new Zn(0,o);
                            this.checkTooFewPoints(i)
                        } else if (arguments[0]instanceof Lt) {
                            var s = arguments[0];
                            if (this.checkInvalidCoordinates(s),
                            null !== this.validErr)
                                return null;
                            if (this.checkClosedRings(s),
                            null !== this.validErr)
                                return null;
                            var i = new Zn(0,s);
                            if (this.checkTooFewPoints(i),
                            null !== this.validErr)
                                return null;
                            if (this.checkConsistentArea(i),
                            null !== this.validErr)
                                return null;
                            if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i),
                            null !== this.validErr))
                                return null;
                            if (this.checkHolesInShell(s, i),
                            null !== this.validErr)
                                return null;
                            if (this.checkHolesNotNested(s, i),
                            null !== this.validErr)
                                return null;
                            this.checkConnectedInteriors(i)
                        } else if (arguments[0]instanceof Ot) {
                            for (var a = arguments[0], u = 0; u < a.getNumGeometries(); u++) {
                                var l = a.getGeometryN(u);
                                if (this.checkInvalidCoordinates(l),
                                null !== this.validErr)
                                    return null;
                                if (this.checkClosedRings(l),
                                null !== this.validErr)
                                    return null
                            }
                            var i = new Zn(0,a);
                            if (this.checkTooFewPoints(i),
                            null !== this.validErr)
                                return null;
                            if (this.checkConsistentArea(i),
                            null !== this.validErr)
                                return null;
                            if (!this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(i),
                            null !== this.validErr))
                                return null;
                            for (var u = 0; u < a.getNumGeometries(); u++) {
                                var l = a.getGeometryN(u);
                                if (this.checkHolesInShell(l, i),
                                null !== this.validErr)
                                    return null
                            }
                            for (var u = 0; u < a.getNumGeometries(); u++) {
                                var l = a.getGeometryN(u);
                                if (this.checkHolesNotNested(l, i),
                                null !== this.validErr)
                                    return null
                            }
                            if (this.checkShellsNotNested(a, i),
                            null !== this.validErr)
                                return null;
                            this.checkConnectedInteriors(i)
                        } else if (arguments[0]instanceof ft)
                            for (var c = arguments[0], u = 0; u < c.getNumGeometries(); u++) {
                                var h = c.getGeometryN(u);
                                if (this.checkValid(h),
                                null !== this.validErr)
                                    return null
                            }
                        else if (arguments[0]instanceof q) {
                            var f = arguments[0];
                            if (this.validErr = null,
                            f.isEmpty())
                                return null;
                            if (f instanceof St)
                                this.checkValid(f);
                            else if (f instanceof Tt)
                                this.checkValid(f);
                            else if (f instanceof Rt)
                                this.checkValid(f);
                            else if (f instanceof wt)
                                this.checkValid(f);
                            else if (f instanceof Lt)
                                this.checkValid(f);
                            else if (f instanceof Ot)
                                this.checkValid(f);
                            else {
                                if (!(f instanceof ft))
                                    throw new UnsupportedOperationException(f.getClass().getName());
                                this.checkValid(f)
                            }
                        }
                    },
                    setSelfTouchingRingFormingHoleValid: function(t) {
                        this.isSelfTouchingRingFormingHoleValid = t
                    },
                    checkShellNotNested: function(t, e, n) {
                        var i = t.getCoordinates()
                          , r = e.getExteriorRing()
                          , o = r.getCoordinates()
                          , s = zr.findPtNotNode(i, r, n);
                        if (null === s)
                            return null;
                        if (!le.isPointInRing(s, o))
                            return null;
                        if (e.getNumInteriorRing() <= 0)
                            return this.validErr = new Vr(Vr.NESTED_SHELLS,s),
                            null;
                        for (var a = null, u = 0; u < e.getNumInteriorRing(); u++) {
                            var l = e.getInteriorRingN(u);
                            if (null === (a = this.checkShellInsideHole(t, l, n)))
                                return null
                        }
                        this.validErr = new Vr(Vr.NESTED_SHELLS,a)
                    },
                    checkClosedRings: function(t) {
                        if (this.checkClosedRing(t.getExteriorRing()),
                        null !== this.validErr)
                            return null;
                        for (var e = 0; e < t.getNumInteriorRing(); e++)
                            if (this.checkClosedRing(t.getInteriorRingN(e)),
                            null !== this.validErr)
                                return null
                    },
                    checkClosedRing: function(t) {
                        if (!t.isClosed()) {
                            var e = null;
                            t.getNumPoints() >= 1 && (e = t.getCoordinateN(0)),
                            this.validErr = new Vr(Vr.RING_NOT_CLOSED,e)
                        }
                    },
                    checkShellsNotNested: function(t, e) {
                        for (var n = 0; n < t.getNumGeometries(); n++)
                            for (var i = t.getGeometryN(n), r = i.getExteriorRing(), o = 0; o < t.getNumGeometries(); o++)
                                if (n !== o) {
                                    var s = t.getGeometryN(o);
                                    if (this.checkShellNotNested(r, s, e),
                                    null !== this.validErr)
                                        return null
                                }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return zr
                    }
                }),
                zr.findPtNotNode = function(t, e, n) {
                    for (var i = n.findEdge(e), r = i.getEdgeIntersectionList(), o = 0; o < t.length; o++) {
                        var s = t[o];
                        if (!r.isIntersection(s))
                            return s
                    }
                    return null
                }
                ,
                zr.isValid = function() {
                    if (arguments[0]instanceof q) {
                        return new zr(arguments[0]).isValid()
                    }
                    if (arguments[0]instanceof d) {
                        var t = arguments[0];
                        return !(r.isNaN(t.x) || r.isInfinite(t.x) || r.isNaN(t.y) || r.isInfinite(t.y))
                    }
                }
                ,
                e(jr.prototype, {
                    isIncluded: function() {
                        return this._isIncluded
                    },
                    getCoordinates: function() {
                        if (null === this.ringPts) {
                            for (var t = new N, e = this.deList.iterator(); e.hasNext(); ) {
                                var n = e.next()
                                  , i = n.getEdge();
                                jr.addEdge(i.getLine().getCoordinates(), n.getEdgeDirection(), t)
                            }
                            this.ringPts = t.toCoordinateArray()
                        }
                        return this.ringPts
                    },
                    isIncludedSet: function() {
                        return this._isIncludedSet
                    },
                    isValid: function() {
                        return this.getCoordinates(),
                        !(this.ringPts.length <= 3) && (this.getRing(),
                        zr.isValid(this.ring))
                    },
                    build: function(t) {
                        var e = t;
                        do {
                            this.add(e),
                            e.setRing(this),
                            e = e.getNext(),
                            f.isTrue(null !== e, "found null DE in ring"),
                            f.isTrue(e === t || !e.isInRing(), "found DE already in ring")
                        } while (e !== t)
                    },
                    isOuterHole: function() {
                        return !!this._isHole && !this.hasShell()
                    },
                    getPolygon: function() {
                        var t = null;
                        if (null !== this.holes) {
                            t = new Array(this.holes.size()).fill(null);
                            for (var e = 0; e < this.holes.size(); e++)
                                t[e] = this.holes.get(e)
                        }
                        return this.factory.createPolygon(this.ring, t)
                    },
                    isHole: function() {
                        return this._isHole
                    },
                    isProcessed: function() {
                        return this._isProcessed
                    },
                    addHole: function() {
                        if (arguments[0]instanceof Rt) {
                            var t = arguments[0];
                            null === this.holes && (this.holes = new I),
                            this.holes.add(t)
                        } else if (arguments[0]instanceof jr) {
                            var e = arguments[0];
                            e.setShell(this);
                            var n = e.getRing();
                            null === this.holes && (this.holes = new I),
                            this.holes.add(n)
                        }
                    },
                    setIncluded: function(t) {
                        this._isIncluded = t,
                        this._isIncludedSet = !0
                    },
                    getOuterHole: function() {
                        if (this.isHole())
                            return null;
                        for (var t = 0; t < this.deList.size(); t++) {
                            var e = this.deList.get(t)
                              , n = e.getSym().getRing();
                            if (n.isOuterHole())
                                return n
                        }
                        return null
                    },
                    computeHole: function() {
                        var t = this.getRing();
                        this._isHole = le.isCCW(t.getCoordinates())
                    },
                    hasShell: function() {
                        return null !== this.shell
                    },
                    isOuterShell: function() {
                        return null !== this.getOuterHole()
                    },
                    getLineString: function() {
                        return this.getCoordinates(),
                        this.factory.createLineString(this.ringPts)
                    },
                    toString: function() {
                        return re.toLineString(new Gt(this.getCoordinates()))
                    },
                    getShell: function() {
                        return this.isHole() ? this.shell : this
                    },
                    add: function(t) {
                        this.deList.add(t)
                    },
                    getRing: function() {
                        if (null !== this.ring)
                            return this.ring;
                        this.getCoordinates(),
                        this.ringPts.length < 3 && D.out.println(this.ringPts);
                        try {
                            this.ring = this.factory.createLinearRing(this.ringPts)
                        } catch (t) {
                            if (!(t instanceof w))
                                throw t;
                            D.out.println(this.ringPts)
                        }
                        return this.ring
                    },
                    updateIncluded: function() {
                        if (this.isHole())
                            return null;
                        for (var t = 0; t < this.deList.size(); t++) {
                            var e = this.deList.get(t)
                              , n = e.getSym().getRing().getShell();
                            if (null !== n && n.isIncludedSet())
                                return this.setIncluded(!n.isIncluded()),
                                null
                        }
                    },
                    setShell: function(t) {
                        this.shell = t
                    },
                    setProcessed: function(t) {
                        this._isProcessed = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return jr
                    }
                }),
                jr.findDirEdgesInRing = function(t) {
                    var e = t
                      , n = new I;
                    do {
                        n.add(e),
                        e = e.getNext(),
                        f.isTrue(null !== e, "found null DE in ring"),
                        f.isTrue(e === t || !e.isInRing(), "found DE already in ring")
                    } while (e !== t);return n
                }
                ,
                jr.addEdge = function(t, e, n) {
                    if (e)
                        for (var i = 0; i < t.length; i++)
                            n.add(t[i], !1);
                    else
                        for (var i = t.length - 1; i >= 0; i--)
                            n.add(t[i], !1)
                }
                ,
                jr.findEdgeRingContaining = function(t, e) {
                    for (var n = t.getRing(), i = n.getEnvelopeInternal(), r = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext(); ) {
                        var u = a.next()
                          , l = u.getRing()
                          , c = l.getEnvelopeInternal();
                        if (!c.equals(i) && c.contains(i)) {
                            r = X.ptNotInList(n.getCoordinates(), l.getCoordinates());
                            var h = !1;
                            le.isPointInRing(r, l.getCoordinates()) && (h = !0),
                            h && (null === o || s.contains(c)) && (o = u,
                            s = o.getRing().getEnvelopeInternal())
                        }
                    }
                    return o
                }
                ,
                e(Yr.prototype, {
                    compare: function(t, e) {
                        var n = t
                          , i = e;
                        return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())
                    },
                    interfaces_: function() {
                        return [a]
                    },
                    getClass: function() {
                        return Yr
                    }
                }),
                jr.EnvelopeComparator = Yr,
                c(Xr, Lr),
                e(Xr.prototype, {
                    findEdgeRing: function(t) {
                        var e = new jr(this.factory);
                        return e.build(t),
                        e
                    },
                    computeDepthParity: function() {
                        if (0 === arguments.length)
                            for (; ; ) {
                                return null
                            }
                        else
                            1 === arguments.length && arguments[0]
                    },
                    computeNextCWEdges: function() {
                        for (var t = this.nodeIterator(); t.hasNext(); ) {
                            var e = t.next();
                            Xr.computeNextCWEdges(e)
                        }
                    },
                    addEdge: function(t) {
                        if (t.isEmpty())
                            return null;
                        var e = X.removeRepeatedPoints(t.getCoordinates());
                        if (e.length < 2)
                            return null;
                        var n = e[0]
                          , i = e[e.length - 1]
                          , r = this.getNode(n)
                          , o = this.getNode(i)
                          , s = new Or(r,o,e[1],!0)
                          , a = new Or(o,r,e[e.length - 2],!1)
                          , u = new Pr(t);
                        u.setDirectedEdges(s, a),
                        this.add(u)
                    },
                    deleteCutEdges: function() {
                        this.computeNextCWEdges(),
                        Xr.findLabeledEdgeRings(this.dirEdges);
                        for (var t = new I, e = this.dirEdges.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            if (!n.isMarked()) {
                                var i = n.getSym();
                                if (n.getLabel() === i.getLabel()) {
                                    n.setMarked(!0),
                                    i.setMarked(!0);
                                    var r = n.getEdge();
                                    t.add(r.getLine())
                                }
                            }
                        }
                        return t
                    },
                    getEdgeRings: function() {
                        this.computeNextCWEdges(),
                        Xr.label(this.dirEdges, -1);
                        var t = Xr.findLabeledEdgeRings(this.dirEdges);
                        this.convertMaximalToMinimalEdgeRings(t);
                        for (var e = new I, n = this.dirEdges.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (!i.isMarked() && !i.isInRing()) {
                                var r = this.findEdgeRing(i);
                                e.add(r)
                            }
                        }
                        return e
                    },
                    getNode: function(t) {
                        var e = this.findNode(t);
                        return null === e && (e = new _r(t),
                        this.add(e)),
                        e
                    },
                    convertMaximalToMinimalEdgeRings: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next()
                              , i = n.getLabel()
                              , r = Xr.findIntersectionNodes(n, i);
                            if (null !== r)
                                for (var o = r.iterator(); o.hasNext(); ) {
                                    var s = o.next();
                                    Xr.computeNextCCWEdges(s, i)
                                }
                        }
                    },
                    deleteDangles: function() {
                        for (var t = this.findNodesOfDegree(1), e = new Z, n = new ge, i = t.iterator(); i.hasNext(); )
                            n.push(i.next());
                        for (; !n.isEmpty(); ) {
                            var r = n.pop();
                            Xr.deleteAllEdges(r);
                            for (var o = r.getOutEdges().getEdges(), i = o.iterator(); i.hasNext(); ) {
                                var s = i.next();
                                s.setMarked(!0);
                                var a = s.getSym();
                                null !== a && a.setMarked(!0);
                                var u = s.getEdge();
                                e.add(u.getLine());
                                var l = s.getToNode();
                                1 === Xr.getDegreeNonDeleted(l) && n.push(l)
                            }
                        }
                        return e
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Xr
                    }
                }),
                Xr.findLabeledEdgeRings = function(t) {
                    for (var e = new I, n = 1, i = t.iterator(); i.hasNext(); ) {
                        var r = i.next();
                        if (!(r.isMarked() || r.getLabel() >= 0)) {
                            e.add(r);
                            var o = jr.findDirEdgesInRing(r);
                            Xr.label(o, n),
                            n++
                        }
                    }
                    return e
                }
                ,
                Xr.getDegreeNonDeleted = function(t) {
                    for (var e = t.getOutEdges().getEdges(), n = 0, i = e.iterator(); i.hasNext(); ) {
                        i.next().isMarked() || n++
                    }
                    return n
                }
                ,
                Xr.deleteAllEdges = function(t) {
                    for (var e = t.getOutEdges().getEdges(), n = e.iterator(); n.hasNext(); ) {
                        var i = n.next();
                        i.setMarked(!0);
                        var r = i.getSym();
                        null !== r && r.setMarked(!0)
                    }
                }
                ,
                Xr.label = function(t, e) {
                    for (var n = t.iterator(); n.hasNext(); ) {
                        n.next().setLabel(e)
                    }
                }
                ,
                Xr.computeNextCWEdges = function(t) {
                    for (var e = t.getOutEdges(), n = null, i = null, r = e.getEdges().iterator(); r.hasNext(); ) {
                        var o = r.next();
                        if (!o.isMarked()) {
                            if (null === n && (n = o),
                            null !== i) {
                                var s = i.getSym();
                                s.setNext(o)
                            }
                            i = o
                        }
                    }
                    if (null !== i) {
                        var s = i.getSym();
                        s.setNext(n)
                    }
                }
                ,
                Xr.computeNextCCWEdges = function(t, e) {
                    for (var n = t.getOutEdges(), i = null, r = null, o = n.getEdges(), s = o.size() - 1; s >= 0; s--) {
                        var a = o.get(s)
                          , u = a.getSym()
                          , l = null;
                        a.getLabel() === e && (l = a);
                        var c = null;
                        u.getLabel() === e && (c = u),
                        null === l && null === c || (null !== c && (r = c),
                        null !== l && (null !== r && (r.setNext(l),
                        r = null),
                        null === i && (i = l)))
                    }
                    null !== r && (f.isTrue(null !== i),
                    r.setNext(i))
                }
                ,
                Xr.getDegree = function(t, e) {
                    for (var n = t.getOutEdges().getEdges(), i = 0, r = n.iterator(); r.hasNext(); ) {
                        r.next().getLabel() === e && i++
                    }
                    return i
                }
                ,
                Xr.findIntersectionNodes = function(t, e) {
                    var n = t
                      , i = null;
                    do {
                        var r = n.getFromNode();
                        Xr.getDegree(r, e) > 1 && (null === i && (i = new I),
                        i.add(r)),
                        n = n.getNext(),
                        f.isTrue(null !== n, "found null DE in ring"),
                        f.isTrue(n === t || !n.isInRing(), "found DE already in ring")
                    } while (n !== t);return i
                }
                ,
                e(Hr.prototype, {
                    getGeometry: function() {
                        return null === this.geomFactory && (this.geomFactory = new ne),
                        this.polygonize(),
                        this.extractOnlyPolygonal ? this.geomFactory.buildGeometry(this.polyList) : this.geomFactory.createGeometryCollection(ne.toGeometryArray(this.polyList))
                    },
                    getInvalidRingLines: function() {
                        return this.polygonize(),
                        this.invalidRingLines
                    },
                    findValidRings: function(t, e, n) {
                        for (var i = t.iterator(); i.hasNext(); ) {
                            var r = i.next();
                            r.isValid() ? e.add(r) : n.add(r.getLineString())
                        }
                    },
                    polygonize: function() {
                        if (null !== this.polyList)
                            return null;
                        if (this.polyList = new I,
                        null === this.graph)
                            return null;
                        this.dangles = this.graph.deleteDangles(),
                        this.cutEdges = this.graph.deleteCutEdges();
                        var t = this.graph.getEdgeRings()
                          , e = new I;
                        this.invalidRingLines = new I,
                        this.isCheckingRingsValid ? this.findValidRings(t, e, this.invalidRingLines) : e = t,
                        this.findShellsAndHoles(e),
                        Hr.assignHolesToShells(this.holeList, this.shellList),
                        ls.sort(this.shellList, new jr.EnvelopeComparator);
                        var n = !0;
                        this.extractOnlyPolygonal && (Hr.findDisjointShells(this.shellList),
                        n = !1),
                        this.polyList = Hr.extractPolygons(this.shellList, n)
                    },
                    getDangles: function() {
                        return this.polygonize(),
                        this.dangles
                    },
                    getCutEdges: function() {
                        return this.polygonize(),
                        this.cutEdges
                    },
                    getPolygons: function() {
                        return this.polygonize(),
                        this.polyList
                    },
                    add: function() {
                        if (b(arguments[0], m))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.add(n)
                            }
                        else if (arguments[0]instanceof wt) {
                            var i = arguments[0];
                            this.geomFactory = i.getFactory(),
                            null === this.graph && (this.graph = new Xr(this.geomFactory)),
                            this.graph.addEdge(i)
                        } else if (arguments[0]instanceof q) {
                            var r = arguments[0];
                            r.apply(this.lineStringAdder)
                        }
                    },
                    setCheckRingsValid: function(t) {
                        this.isCheckingRingsValid = t
                    },
                    findShellsAndHoles: function(t) {
                        this.holeList = new I,
                        this.shellList = new I;
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            n.computeHole(),
                            n.isHole() ? this.holeList.add(n) : this.shellList.add(n)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Hr
                    }
                }),
                Hr.findOuterShells = function(t) {
                    for (var e = t.iterator(); e.hasNext(); ) {
                        var n = e.next()
                          , i = n.getOuterHole();
                        null === i || i.isProcessed() || (n.setIncluded(!0),
                        i.setProcessed(!0))
                    }
                }
                ,
                Hr.extractPolygons = function(t, e) {
                    for (var n = new I, i = t.iterator(); i.hasNext(); ) {
                        var r = i.next();
                        (e || r.isIncluded()) && n.add(r.getPolygon())
                    }
                    return n
                }
                ,
                Hr.assignHolesToShells = function(t, e) {
                    for (var n = t.iterator(); n.hasNext(); ) {
                        var i = n.next();
                        Hr.assignHoleToShell(i, e)
                    }
                }
                ,
                Hr.assignHoleToShell = function(t, e) {
                    var n = jr.findEdgeRingContaining(t, e);
                    null !== n && n.addHole(t)
                }
                ,
                Hr.findDisjointShells = function(t) {
                    Hr.findOuterShells(t);
                    var e = null;
                    do {
                        e = !1;
                        for (var n = t.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.isIncludedSet() || (i.updateIncluded(),
                            i.isIncludedSet() || (e = !0))
                        }
                    } while (e)
                }
                ,
                e(Wr.prototype, {
                    filter: function(t) {
                        t instanceof wt && this.p.add(t)
                    },
                    interfaces_: function() {
                        return [k]
                    },
                    getClass: function() {
                        return Wr
                    }
                }),
                Hr.LineStringAdder = Wr;
                var Ss = Object.freeze({
                    Polygonizer: Hr
                });
                e(Jr.prototype, {
                    insertEdgeEnds: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.nodes.add(n)
                        }
                    },
                    computeProperIntersectionIM: function(t, e) {
                        var n = this.arg[0].getGeometry().getDimension()
                          , i = this.arg[1].getGeometry().getDimension()
                          , r = t.hasProperIntersection()
                          , o = t.hasProperInteriorIntersection();
                        2 === n && 2 === i ? r && e.setAtLeast("212101212") : 2 === n && 1 === i ? (r && e.setAtLeast("FFF0FFFF2"),
                        o && e.setAtLeast("1FFFFF1FF")) : 1 === n && 2 === i ? (r && e.setAtLeast("F0FFFFFF2"),
                        o && e.setAtLeast("1F1FFFFFF")) : 1 === n && 1 === i && o && e.setAtLeast("0FFFFFFFF")
                    },
                    labelIsolatedEdges: function(t, e) {
                        for (var n = this.arg[t].getEdgeIterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.isIsolated() && (this.labelIsolatedEdge(i, e, this.arg[e].getGeometry()),
                            this.isolatedEdges.add(i))
                        }
                    },
                    labelIsolatedEdge: function(t, e, n) {
                        if (n.getDimension() > 0) {
                            var i = this.ptLocator.locate(t.getCoordinate(), n);
                            t.getLabel().setAllLocations(e, i)
                        } else
                            t.getLabel().setAllLocations(e, S.EXTERIOR)
                    },
                    computeIM: function() {
                        var t = new he;
                        if (t.set(S.EXTERIOR, S.EXTERIOR, 2),
                        !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))
                            return this.computeDisjointIM(t),
                            t;
                        this.arg[0].computeSelfNodes(this.li, !1),
                        this.arg[1].computeSelfNodes(this.li, !1);
                        var e = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);
                        this.computeIntersectionNodes(0),
                        this.computeIntersectionNodes(1),
                        this.copyNodesAndLabels(0),
                        this.copyNodesAndLabels(1),
                        this.labelIsolatedNodes(),
                        this.computeProperIntersectionIM(e, t);
                        var n = new Ar
                          , i = n.computeEdgeEnds(this.arg[0].getEdgeIterator());
                        this.insertEdgeEnds(i);
                        var r = n.computeEdgeEnds(this.arg[1].getEdgeIterator());
                        return this.insertEdgeEnds(r),
                        this.labelNodeEdges(),
                        this.labelIsolatedEdges(0, 1),
                        this.labelIsolatedEdges(1, 0),
                        this.updateIM(t),
                        t
                    },
                    labelNodeEdges: function() {
                        for (var t = this.nodes.iterator(); t.hasNext(); ) {
                            t.next().getEdges().computeLabelling(this.arg)
                        }
                    },
                    copyNodesAndLabels: function(t) {
                        for (var e = this.arg[t].getNodeIterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.nodes.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
                        }
                    },
                    labelIntersectionNodes: function(t) {
                        for (var e = this.arg[t].getEdgeIterator(); e.hasNext(); )
                            for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext(); ) {
                                var o = r.next()
                                  , s = this.nodes.find(o.coord);
                                s.getLabel().isNull(t) && (i === S.BOUNDARY ? s.setLabelBoundary(t) : s.setLabel(t, S.INTERIOR))
                            }
                    },
                    labelIsolatedNode: function(t, e) {
                        var n = this.ptLocator.locate(t.getCoordinate(), this.arg[e].getGeometry());
                        t.getLabel().setAllLocations(e, n)
                    },
                    computeIntersectionNodes: function(t) {
                        for (var e = this.arg[t].getEdgeIterator(); e.hasNext(); )
                            for (var n = e.next(), i = n.getLabel().getLocation(t), r = n.getEdgeIntersectionList().iterator(); r.hasNext(); ) {
                                var o = r.next()
                                  , s = this.nodes.addNode(o.coord);
                                i === S.BOUNDARY ? s.setLabelBoundary(t) : s.getLabel().isNull(t) && s.setLabel(t, S.INTERIOR)
                            }
                    },
                    labelIsolatedNodes: function() {
                        for (var t = this.nodes.iterator(); t.hasNext(); ) {
                            var e = t.next()
                              , n = e.getLabel();
                            f.isTrue(n.getGeometryCount() > 0, "node with empty label found"),
                            e.isIsolated() && (n.isNull(0) ? this.labelIsolatedNode(e, 0) : this.labelIsolatedNode(e, 1))
                        }
                    },
                    updateIM: function(t) {
                        for (var e = this.isolatedEdges.iterator(); e.hasNext(); ) {
                            e.next().updateIM(t)
                        }
                        for (var n = this.nodes.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            i.updateIM(t),
                            i.updateIMFromEdges(t)
                        }
                    },
                    computeDisjointIM: function(t) {
                        var e = this.arg[0].getGeometry();
                        e.isEmpty() || (t.set(S.INTERIOR, S.EXTERIOR, e.getDimension()),
                        t.set(S.BOUNDARY, S.EXTERIOR, e.getBoundaryDimension()));
                        var n = this.arg[1].getGeometry();
                        n.isEmpty() || (t.set(S.EXTERIOR, S.INTERIOR, n.getDimension()),
                        t.set(S.EXTERIOR, S.BOUNDARY, n.getBoundaryDimension()))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Jr
                    }
                }),
                e($r.prototype, {
                    isContainedInBoundary: function(t) {
                        if (t instanceof Lt)
                            return !1;
                        if (t instanceof St)
                            return this.isPointContainedInBoundary(t);
                        if (t instanceof wt)
                            return this.isLineStringContainedInBoundary(t);
                        for (var e = 0; e < t.getNumGeometries(); e++) {
                            var n = t.getGeometryN(e);
                            if (!this.isContainedInBoundary(n))
                                return !1
                        }
                        return !0
                    },
                    isLineSegmentContainedInBoundary: function(t, e) {
                        if (t.equals(e))
                            return this.isPointContainedInBoundary(t);
                        if (t.x === e.x) {
                            if (t.x === this.rectEnv.getMinX() || t.x === this.rectEnv.getMaxX())
                                return !0
                        } else if (t.y === e.y && (t.y === this.rectEnv.getMinY() || t.y === this.rectEnv.getMaxY()))
                            return !0;
                        return !1
                    },
                    isLineStringContainedInBoundary: function(t) {
                        for (var e = t.getCoordinateSequence(), n = new d, i = new d, r = 0; r < e.size() - 1; r++)
                            if (e.getCoordinate(r, n),
                            e.getCoordinate(r + 1, i),
                            !this.isLineSegmentContainedInBoundary(n, i))
                                return !1;
                        return !0
                    },
                    isPointContainedInBoundary: function() {
                        if (arguments[0]instanceof St) {
                            var t = arguments[0];
                            return this.isPointContainedInBoundary(t.getCoordinate())
                        }
                        if (arguments[0]instanceof d) {
                            var e = arguments[0];
                            return e.x === this.rectEnv.getMinX() || e.x === this.rectEnv.getMaxX() || e.y === this.rectEnv.getMinY() || e.y === this.rectEnv.getMaxY()
                        }
                    },
                    contains: function(t) {
                        return !!this.rectEnv.contains(t.getEnvelopeInternal()) && !this.isContainedInBoundary(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return $r
                    }
                }),
                $r.contains = function(t, e) {
                    return new $r(t).contains(e)
                }
                ,
                e(Kr.prototype, {
                    intersects: function(t, e) {
                        var n = new C(t,e);
                        if (!this.rectEnv.intersects(n))
                            return !1;
                        if (this.rectEnv.intersects(t))
                            return !0;
                        if (this.rectEnv.intersects(e))
                            return !0;
                        if (t.compareTo(e) > 0) {
                            var i = t;
                            t = e,
                            e = i
                        }
                        var r = !1;
                        return e.y > t.y && (r = !0),
                        r ? this.li.computeIntersection(t, e, this.diagDown0, this.diagDown1) : this.li.computeIntersection(t, e, this.diagUp0, this.diagUp1),
                        !!this.li.hasIntersection()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Kr
                    }
                }),
                e(Zr.prototype, {
                    applyTo: function(t) {
                        for (var e = 0; e < t.getNumGeometries() && !this._isDone; e++) {
                            var n = t.getGeometryN(e);
                            if (n instanceof ft)
                                this.applyTo(n);
                            else if (this.visit(n),
                            this.isDone())
                                return this._isDone = !0,
                                null
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Zr
                    }
                }),
                e(Qr.prototype, {
                    intersects: function(t) {
                        if (!this.rectEnv.intersects(t.getEnvelopeInternal()))
                            return !1;
                        var e = new to(this.rectEnv);
                        if (e.applyTo(t),
                        e.intersects())
                            return !0;
                        var n = new eo(this.rectangle);
                        if (n.applyTo(t),
                        n.containsPoint())
                            return !0;
                        var i = new no(this.rectangle);
                        return i.applyTo(t),
                        !!i.intersects()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Qr
                    }
                }),
                Qr.intersects = function(t, e) {
                    return new Qr(t).intersects(e)
                }
                ,
                c(to, Zr),
                e(to.prototype, {
                    isDone: function() {
                        return !0 === this._intersects
                    },
                    visit: function(t) {
                        var e = t.getEnvelopeInternal();
                        return this.rectEnv.intersects(e) ? this.rectEnv.contains(e) ? (this._intersects = !0,
                        null) : e.getMinX() >= this.rectEnv.getMinX() && e.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = !0,
                        null) : e.getMinY() >= this.rectEnv.getMinY() && e.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = !0,
                        null) : void 0 : null
                    },
                    intersects: function() {
                        return this._intersects
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return to
                    }
                }),
                c(eo, Zr),
                e(eo.prototype, {
                    isDone: function() {
                        return !0 === this._containsPoint
                    },
                    visit: function(t) {
                        if (!(t instanceof Lt))
                            return null;
                        var e = t.getEnvelopeInternal();
                        if (!this.rectEnv.intersects(e))
                            return null;
                        for (var n = new d, i = 0; i < 4; i++)
                            if (this.rectSeq.getCoordinate(i, n),
                            e.contains(n) && bn.containsPointInPolygon(n, t))
                                return this._containsPoint = !0,
                                null
                    },
                    containsPoint: function() {
                        return this._containsPoint
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return eo
                    }
                }),
                c(no, Zr),
                e(no.prototype, {
                    intersects: function() {
                        return this.hasIntersection
                    },
                    isDone: function() {
                        return !0 === this.hasIntersection
                    },
                    visit: function(t) {
                        var e = t.getEnvelopeInternal();
                        if (!this.rectEnv.intersects(e))
                            return null;
                        var n = Un.getLines(t);
                        this.checkIntersectionWithLineStrings(n)
                    },
                    checkIntersectionWithLineStrings: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            if (this.checkIntersectionWithSegments(n),
                            this.hasIntersection)
                                return null
                        }
                    },
                    checkIntersectionWithSegments: function(t) {
                        for (var e = t.getCoordinateSequence(), n = 1; n < e.size(); n++)
                            if (e.getCoordinate(n - 1, this.p0),
                            e.getCoordinate(n, this.p1),
                            this.rectIntersector.intersects(this.p0, this.p1))
                                return this.hasIntersection = !0,
                                null
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return no
                    }
                }),
                c(io, Qn),
                e(io.prototype, {
                    getIntersectionMatrix: function() {
                        return this._relate.computeIM()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return io
                    }
                }),
                io.covers = function(t, e) {
                    return !!t.getEnvelopeInternal().covers(e.getEnvelopeInternal()) && (!!t.isRectangle() || io.relate(t, e).isCovers())
                }
                ,
                io.intersects = function(t, e) {
                    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && (t.isRectangle() ? Qr.intersects(t, e) : e.isRectangle() ? Qr.intersects(e, t) : io.relate(t, e).isIntersects())
                }
                ,
                io.touches = function(t, e) {
                    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && io.relate(t, e).isTouches(t.getDimension(), e.getDimension())
                }
                ,
                io.within = function(t, e) {
                    return e.contains(t)
                }
                ,
                io.coveredBy = function(t, e) {
                    return io.covers(e, t)
                }
                ,
                io.relate = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = new io(t,e)
                          , i = n.getIntersectionMatrix();
                        return i
                    }
                    if (3 === arguments.length) {
                        if ("string" == typeof arguments[2] && arguments[0]instanceof q && arguments[1]instanceof q) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , s = arguments[2];
                            return io.relateWithCheck(r, o).matches(s)
                        }
                        if (b(arguments[2], U) && arguments[0]instanceof q && arguments[1]instanceof q) {
                            var a = arguments[0]
                              , u = arguments[1]
                              , l = arguments[2]
                              , n = new io(a,u,l)
                              , i = n.getIntersectionMatrix();
                            return i
                        }
                    }
                }
                ,
                io.overlaps = function(t, e) {
                    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && io.relate(t, e).isOverlaps(t.getDimension(), e.getDimension())
                }
                ,
                io.disjoint = function(t, e) {
                    return !t.intersects(e)
                }
                ,
                io.relateWithCheck = function(t, e) {
                    return t.checkNotGeometryCollection(t),
                    t.checkNotGeometryCollection(e),
                    io.relate(t, e)
                }
                ,
                io.crosses = function(t, e) {
                    return !!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()) && io.relate(t, e).isCrosses(t.getDimension(), e.getDimension())
                }
                ,
                io.contains = function(t, e) {
                    return !!t.getEnvelopeInternal().contains(e.getEnvelopeInternal()) && (t.isRectangle() ? $r.contains(t, e) : io.relate(t, e).isContains())
                }
                ;
                var bs = Object.freeze({
                    RelateOp: io
                });
                e(ro.prototype, {
                    extractElements: function(t, e) {
                        if (null === t)
                            return null;
                        for (var n = 0; n < t.getNumGeometries(); n++) {
                            var i = t.getGeometryN(n);
                            this.skipEmpty && i.isEmpty() || e.add(i)
                        }
                    },
                    combine: function() {
                        for (var t = new I, e = this.inputGeoms.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.extractElements(n, t)
                        }
                        return 0 === t.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ro
                    }
                }),
                ro.combine = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0]
                          , e = new ro(t);
                        return e.combine()
                    }
                    if (2 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , e = new ro(ro.createList(n, i));
                        return e.combine()
                    }
                    if (3 === arguments.length) {
                        var r = arguments[0]
                          , o = arguments[1]
                          , s = arguments[2]
                          , e = new ro(ro.createList(r, o, s));
                        return e.combine()
                    }
                }
                ,
                ro.extractFactory = function(t) {
                    return t.isEmpty() ? null : t.iterator().next().getFactory()
                }
                ,
                ro.createList = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = new I;
                        return n.add(t),
                        n.add(e),
                        n
                    }
                    if (3 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , o = arguments[2]
                          , n = new I;
                        return n.add(i),
                        n.add(r),
                        n.add(o),
                        n
                    }
                }
                ,
                e(oo.prototype, {
                    union: function() {
                        for (var t = new be, e = new at, n = 0; n < this.pointGeom.getNumGeometries(); n++) {
                            var i = this.pointGeom.getGeometryN(n)
                              , r = i.getCoordinate();
                            t.locate(r, this.otherGeom) === S.EXTERIOR && e.add(r)
                        }
                        if (0 === e.size())
                            return this.otherGeom;
                        var o = null
                          , s = X.toCoordinateArray(e);
                        return o = 1 === s.length ? this.geomFact.createPoint(s[0]) : this.geomFact.createMultiPointFromCoords(s),
                        ro.combine(o, this.otherGeom)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return oo
                    }
                }),
                oo.union = function(t, e) {
                    return new oo(t,e).union()
                }
                ,
                e(so.prototype, {
                    filter: function(t) {
                        -1 !== this.sortIndex && t.getSortIndex() !== this.sortIndex || this.comps.add(t)
                    },
                    interfaces_: function() {
                        return [ct]
                    },
                    getClass: function() {
                        return so
                    }
                }),
                so.extract = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1];
                        return so.extract(t, e, new I)
                    }
                    if (3 === arguments.length) {
                        var n = arguments[0]
                          , i = arguments[1]
                          , r = arguments[2];
                        return n.getSortIndex() === i ? r.add(n) : n instanceof ft && n.apply(new so(i,r)),
                        r
                    }
                }
                ,
                e(ao.prototype, {
                    reduceToGeometries: function(t) {
                        for (var e = new I, n = t.iterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = null;
                            b(i, v) ? r = this.unionTree(i) : i instanceof q && (r = i),
                            e.add(r)
                        }
                        return e
                    },
                    extractByEnvelope: function(t, e, n) {
                        for (var i = new I, r = 0; r < e.getNumGeometries(); r++) {
                            var o = e.getGeometryN(r);
                            o.getEnvelopeInternal().intersects(t) ? i.add(o) : n.add(o)
                        }
                        return this.geomFactory.buildGeometry(i)
                    },
                    unionOptimized: function(t, e) {
                        var n = t.getEnvelopeInternal()
                          , i = e.getEnvelopeInternal();
                        if (!n.intersects(i)) {
                            return ro.combine(t, e)
                        }
                        if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1)
                            return this.unionActual(t, e);
                        var r = n.intersection(i);
                        return this.unionUsingEnvelopeIntersection(t, e, r)
                    },
                    union: function() {
                        if (null === this.inputPolys)
                            throw new IllegalStateException("union() method cannot be called twice");
                        if (this.inputPolys.isEmpty())
                            return null;
                        this.geomFactory = this.inputPolys.iterator().next().getFactory();
                        for (var t = new Ue(ao.STRTREE_NODE_CAPACITY), e = this.inputPolys.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            t.insert(n.getEnvelopeInternal(), n)
                        }
                        this.inputPolys = null;
                        var i = t.itemsTree();
                        return this.unionTree(i)
                    },
                    binaryUnion: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.binaryUnion(t, 0, t.size())
                        }
                        if (3 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1]
                              , i = arguments[2];
                            if (i - n <= 1) {
                                var r = ao.getGeometry(e, n);
                                return this.unionSafe(r, null)
                            }
                            if (i - n == 2)
                                return this.unionSafe(ao.getGeometry(e, n), ao.getGeometry(e, n + 1));
                            var o = Math.trunc((i + n) / 2)
                              , r = this.binaryUnion(e, n, o)
                              , s = this.binaryUnion(e, o, i);
                            return this.unionSafe(r, s)
                        }
                    },
                    repeatedUnion: function(t) {
                        for (var e = null, n = t.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            e = null === e ? i.copy() : e.union(i)
                        }
                        return e
                    },
                    unionSafe: function(t, e) {
                        return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e)
                    },
                    unionActual: function(t, e) {
                        return ao.restrictToPolygons(t.union(e))
                    },
                    unionTree: function(t) {
                        var e = this.reduceToGeometries(t);
                        return this.binaryUnion(e)
                    },
                    unionUsingEnvelopeIntersection: function(t, e, n) {
                        var i = new I
                          , r = this.extractByEnvelope(n, t, i)
                          , o = this.extractByEnvelope(n, e, i)
                          , s = this.unionActual(r, o);
                        return i.add(s),
                        ro.combine(i)
                    },
                    bufferUnion: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = t.get(0).getFactory()
                              , n = e.buildGeometry(t)
                              , i = n.buffer(0);
                            return i
                        }
                        if (2 === arguments.length) {
                            var r = arguments[0]
                              , o = arguments[1]
                              , e = r.getFactory()
                              , n = e.createGeometryCollection([r, o])
                              , i = n.buffer(0);
                            return i
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ao
                    }
                }),
                ao.restrictToPolygons = function(t) {
                    if (b(t, bt))
                        return t;
                    var e = gr.getPolygons(t);
                    return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(ne.toPolygonArray(e))
                }
                ,
                ao.getGeometry = function(t, e) {
                    return e >= t.size() ? null : t.get(e)
                }
                ,
                ao.union = function(t) {
                    return new ao(t).union()
                }
                ,
                ao.STRTREE_NODE_CAPACITY = 4,
                e(uo.prototype, {
                    unionNoOpt: function(t) {
                        var e = this.geomFact.createPoint();
                        return ri.overlayOp(t, e, ni.UNION)
                    },
                    unionWithNull: function(t, e) {
                        return null === t && null === e ? null : null === e ? t : null === t ? e : t.union(e)
                    },
                    extract: function() {
                        if (b(arguments[0], m))
                            for (var t = arguments[0], e = t.iterator(); e.hasNext(); ) {
                                var n = e.next();
                                this.extract(n)
                            }
                        else if (arguments[0]instanceof q) {
                            var i = arguments[0];
                            null === this.geomFact && (this.geomFact = i.getFactory()),
                            so.extract(i, q.SORTINDEX_POLYGON, this.polygons),
                            so.extract(i, q.SORTINDEX_LINESTRING, this.lines),
                            so.extract(i, q.SORTINDEX_POINT, this.points)
                        }
                    },
                    union: function() {
                        if (null === this.geomFact)
                            return null;
                        var t = null;
                        if (this.points.size() > 0) {
                            var e = this.geomFact.buildGeometry(this.points);
                            t = this.unionNoOpt(e)
                        }
                        var n = null;
                        if (this.lines.size() > 0) {
                            var i = this.geomFact.buildGeometry(this.lines);
                            n = this.unionNoOpt(i)
                        }
                        var r = null;
                        this.polygons.size() > 0 && (r = ao.union(this.polygons));
                        var o = this.unionWithNull(n, r)
                          , s = null;
                        return s = null === t ? o : null === o ? t : oo.union(t, o),
                        null === s ? this.geomFact.createGeometryCollection() : s
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return uo
                    }
                }),
                uo.union = function() {
                    if (1 === arguments.length) {
                        if (b(arguments[0], m)) {
                            var t = arguments[0]
                              , e = new uo(t);
                            return e.union()
                        }
                        if (arguments[0]instanceof q) {
                            var n = arguments[0]
                              , e = new uo(n);
                            return e.union()
                        }
                    } else if (2 === arguments.length) {
                        var i = arguments[0]
                          , r = arguments[1]
                          , e = new uo(i,r);
                        return e.union()
                    }
                }
                ;
                var Ls = Object.freeze({
                    UnaryUnionOp: uo
                })
                  , Ts = Object.freeze({
                    IsValidOp: zr,
                    ConsistentAreaTester: Br
                })
                  , Rs = Object.freeze({
                    BoundaryOp: gt,
                    IsSimpleOp: Xi,
                    buffer: Ns,
                    distance: Cs,
                    linemerge: ws,
                    overlay: _s,
                    polygonize: Ss,
                    relate: bs,
                    union: Ls,
                    valid: Ts
                });
                c(lo, Pt.CoordinateOperation),
                e(lo.prototype, {
                    editCoordinates: function(t, e) {
                        if (0 === t.length)
                            return null;
                        for (var n = new Array(t.length).fill(null), i = 0; i < t.length; i++) {
                            var r = new d(t[i]);
                            this.targetPM.makePrecise(r),
                            n[i] = r
                        }
                        var o = new N(n,!1)
                          , s = o.toCoordinateArray()
                          , a = 0;
                        e instanceof wt && (a = 2),
                        e instanceof Rt && (a = 4);
                        var u = n;
                        return this.removeCollapsed && (u = null),
                        s.length < a ? u : s
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return lo
                    }
                }),
                e(co.prototype, {
                    fixPolygonalTopology: function(t) {
                        var e = t;
                        this.changePrecisionModel || (e = this.changePM(t, this.targetPM));
                        var n = e.buffer(0)
                          , i = n;
                        return this.changePrecisionModel || (i = this.changePM(n, t.getPrecisionModel())),
                        i
                    },
                    reducePointwise: function(t) {
                        var e = null;
                        if (this.changePrecisionModel) {
                            e = new Pt(this.createFactory(t.getFactory(), this.targetPM))
                        } else
                            e = new Pt;
                        var n = this.removeCollapsed;
                        return t.getDimension() >= 2 && (n = !0),
                        e.edit(t, new lo(this.targetPM,n))
                    },
                    changePM: function(t, e) {
                        return this.createEditor(t.getFactory(), e).edit(t, new Pt.NoOpGeometryOperation)
                    },
                    setRemoveCollapsedComponents: function(t) {
                        this.removeCollapsed = t
                    },
                    createFactory: function(t, e) {
                        return new ne(e,t.getSRID(),t.getCoordinateSequenceFactory())
                    },
                    setChangePrecisionModel: function(t) {
                        this.changePrecisionModel = t
                    },
                    reduce: function(t) {
                        var e = this.reducePointwise(t);
                        return this.isPointwise ? e : b(e, bt) ? e.isValid() ? e : this.fixPolygonalTopology(e) : e
                    },
                    setPointwise: function(t) {
                        this.isPointwise = t
                    },
                    createEditor: function(t, e) {
                        return t.getPrecisionModel() === e ? new Pt : new Pt(this.createFactory(t, e))
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return co
                    }
                }),
                co.reduce = function(t, e) {
                    return new co(e).reduce(t)
                }
                ,
                co.reducePointwise = function(t, e) {
                    var n = new co(e);
                    return n.setPointwise(!0),
                    n.reduce(t)
                }
                ;
                var Os = Object.freeze({
                    GeometryPrecisionReducer: co
                });
                e(ho.prototype, {
                    simplifySection: function(t, e) {
                        if (t + 1 === e)
                            return null;
                        this.seg.p0 = this.pts[t],
                        this.seg.p1 = this.pts[e];
                        for (var n = -1, i = t, r = t + 1; r < e; r++) {
                            var o = this.seg.distance(this.pts[r]);
                            o > n && (n = o,
                            i = r)
                        }
                        if (n <= this.distanceTolerance)
                            for (var r = t + 1; r < e; r++)
                                this.usePt[r] = !1;
                        else
                            this.simplifySection(t, i),
                            this.simplifySection(i, e)
                    },
                    setDistanceTolerance: function(t) {
                        this.distanceTolerance = t
                    },
                    simplify: function() {
                        this.usePt = new Array(this.pts.length).fill(null);
                        for (var t = 0; t < this.pts.length; t++)
                            this.usePt[t] = !0;
                        this.simplifySection(0, this.pts.length - 1);
                        for (var e = new N, t = 0; t < this.pts.length; t++)
                            this.usePt[t] && e.add(new d(this.pts[t]));
                        return e.toCoordinateArray()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return ho
                    }
                }),
                ho.simplify = function(t, e) {
                    var n = new ho(t);
                    return n.setDistanceTolerance(e),
                    n.simplify()
                }
                ,
                e(fo.prototype, {
                    setEnsureValid: function(t) {
                        this.isEnsureValidTopology = t
                    },
                    getResultGeometry: function() {
                        return this.inputGeom.isEmpty() ? this.inputGeom.copy() : new go(this.isEnsureValidTopology,this.distanceTolerance).transform(this.inputGeom)
                    },
                    setDistanceTolerance: function(t) {
                        if (t < 0)
                            throw new i("Tolerance must be non-negative");
                        this.distanceTolerance = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return fo
                    }
                }),
                fo.simplify = function(t, e) {
                    var n = new fo(t);
                    return n.setDistanceTolerance(e),
                    n.getResultGeometry()
                }
                ,
                c(go, ve),
                e(go.prototype, {
                    transformPolygon: function(t, e) {
                        if (t.isEmpty())
                            return null;
                        var n = ve.prototype.transformPolygon.call(this, t, e);
                        return e instanceof Ot ? n : this.createValidArea(n)
                    },
                    createValidArea: function(t) {
                        return this.isEnsureValidTopology ? t.buffer(0) : t
                    },
                    transformCoordinates: function(t, e) {
                        var n = t.toCoordinateArray()
                          , i = null;
                        return i = 0 === n.length ? new Array(0).fill(null) : ho.simplify(n, this.distanceTolerance),
                        this.factory.getCoordinateSequenceFactory().create(i)
                    },
                    transformMultiPolygon: function(t, e) {
                        var n = ve.prototype.transformMultiPolygon.call(this, t, e);
                        return this.createValidArea(n)
                    },
                    transformLinearRing: function(t, e) {
                        var n = e instanceof Lt
                          , i = ve.prototype.transformLinearRing.call(this, t, e);
                        return !n || i instanceof Rt ? i : null
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return go
                    }
                }),
                fo.DPTransformer = go,
                c(po, ce),
                e(po.prototype, {
                    getIndex: function() {
                        return this.index
                    },
                    getParent: function() {
                        return this.parent
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return po
                    }
                }),
                e(mo.prototype, {
                    addToResult: function(t) {
                        this.resultSegs.add(t)
                    },
                    asLineString: function() {
                        return this.parentLine.getFactory().createLineString(mo.extractCoordinates(this.resultSegs))
                    },
                    getResultSize: function() {
                        var t = this.resultSegs.size();
                        return 0 === t ? 0 : t + 1
                    },
                    getParent: function() {
                        return this.parentLine
                    },
                    getSegment: function(t) {
                        return this.segs[t]
                    },
                    getParentCoordinates: function() {
                        return this.parentLine.getCoordinates()
                    },
                    getMinimumSize: function() {
                        return this.minimumSize
                    },
                    asLinearRing: function() {
                        return this.parentLine.getFactory().createLinearRing(mo.extractCoordinates(this.resultSegs))
                    },
                    getSegments: function() {
                        return this.segs
                    },
                    init: function() {
                        var t = this.parentLine.getCoordinates();
                        this.segs = new Array(t.length - 1).fill(null);
                        for (var e = 0; e < t.length - 1; e++) {
                            var n = new po(t[e],t[e + 1],this.parentLine,e);
                            this.segs[e] = n
                        }
                    },
                    getResultCoordinates: function() {
                        return mo.extractCoordinates(this.resultSegs)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return mo
                    }
                }),
                mo.extractCoordinates = function(t) {
                    for (var e = new Array(t.size() + 1).fill(null), n = null, i = 0; i < t.size(); i++)
                        n = t.get(i),
                        e[i] = n.p0;
                    return e[e.length - 1] = n.p1,
                    e
                }
                ,
                e(yo.prototype, {
                    remove: function(t) {
                        this.index.remove(new C(t.p0,t.p1), t)
                    },
                    add: function() {
                        if (arguments[0]instanceof mo)
                            for (var t = arguments[0], e = t.getSegments(), n = 0; n < e.length; n++) {
                                var i = e[n];
                                this.add(i)
                            }
                        else if (arguments[0]instanceof ce) {
                            var r = arguments[0];
                            this.index.insert(new C(r.p0,r.p1), r)
                        }
                    },
                    query: function(t) {
                        var e = new C(t.p0,t.p1)
                          , n = new vo(t);
                        return this.index.query(e, n),
                        n.getItems()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return yo
                    }
                }),
                e(vo.prototype, {
                    visitItem: function(t) {
                        var e = t;
                        C.intersects(e.p0, e.p1, this.querySeg.p0, this.querySeg.p1) && this.items.add(t)
                    },
                    getItems: function() {
                        return this.items
                    },
                    interfaces_: function() {
                        return [Ae]
                    },
                    getClass: function() {
                        return vo
                    }
                }),
                e(Eo.prototype, {
                    flatten: function(t, e) {
                        var n = this.linePts[t]
                          , i = this.linePts[e]
                          , r = new ce(n,i);
                        return this.remove(this.line, t, e),
                        this.outputIndex.add(r),
                        r
                    },
                    hasBadIntersection: function(t, e, n) {
                        return !!this.hasBadOutputIntersection(n) || !!this.hasBadInputIntersection(t, e, n)
                    },
                    setDistanceTolerance: function(t) {
                        this.distanceTolerance = t
                    },
                    simplifySection: function(t, e, n) {
                        n += 1;
                        var i = new Array(2).fill(null);
                        if (t + 1 === e) {
                            var r = this.line.getSegment(t);
                            return this.line.addToResult(r),
                            null
                        }
                        var o = !0;
                        if (this.line.getResultSize() < this.line.getMinimumSize()) {
                            n + 1 < this.line.getMinimumSize() && (o = !1)
                        }
                        var s = new Array(1).fill(null)
                          , a = this.findFurthestPoint(this.linePts, t, e, s);
                        s[0] > this.distanceTolerance && (o = !1);
                        var u = new ce;
                        if (u.p0 = this.linePts[t],
                        u.p1 = this.linePts[e],
                        i[0] = t,
                        i[1] = e,
                        this.hasBadIntersection(this.line, i, u) && (o = !1),
                        o) {
                            var r = this.flatten(t, e);
                            return this.line.addToResult(r),
                            null
                        }
                        this.simplifySection(t, a, n),
                        this.simplifySection(a, e, n)
                    },
                    hasBadOutputIntersection: function(t) {
                        for (var e = this.outputIndex.query(t), n = e.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            if (this.hasInteriorIntersection(i, t))
                                return !0
                        }
                        return !1
                    },
                    findFurthestPoint: function(t, e, n, i) {
                        var r = new ce;
                        r.p0 = t[e],
                        r.p1 = t[n];
                        for (var o = -1, s = e, a = e + 1; a < n; a++) {
                            var u = t[a]
                              , l = r.distance(u);
                            l > o && (o = l,
                            s = a)
                        }
                        return i[0] = o,
                        s
                    },
                    simplify: function(t) {
                        this.line = t,
                        this.linePts = t.getParentCoordinates(),
                        this.simplifySection(0, this.linePts.length - 1, 0)
                    },
                    remove: function(t, e, n) {
                        for (var i = e; i < n; i++) {
                            var r = t.getSegment(i);
                            this.inputIndex.remove(r)
                        }
                    },
                    hasInteriorIntersection: function(t, e) {
                        return this.li.computeIntersection(t.p0, t.p1, e.p0, e.p1),
                        this.li.isInteriorIntersection()
                    },
                    hasBadInputIntersection: function(t, e, n) {
                        for (var i = this.inputIndex.query(n), r = i.iterator(); r.hasNext(); ) {
                            var o = r.next();
                            if (this.hasInteriorIntersection(o, n)) {
                                if (Eo.isInLineSection(t, e, o))
                                    continue;
                                return !0
                            }
                        }
                        return !1
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Eo
                    }
                }),
                Eo.isInLineSection = function(t, e, n) {
                    if (n.getParent() !== t.getParent())
                        return !1;
                    var i = n.getIndex();
                    return i >= e[0] && i < e[1]
                }
                ,
                e(xo.prototype, {
                    setDistanceTolerance: function(t) {
                        this.distanceTolerance = t
                    },
                    simplify: function(t) {
                        for (var e = t.iterator(); e.hasNext(); )
                            this.inputIndex.add(e.next());
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = new Eo(this.inputIndex,this.outputIndex);
                            n.setDistanceTolerance(this.distanceTolerance),
                            n.simplify(e.next())
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return xo
                    }
                }),
                e(Io.prototype, {
                    getResultGeometry: function() {
                        return this.inputGeom.isEmpty() ? this.inputGeom.copy() : (this.linestringMap = new Qt,
                        this.inputGeom.apply(new Co(this)),
                        this.lineSimplifier.simplify(this.linestringMap.values()),
                        new No(this.linestringMap).transform(this.inputGeom))
                    },
                    setDistanceTolerance: function(t) {
                        if (t < 0)
                            throw new i("Tolerance must be non-negative");
                        this.lineSimplifier.setDistanceTolerance(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Io
                    }
                }),
                Io.simplify = function(t, e) {
                    var n = new Io(t);
                    return n.setDistanceTolerance(e),
                    n.getResultGeometry()
                }
                ,
                c(No, ve),
                e(No.prototype, {
                    transformCoordinates: function(t, e) {
                        if (0 === t.size())
                            return null;
                        if (e instanceof wt) {
                            var n = this.linestringMap.get(e);
                            return this.createCoordinateSequence(n.getResultCoordinates())
                        }
                        return ve.prototype.transformCoordinates.call(this, t, e)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return No
                    }
                }),
                e(Co.prototype, {
                    filter: function(t) {
                        if (t instanceof wt) {
                            var e = t;
                            if (e.isEmpty())
                                return null;
                            var n = e.isClosed() ? 4 : 2
                              , i = new mo(e,n);
                            this.tps.linestringMap.put(e, i)
                        }
                    },
                    interfaces_: function() {
                        return [k]
                    },
                    getClass: function() {
                        return Co
                    }
                }),
                Io.LineStringTransformer = No,
                Io.LineStringMapBuilderFilter = Co;
                var Ps = Object.freeze({
                    DouglasPeuckerSimplifier: fo,
                    TopologyPreservingSimplifier: Io
                });
                e(wo.prototype, {
                    splitAt: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = this.minimumLen / this.segLen;
                            if (t.distance(this.seg.p0) < this.minimumLen)
                                return this.splitPt = this.seg.pointAlong(e),
                                null;
                            if (t.distance(this.seg.p1) < this.minimumLen)
                                return this.splitPt = wo.pointAlongReverse(this.seg, e),
                                null;
                            this.splitPt = t
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = this.getConstrainedLength(n)
                              , o = r / this.segLen;
                            i.equals2D(this.seg.p0) ? this.splitPt = this.seg.pointAlong(o) : this.splitPt = wo.pointAlongReverse(this.seg, o)
                        }
                    },
                    setMinimumLength: function(t) {
                        this.minimumLen = t
                    },
                    getConstrainedLength: function(t) {
                        return t < this.minimumLen ? this.minimumLen : t
                    },
                    getSplitPoint: function() {
                        return this.splitPt
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return wo
                    }
                }),
                wo.pointAlongReverse = function(t, e) {
                    var n = new d;
                    return n.x = t.p1.x - e * (t.p1.x - t.p0.x),
                    n.y = t.p1.y - e * (t.p1.y - t.p0.y),
                    n
                }
                ,
                e(_o.prototype, {
                    findSplitPoint: function(t, e) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return _o
                    }
                }),
                e(So.prototype, {
                    findSplitPoint: function(t, e) {
                        var n = t.getLineSegment()
                          , i = n.getLength()
                          , r = i / 2
                          , o = new wo(n)
                          , s = So.projectedSplitPoint(t, e)
                          , a = 2 * s.distance(e) * .8
                          , u = a;
                        return u > r && (u = r),
                        o.setMinimumLength(u),
                        o.splitAt(s),
                        o.getSplitPoint()
                    },
                    interfaces_: function() {
                        return [_o]
                    },
                    getClass: function() {
                        return So
                    }
                }),
                So.projectedSplitPoint = function(t, e) {
                    return t.getLineSegment().project(e)
                }
                ,
                e(bo.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return bo
                    }
                }),
                bo.triArea = function(t, e, n) {
                    return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x)
                }
                ,
                bo.isInCircleDDNormalized = function(t, e, n, i) {
                    var r = P.valueOf(t.x).selfSubtract(i.x)
                      , o = P.valueOf(t.y).selfSubtract(i.y)
                      , s = P.valueOf(e.x).selfSubtract(i.x)
                      , a = P.valueOf(e.y).selfSubtract(i.y)
                      , u = P.valueOf(n.x).selfSubtract(i.x)
                      , l = P.valueOf(n.y).selfSubtract(i.y)
                      , c = r.multiply(a).selfSubtract(s.multiply(o))
                      , h = s.multiply(l).selfSubtract(u.multiply(a))
                      , f = u.multiply(o).selfSubtract(r.multiply(l))
                      , d = r.multiply(r).selfAdd(o.multiply(o))
                      , g = s.multiply(s).selfAdd(a.multiply(a))
                      , p = u.multiply(u).selfAdd(l.multiply(l));
                    return d.selfMultiply(h).selfAdd(g.selfMultiply(f)).selfAdd(p.selfMultiply(c)).doubleValue() > 0
                }
                ,
                bo.checkRobustInCircle = function(t, e, n, i) {
                    var r = bo.isInCircleNonRobust(t, e, n, i)
                      , o = bo.isInCircleDDSlow(t, e, n, i)
                      , s = bo.isInCircleCC(t, e, n, i)
                      , a = Ci.circumcentre(t, e, n);
                    D.out.println("p radius diff a = " + Math.abs(i.distance(a) - t.distance(a)) / t.distance(a)),
                    r === o && r === s || (D.out.println("inCircle robustness failure (double result = " + r + ", DD result = " + o + ", CC result = " + s + ")"),
                    D.out.println(re.toLineString(new Gt([t, e, n, i]))),
                    D.out.println("Circumcentre = " + re.toPoint(a) + " radius = " + t.distance(a)),
                    D.out.println("p radius diff a = " + Math.abs(i.distance(a) / t.distance(a) - 1)),
                    D.out.println("p radius diff b = " + Math.abs(i.distance(a) / e.distance(a) - 1)),
                    D.out.println("p radius diff c = " + Math.abs(i.distance(a) / n.distance(a) - 1)),
                    D.out.println())
                }
                ,
                bo.isInCircleDDFast = function(t, e, n, i) {
                    var r = P.sqr(t.x).selfAdd(P.sqr(t.y)).selfMultiply(bo.triAreaDDFast(e, n, i))
                      , o = P.sqr(e.x).selfAdd(P.sqr(e.y)).selfMultiply(bo.triAreaDDFast(t, n, i))
                      , s = P.sqr(n.x).selfAdd(P.sqr(n.y)).selfMultiply(bo.triAreaDDFast(t, e, i))
                      , a = P.sqr(i.x).selfAdd(P.sqr(i.y)).selfMultiply(bo.triAreaDDFast(t, e, n));
                    return r.selfSubtract(o).selfAdd(s).selfSubtract(a).doubleValue() > 0
                }
                ,
                bo.isInCircleCC = function(t, e, n, i) {
                    var r = Ci.circumcentre(t, e, n)
                      , o = t.distance(r);
                    return i.distance(r) - o <= 0
                }
                ,
                bo.isInCircleNormalized = function(t, e, n, i) {
                    var r = t.x - i.x
                      , o = t.y - i.y
                      , s = e.x - i.x
                      , a = e.y - i.y
                      , u = n.x - i.x
                      , l = n.y - i.y;
                    return (r * r + o * o) * (s * l - u * a) + (s * s + a * a) * (u * o - r * l) + (u * u + l * l) * (r * a - s * o) > 0
                }
                ,
                bo.isInCircleDDSlow = function(t, e, n, i) {
                    var r = P.valueOf(i.x)
                      , o = P.valueOf(i.y)
                      , s = P.valueOf(t.x)
                      , a = P.valueOf(t.y)
                      , u = P.valueOf(e.x)
                      , l = P.valueOf(e.y)
                      , c = P.valueOf(n.x)
                      , h = P.valueOf(n.y)
                      , f = s.multiply(s).add(a.multiply(a)).multiply(bo.triAreaDDSlow(u, l, c, h, r, o))
                      , d = u.multiply(u).add(l.multiply(l)).multiply(bo.triAreaDDSlow(s, a, c, h, r, o))
                      , g = c.multiply(c).add(h.multiply(h)).multiply(bo.triAreaDDSlow(s, a, u, l, r, o))
                      , p = r.multiply(r).add(o.multiply(o)).multiply(bo.triAreaDDSlow(s, a, u, l, c, h));
                    return f.subtract(d).add(g).subtract(p).doubleValue() > 0
                }
                ,
                bo.isInCircleNonRobust = function(t, e, n, i) {
                    return (t.x * t.x + t.y * t.y) * bo.triArea(e, n, i) - (e.x * e.x + e.y * e.y) * bo.triArea(t, n, i) + (n.x * n.x + n.y * n.y) * bo.triArea(t, e, i) - (i.x * i.x + i.y * i.y) * bo.triArea(t, e, n) > 0
                }
                ,
                bo.isInCircleRobust = function(t, e, n, i) {
                    return bo.isInCircleNormalized(t, e, n, i)
                }
                ,
                bo.triAreaDDSlow = function(t, e, n, i, r, o) {
                    return n.subtract(t).multiply(o.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)))
                }
                ,
                bo.triAreaDDFast = function(t, e, n) {
                    var i = P.valueOf(e.x).selfSubtract(t.x).selfMultiply(P.valueOf(n.y).selfSubtract(t.y))
                      , r = P.valueOf(e.y).selfSubtract(t.y).selfMultiply(P.valueOf(n.x).selfSubtract(t.x));
                    return i.selfSubtract(r)
                }
                ,
                e(Lo.prototype, {
                    circleCenter: function(t, e) {
                        var n = new Lo(this.getX(),this.getY())
                          , i = this.bisector(n, t)
                          , r = this.bisector(t, e)
                          , o = new F(i,r)
                          , s = null;
                        try {
                            s = new Lo(o.getX(),o.getY())
                        } catch (i) {
                            if (!(i instanceof _))
                                throw i;
                            D.err.println("a: " + n + "  b: " + t + "  c: " + e),
                            D.err.println(i)
                        }
                        return s
                    },
                    dot: function(t) {
                        return this.p.x * t.getX() + this.p.y * t.getY()
                    },
                    magn: function() {
                        return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y)
                    },
                    getZ: function() {
                        return this.p.z
                    },
                    bisector: function(t, e) {
                        var n = e.getX() - t.getX()
                          , i = e.getY() - t.getY();
                        return new F(new F(t.getX() + n / 2,t.getY() + i / 2,1),new F(t.getX() - i + n / 2,t.getY() + n + i / 2,1))
                    },
                    equals: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.p.x === t.getX() && this.p.y === t.getY()
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            return this.p.distance(e.getCoordinate()) < n
                        }
                    },
                    getCoordinate: function() {
                        return this.p
                    },
                    isInCircle: function(t, e, n) {
                        return bo.isInCircleRobust(t.p, e.p, n.p, this.p)
                    },
                    interpolateZValue: function(t, e, n) {
                        var i = t.getX()
                          , r = t.getY()
                          , o = e.getX() - i
                          , s = n.getX() - i
                          , a = e.getY() - r
                          , u = n.getY() - r
                          , l = o * u - s * a
                          , c = this.getX() - i
                          , h = this.getY() - r
                          , f = (u * c - s * h) / l
                          , d = (-a * c + o * h) / l;
                        return t.getZ() + f * (e.getZ() - t.getZ()) + d * (n.getZ() - t.getZ())
                    },
                    midPoint: function(t) {
                        return new Lo((this.p.x + t.getX()) / 2,(this.p.y + t.getY()) / 2,(this.p.z + t.getZ()) / 2)
                    },
                    rightOf: function(t) {
                        return this.isCCW(t.dest(), t.orig())
                    },
                    isCCW: function(t, e) {
                        return (t.p.x - this.p.x) * (e.p.y - this.p.y) - (t.p.y - this.p.y) * (e.p.x - this.p.x) > 0
                    },
                    getX: function() {
                        return this.p.x
                    },
                    crossProduct: function(t) {
                        return this.p.x * t.getY() - this.p.y * t.getX()
                    },
                    setZ: function(t) {
                        this.p.z = t
                    },
                    times: function(t) {
                        return new Lo(t * this.p.x,t * this.p.y)
                    },
                    cross: function() {
                        return new Lo(this.p.y,-this.p.x)
                    },
                    leftOf: function(t) {
                        return this.isCCW(t.orig(), t.dest())
                    },
                    toString: function() {
                        return "POINT (" + this.p.x + " " + this.p.y + ")"
                    },
                    sub: function(t) {
                        return new Lo(this.p.x - t.getX(),this.p.y - t.getY())
                    },
                    getY: function() {
                        return this.p.y
                    },
                    classify: function(t, e) {
                        var n = this
                          , i = e.sub(t)
                          , r = n.sub(t)
                          , o = i.crossProduct(r);
                        return o > 0 ? Lo.LEFT : o < 0 ? Lo.RIGHT : i.getX() * r.getX() < 0 || i.getY() * r.getY() < 0 ? Lo.BEHIND : i.magn() < r.magn() ? Lo.BEYOND : t.equals(n) ? Lo.ORIGIN : e.equals(n) ? Lo.DESTINATION : Lo.BETWEEN
                    },
                    sum: function(t) {
                        return new Lo(this.p.x + t.getX(),this.p.y + t.getY())
                    },
                    distance: function(t, e) {
                        return Math.sqrt(Math.pow(e.getX() - t.getX(), 2) + Math.pow(e.getY() - t.getY(), 2))
                    },
                    circumRadiusRatio: function(t, e) {
                        var n = this.circleCenter(t, e)
                          , i = this.distance(n, t)
                          , r = this.distance(this, t)
                          , o = this.distance(t, e);
                        return o < r && (r = o),
                        o = this.distance(e, this),
                        o < r && (r = o),
                        i / r
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Lo
                    }
                }),
                Lo.interpolateZ = function() {
                    if (3 === arguments.length) {
                        var t = arguments[0]
                          , e = arguments[1]
                          , n = arguments[2]
                          , i = e.distance(n)
                          , r = t.distance(e)
                          , o = n.z - e.z;
                        return e.z + o * (r / i)
                    }
                    if (4 === arguments.length) {
                        var s = arguments[0]
                          , a = arguments[1]
                          , u = arguments[2]
                          , l = arguments[3]
                          , c = a.x
                          , h = a.y
                          , f = u.x - c
                          , d = l.x - c
                          , g = u.y - h
                          , p = l.y - h
                          , m = f * p - d * g
                          , y = s.x - c
                          , v = s.y - h
                          , E = (p * y - d * v) / m
                          , x = (-g * y + f * v) / m;
                        return a.z + E * (u.z - a.z) + x * (l.z - a.z)
                    }
                }
                ,
                Lo.LEFT = 0,
                Lo.RIGHT = 1,
                Lo.BEYOND = 2,
                Lo.BEHIND = 3,
                Lo.BETWEEN = 4,
                Lo.ORIGIN = 5,
                Lo.DESTINATION = 6,
                c(To, Lo),
                e(To.prototype, {
                    getConstraint: function() {
                        return this.constraint
                    },
                    setOnConstraint: function(t) {
                        this._isOnConstraint = t
                    },
                    merge: function(t) {
                        t._isOnConstraint && (this._isOnConstraint = !0,
                        this.constraint = t.constraint)
                    },
                    isOnConstraint: function() {
                        return this._isOnConstraint
                    },
                    setConstraint: function(t) {
                        this._isOnConstraint = !0,
                        this.constraint = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return To
                    }
                }),
                e(Ro.prototype, {
                    equalsNonOriented: function(t) {
                        return !!this.equalsOriented(t) || !!this.equalsOriented(t.sym())
                    },
                    toLineSegment: function() {
                        return new ce(this.vertex.getCoordinate(),this.dest().getCoordinate())
                    },
                    dest: function() {
                        return this.sym().orig()
                    },
                    oNext: function() {
                        return this.next
                    },
                    equalsOriented: function(t) {
                        return !(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))
                    },
                    dNext: function() {
                        return this.sym().oNext().sym()
                    },
                    lPrev: function() {
                        return this.next.sym()
                    },
                    rPrev: function() {
                        return this.sym().oNext()
                    },
                    rot: function() {
                        return this._rot
                    },
                    oPrev: function() {
                        return this._rot.next._rot
                    },
                    sym: function() {
                        return this._rot._rot
                    },
                    setOrig: function(t) {
                        this.vertex = t
                    },
                    lNext: function() {
                        return this.invRot().oNext().rot()
                    },
                    getLength: function() {
                        return this.orig().getCoordinate().distance(this.dest().getCoordinate())
                    },
                    invRot: function() {
                        return this._rot.sym()
                    },
                    setDest: function(t) {
                        this.sym().setOrig(t)
                    },
                    setData: function(t) {
                        this.data = t
                    },
                    getData: function() {
                        return this.data
                    },
                    delete: function() {
                        this._rot = null
                    },
                    orig: function() {
                        return this.vertex
                    },
                    rNext: function() {
                        return this._rot.next.invRot()
                    },
                    toString: function() {
                        var t = this.vertex.getCoordinate()
                          , e = this.dest().getCoordinate();
                        return re.toLineString(t, e)
                    },
                    isLive: function() {
                        return null !== this._rot
                    },
                    getPrimary: function() {
                        return this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0 ? this : this.sym()
                    },
                    dPrev: function() {
                        return this.invRot().oNext().invRot()
                    },
                    setNext: function(t) {
                        this.next = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ro
                    }
                }),
                Ro.makeEdge = function(t, e) {
                    var n = new Ro
                      , i = new Ro
                      , r = new Ro
                      , o = new Ro;
                    n._rot = i,
                    i._rot = r,
                    r._rot = o,
                    o._rot = n,
                    n.setNext(n),
                    i.setNext(o),
                    r.setNext(r),
                    o.setNext(i);
                    var s = n;
                    return s.setOrig(t),
                    s.setDest(e),
                    s
                }
                ,
                Ro.swap = function(t) {
                    var e = t.oPrev()
                      , n = t.sym().oPrev();
                    Ro.splice(t, e),
                    Ro.splice(t.sym(), n),
                    Ro.splice(t, e.lNext()),
                    Ro.splice(t.sym(), n.lNext()),
                    t.setOrig(e.dest()),
                    t.setDest(n.dest())
                }
                ,
                Ro.splice = function(t, e) {
                    var n = t.oNext().rot()
                      , i = e.oNext().rot()
                      , r = e.oNext()
                      , o = t.oNext()
                      , s = i.oNext()
                      , a = n.oNext();
                    t.setNext(r),
                    e.setNext(o),
                    n.setNext(s),
                    i.setNext(a)
                }
                ,
                Ro.connect = function(t, e) {
                    var n = Ro.makeEdge(t.dest(), e.orig());
                    return Ro.splice(n, t.lNext()),
                    Ro.splice(n.sym(), e),
                    n
                }
                ,
                e(Oo.prototype, {
                    insertSite: function(t) {
                        var e = this.subdiv.locate(t);
                        if (this.subdiv.isVertexOfEdge(e, t))
                            return e;
                        this.subdiv.isOnEdge(e, t.getCoordinate()) && (e = e.oPrev(),
                        this.subdiv.delete(e.oNext()));
                        var n = this.subdiv.makeEdge(e.orig(), t);
                        Ro.splice(n, e);
                        var i = n;
                        do {
                            n = this.subdiv.connect(e, n.sym()),
                            e = n.oPrev()
                        } while (e.lNext() !== i);for (; ; ) {
                            var r = e.oPrev();
                            if (r.dest().rightOf(e) && t.isInCircle(e.orig(), r.dest(), e.dest()))
                                Ro.swap(e),
                                e = e.oPrev();
                            else {
                                if (e.oNext() === i)
                                    return n;
                                e = e.oNext().lPrev()
                            }
                        }
                    },
                    insertSites: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.insertSite(n)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Oo
                    }
                }),
                e(Po.prototype, {
                    locate: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Po
                    }
                }),
                e(Mo.prototype, {
                    init: function() {
                        this.lastEdge = this.findEdge()
                    },
                    locate: function(t) {
                        this.lastEdge.isLive() || this.init();
                        var e = this.subdiv.locateFromEdge(t, this.lastEdge);
                        return this.lastEdge = e,
                        e
                    },
                    findEdge: function() {
                        return this.subdiv.getEdges().iterator().next()
                    },
                    interfaces_: function() {
                        return [Po]
                    },
                    getClass: function() {
                        return Mo
                    }
                }),
                c(Ao, l),
                e(Ao.prototype, {
                    getSegment: function() {
                        return this.seg
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ao
                    }
                }),
                Ao.msgWithSpatial = function(t, e) {
                    return null !== e ? t + " [ " + e + " ]" : t
                }
                ,
                e(Do.prototype, {
                    visit: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Do
                    }
                }),
                e(Fo.prototype, {
                    getTriangleVertices: function(t) {
                        var e = new qo;
                        return this.visitTriangles(e, t),
                        e.getTriangleVertices()
                    },
                    isFrameVertex: function(t) {
                        return !!t.equals(this.frameVertex[0]) || !!t.equals(this.frameVertex[1]) || !!t.equals(this.frameVertex[2])
                    },
                    isVertexOfEdge: function(t, e) {
                        return !(!e.equals(t.orig(), this.tolerance) && !e.equals(t.dest(), this.tolerance))
                    },
                    connect: function(t, e) {
                        var n = Ro.connect(t, e);
                        return this.quadEdges.add(n),
                        n
                    },
                    getVoronoiCellPolygon: function(t, e) {
                        var n = new I
                          , i = t;
                        do {
                            var r = t.rot().orig().getCoordinate();
                            n.add(r),
                            t = t.oPrev()
                        } while (t !== i);var o = new N;
                        o.addAll(n, !1),
                        o.closeRing(),
                        o.size() < 4 && (D.out.println(o),
                        o.add(o.get(o.size() - 1), !0));
                        var s = o.toCoordinateArray()
                          , a = e.createPolygon(e.createLinearRing(s), null)
                          , u = i.orig();
                        return a.setUserData(u.getCoordinate()),
                        a
                    },
                    setLocator: function(t) {
                        this.locator = t
                    },
                    initSubdiv: function() {
                        var t = this.makeEdge(this.frameVertex[0], this.frameVertex[1])
                          , e = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);
                        Ro.splice(t.sym(), e);
                        var n = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);
                        return Ro.splice(e.sym(), n),
                        Ro.splice(n.sym(), t),
                        t
                    },
                    isFrameBorderEdge: function(t) {
                        var e = new Array(3).fill(null);
                        Fo.getTriangleEdges(t, e);
                        var n = new Array(3).fill(null);
                        Fo.getTriangleEdges(t.sym(), n);
                        var i = t.lNext().dest();
                        if (this.isFrameVertex(i))
                            return !0;
                        var r = t.sym().lNext().dest();
                        return !!this.isFrameVertex(r)
                    },
                    makeEdge: function(t, e) {
                        var n = Ro.makeEdge(t, e);
                        return this.quadEdges.add(n),
                        n
                    },
                    visitTriangles: function(t, e) {
                        this.visitedKey++;
                        var n = new ge;
                        n.push(this.startingEdge);
                        for (var i = new Z; !n.empty(); ) {
                            var r = n.pop();
                            if (!i.contains(r)) {
                                var o = this.fetchTriangleToVisit(r, n, e, i);
                                null !== o && t.visit(o)
                            }
                        }
                    },
                    isFrameEdge: function(t) {
                        return !(!this.isFrameVertex(t.orig()) && !this.isFrameVertex(t.dest()))
                    },
                    isOnEdge: function(t, e) {
                        return this.seg.setCoordinates(t.orig().getCoordinate(), t.dest().getCoordinate()),
                        this.seg.distance(e) < this.edgeCoincidenceTolerance
                    },
                    getEnvelope: function() {
                        return new C(this.frameEnv)
                    },
                    createFrame: function(t) {
                        var e = t.getWidth()
                          , n = t.getHeight()
                          , i = 0;
                        i = e > n ? 10 * e : 10 * n,
                        this.frameVertex[0] = new Lo((t.getMaxX() + t.getMinX()) / 2,t.getMaxY() + i),
                        this.frameVertex[1] = new Lo(t.getMinX() - i,t.getMinY() - i),
                        this.frameVertex[2] = new Lo(t.getMaxX() + i,t.getMinY() - i),
                        this.frameEnv = new C(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate()),
                        this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())
                    },
                    getTriangleCoordinates: function(t) {
                        var e = new Bo;
                        return this.visitTriangles(e, t),
                        e.getTriangles()
                    },
                    getVertices: function(t) {
                        for (var e = new Z, n = this.quadEdges.iterator(); n.hasNext(); ) {
                            var i = n.next()
                              , r = i.orig();
                            !t && this.isFrameVertex(r) || e.add(r);
                            var o = i.dest();
                            !t && this.isFrameVertex(o) || e.add(o)
                        }
                        return e
                    },
                    fetchTriangleToVisit: function(t, e, n, i) {
                        var r = t
                          , o = 0
                          , s = !1;
                        do {
                            this.triEdges[o] = r,
                            this.isFrameEdge(r) && (s = !0);
                            var a = r.sym();
                            i.contains(a) || e.push(a),
                            i.add(r),
                            o++,
                            r = r.lNext()
                        } while (r !== t);return s && !n ? null : this.triEdges
                    },
                    getEdges: function() {
                        if (0 === arguments.length)
                            return this.quadEdges;
                        if (1 === arguments.length) {
                            for (var t = arguments[0], e = this.getPrimaryEdges(!1), n = new Array(e.size()).fill(null), i = 0, r = e.iterator(); r.hasNext(); ) {
                                var o = r.next();
                                n[i++] = t.createLineString([o.orig().getCoordinate(), o.dest().getCoordinate()])
                            }
                            return t.createMultiLineString(n)
                        }
                    },
                    getVertexUniqueEdges: function(t) {
                        for (var e = new I, n = new Z, i = this.quadEdges.iterator(); i.hasNext(); ) {
                            var r = i.next()
                              , o = r.orig();
                            n.contains(o) || (n.add(o),
                            !t && this.isFrameVertex(o) || e.add(r));
                            var s = r.sym()
                              , a = s.orig();
                            n.contains(a) || (n.add(a),
                            !t && this.isFrameVertex(a) || e.add(s))
                        }
                        return e
                    },
                    getTriangleEdges: function(t) {
                        var e = new ko;
                        return this.visitTriangles(e, t),
                        e.getTriangleEdges()
                    },
                    getPrimaryEdges: function(t) {
                        this.visitedKey++;
                        var e = new I
                          , n = new ge;
                        n.push(this.startingEdge);
                        for (var i = new Z; !n.empty(); ) {
                            var r = n.pop();
                            if (!i.contains(r)) {
                                var o = r.getPrimary();
                                !t && this.isFrameEdge(o) || e.add(o),
                                n.push(r.oNext()),
                                n.push(r.sym().oNext()),
                                i.add(r),
                                i.add(r.sym())
                            }
                        }
                        return e
                    },
                    delete: function(t) {
                        Ro.splice(t, t.oPrev()),
                        Ro.splice(t.sym(), t.sym().oPrev());
                        var e = t.sym()
                          , n = t.rot()
                          , i = t.rot().sym();
                        this.quadEdges.remove(t),
                        this.quadEdges.remove(e),
                        this.quadEdges.remove(n),
                        this.quadEdges.remove(i),
                        t.delete(),
                        e.delete(),
                        n.delete(),
                        i.delete()
                    },
                    locateFromEdge: function(t, e) {
                        for (var n = 0, i = this.quadEdges.size(), r = e; ; ) {
                            if (++n > i)
                                throw new Ao(r.toLineSegment());
                            if (t.equals(r.orig()) || t.equals(r.dest()))
                                break;
                            if (t.rightOf(r))
                                r = r.sym();
                            else if (t.rightOf(r.oNext())) {
                                if (t.rightOf(r.dPrev()))
                                    break;
                                r = r.dPrev()
                            } else
                                r = r.oNext()
                        }
                        return r
                    },
                    getTolerance: function() {
                        return this.tolerance
                    },
                    getVoronoiCellPolygons: function(t) {
                        this.visitTriangles(new Go, !0);
                        for (var e = new I, n = this.getVertexUniqueEdges(!1), i = n.iterator(); i.hasNext(); ) {
                            var r = i.next();
                            e.add(this.getVoronoiCellPolygon(r, t))
                        }
                        return e
                    },
                    getVoronoiDiagram: function(t) {
                        var e = this.getVoronoiCellPolygons(t);
                        return t.createGeometryCollection(ne.toGeometryArray(e))
                    },
                    getTriangles: function(t) {
                        for (var e = this.getTriangleCoordinates(!1), n = new Array(e.size()).fill(null), i = 0, r = e.iterator(); r.hasNext(); ) {
                            var o = r.next();
                            n[i++] = t.createPolygon(t.createLinearRing(o), null)
                        }
                        return t.createGeometryCollection(n)
                    },
                    insertSite: function(t) {
                        var e = this.locate(t);
                        if (t.equals(e.orig(), this.tolerance) || t.equals(e.dest(), this.tolerance))
                            return e;
                        var n = this.makeEdge(e.orig(), t);
                        Ro.splice(n, e);
                        var i = n;
                        do {
                            n = this.connect(e, n.sym()),
                            e = n.oPrev()
                        } while (e.lNext() !== i);return i
                    },
                    locate: function() {
                        if (1 === arguments.length) {
                            if (arguments[0]instanceof Lo) {
                                var t = arguments[0];
                                return this.locator.locate(t)
                            }
                            if (arguments[0]instanceof d) {
                                var e = arguments[0];
                                return this.locator.locate(new Lo(e))
                            }
                        } else if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , r = this.locator.locate(new Lo(n));
                            if (null === r)
                                return null;
                            var o = r;
                            r.dest().getCoordinate().equals2D(n) && (o = r.sym());
                            var s = o;
                            do {
                                if (s.dest().getCoordinate().equals2D(i))
                                    return s;
                                s = s.oNext()
                            } while (s !== o);return null
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Fo
                    }
                }),
                Fo.getTriangleEdges = function(t, e) {
                    if (e[0] = t,
                    e[1] = e[0].lNext(),
                    e[2] = e[1].lNext(),
                    e[2].lNext() !== e[0])
                        throw new i("Edges do not form a triangle")
                }
                ,
                e(Go.prototype, {
                    visit: function(t) {
                        for (var e = t[0].orig().getCoordinate(), n = t[1].orig().getCoordinate(), i = t[2].orig().getCoordinate(), r = Ci.circumcentre(e, n, i), o = new Lo(r), s = 0; s < 3; s++)
                            t[s].rot().setOrig(o)
                    },
                    interfaces_: function() {
                        return [Do]
                    },
                    getClass: function() {
                        return Go
                    }
                }),
                e(ko.prototype, {
                    getTriangleEdges: function() {
                        return this.triList
                    },
                    visit: function(t) {
                        this.triList.add(t.clone())
                    },
                    interfaces_: function() {
                        return [Do]
                    },
                    getClass: function() {
                        return ko
                    }
                }),
                e(qo.prototype, {
                    visit: function(t) {
                        this.triList.add([t[0].orig(), t[1].orig(), t[2].orig()])
                    },
                    getTriangleVertices: function() {
                        return this.triList
                    },
                    interfaces_: function() {
                        return [Do]
                    },
                    getClass: function() {
                        return qo
                    }
                }),
                e(Bo.prototype, {
                    checkTriangleSize: function(t) {
                        t.length >= 2 ? re.toLineString(t[0], t[1]) : t.length >= 1 && re.toPoint(t[0])
                    },
                    visit: function(t) {
                        this.coordList.clear();
                        for (var e = 0; e < 3; e++) {
                            var n = t[e].orig();
                            this.coordList.add(n.getCoordinate())
                        }
                        if (this.coordList.size() > 0) {
                            this.coordList.closeRing();
                            var i = this.coordList.toCoordinateArray();
                            if (4 !== i.length)
                                return null;
                            this.triCoords.add(i)
                        }
                    },
                    getTriangles: function() {
                        return this.triCoords
                    },
                    interfaces_: function() {
                        return [Do]
                    },
                    getClass: function() {
                        return Bo
                    }
                }),
                Fo.TriangleCircumcentreVisitor = Go,
                Fo.TriangleEdgesListVisitor = ko,
                Fo.TriangleVertexListVisitor = qo,
                Fo.TriangleCoordinatesVisitor = Bo,
                Fo.EDGE_COINCIDENCE_TOL_FACTOR = 1e3,
                e(Uo.prototype, {
                    getLineSegment: function() {
                        return this.ls
                    },
                    getEndZ: function() {
                        return this.ls.getCoordinate(1).z
                    },
                    getStartZ: function() {
                        return this.ls.getCoordinate(0).z
                    },
                    intersection: function(t) {
                        return this.ls.intersection(t.getLineSegment())
                    },
                    getStart: function() {
                        return this.ls.getCoordinate(0)
                    },
                    getEnd: function() {
                        return this.ls.getCoordinate(1)
                    },
                    getEndY: function() {
                        return this.ls.getCoordinate(1).y
                    },
                    getStartX: function() {
                        return this.ls.getCoordinate(0).x
                    },
                    equalsTopo: function(t) {
                        return this.ls.equalsTopo(t.getLineSegment())
                    },
                    getStartY: function() {
                        return this.ls.getCoordinate(0).y
                    },
                    setData: function(t) {
                        this.data = t
                    },
                    getData: function() {
                        return this.data
                    },
                    getEndX: function() {
                        return this.ls.getCoordinate(1).x
                    },
                    toString: function() {
                        return this.ls.toString()
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Uo
                    }
                }),
                e(Vo.prototype, {
                    visit: function(t) {},
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Vo
                    }
                }),
                e(zo.prototype, {
                    isRepeated: function() {
                        return this.count > 1
                    },
                    getRight: function() {
                        return this.right
                    },
                    getCoordinate: function() {
                        return this.p
                    },
                    setLeft: function(t) {
                        this.left = t
                    },
                    getX: function() {
                        return this.p.x
                    },
                    getData: function() {
                        return this.data
                    },
                    getCount: function() {
                        return this.count
                    },
                    getLeft: function() {
                        return this.left
                    },
                    getY: function() {
                        return this.p.y
                    },
                    increment: function() {
                        this.count = this.count + 1
                    },
                    setRight: function(t) {
                        this.right = t
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return zo
                    }
                }),
                e(jo.prototype, {
                    insert: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return this.insert(t, null)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            if (null === this.root)
                                return this.root = new zo(e,n),
                                this.root;
                            if (this.tolerance > 0) {
                                var i = this.findBestMatchNode(e);
                                if (null !== i)
                                    return i.increment(),
                                    i
                            }
                            return this.insertExact(e, n)
                        }
                    },
                    query: function() {
                        var t = arguments
                          , e = this;
                        if (1 === arguments.length) {
                            var n = arguments[0]
                              , i = new I;
                            return this.query(n, i),
                            i
                        }
                        if (2 === arguments.length)
                            if (arguments[0]instanceof C && b(arguments[1], v))
                                !function() {
                                    var n = t[0]
                                      , i = t[1];
                                    e.queryNode(e.root, n, !0, {
                                        interfaces_: function() {
                                            return [Vo]
                                        },
                                        visit: function(t) {
                                            i.add(t)
                                        }
                                    })
                                }();
                            else if (arguments[0]instanceof C && b(arguments[1], Vo)) {
                                var r = arguments[0]
                                  , o = arguments[1];
                                this.queryNode(this.root, r, !0, o)
                            }
                    },
                    queryNode: function(t, e, n, i) {
                        if (null === t)
                            return null;
                        var r = null
                          , o = null
                          , s = null;
                        n ? (r = e.getMinX(),
                        o = e.getMaxX(),
                        s = t.getX()) : (r = e.getMinY(),
                        o = e.getMaxY(),
                        s = t.getY());
                        var a = r < s
                          , u = s <= o;
                        a && this.queryNode(t.getLeft(), e, !n, i),
                        e.contains(t.getCoordinate()) && i.visit(t),
                        u && this.queryNode(t.getRight(), e, !n, i)
                    },
                    findBestMatchNode: function(t) {
                        var e = new Yo(t,this.tolerance);
                        return this.query(e.queryEnvelope(), e),
                        e.getNode()
                    },
                    isEmpty: function() {
                        return null === this.root
                    },
                    insertExact: function(t, e) {
                        for (var n = this.root, i = this.root, r = !0, o = !0; null !== n; ) {
                            if (null !== n) {
                                if (t.distance(n.getCoordinate()) <= this.tolerance)
                                    return n.increment(),
                                    n
                            }
                            o = r ? t.x < n.getX() : t.y < n.getY(),
                            i = n,
                            n = o ? n.getLeft() : n.getRight(),
                            r = !r
                        }
                        this.numberOfNodes = this.numberOfNodes + 1;
                        var s = new zo(t,e);
                        return o ? i.setLeft(s) : i.setRight(s),
                        s
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return jo
                    }
                }),
                jo.toCoordinates = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return jo.toCoordinates(t, !1)
                    }
                    if (2 === arguments.length) {
                        for (var e = arguments[0], n = arguments[1], i = new N, r = e.iterator(); r.hasNext(); )
                            for (var o = r.next(), s = n ? o.getCount() : 1, a = 0; a < s; a++)
                                i.add(o.getCoordinate(), !0);
                        return i.toCoordinateArray()
                    }
                }
                ,
                e(Yo.prototype, {
                    visit: function(t) {
                        var e = this.p.distance(t.getCoordinate());
                        if (!(e <= this.tolerance))
                            return null;
                        var n = !1;
                        (null === this.matchNode || e < this.matchDist || null !== this.matchNode && e === this.matchDist && t.getCoordinate().compareTo(this.matchNode.getCoordinate()) < 1) && (n = !0),
                        n && (this.matchNode = t,
                        this.matchDist = e)
                    },
                    queryEnvelope: function() {
                        var t = new C(this.p);
                        return t.expandBy(this.tolerance),
                        t
                    },
                    getNode: function() {
                        return this.matchNode
                    },
                    interfaces_: function() {
                        return [Vo]
                    },
                    getClass: function() {
                        return Yo
                    }
                }),
                jo.BestMatchVisitor = Yo,
                e(Xo.prototype, {
                    getInitialVertices: function() {
                        return this.initialVertices
                    },
                    getKDT: function() {
                        return this.kdt
                    },
                    enforceConstraints: function() {
                        this.addConstraintVertices();
                        var t = 0
                          , e = 0;
                        do {
                            e = this.enforceGabriel(this.segments),
                            t++
                        } while (e > 0 && t < Xo.MAX_SPLIT_ITER)
                    },
                    insertSites: function(t) {
                        for (var e = t.iterator(); e.hasNext(); ) {
                            var n = e.next();
                            this.insertSite(n)
                        }
                    },
                    getVertexFactory: function() {
                        return this.vertexFactory
                    },
                    getPointArray: function() {
                        for (var t = new Array(this.initialVertices.size() + this.segVertices.size()).fill(null), e = 0, n = this.initialVertices.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            t[e++] = i.getCoordinate()
                        }
                        for (var r = this.segVertices.iterator(); r.hasNext(); ) {
                            var i = r.next();
                            t[e++] = i.getCoordinate()
                        }
                        return t
                    },
                    setConstraints: function(t, e) {
                        this.segments = t,
                        this.segVertices = e
                    },
                    computeConvexHull: function() {
                        var t = new ne
                          , e = this.getPointArray()
                          , n = new me(e,t);
                        this.convexHull = n.getConvexHull()
                    },
                    addConstraintVertices: function() {
                        this.computeConvexHull(),
                        this.insertSites(this.segVertices)
                    },
                    findNonGabrielPoint: function(t) {
                        var e = t.getStart()
                          , n = t.getEnd()
                          , i = new d((e.x + n.x) / 2,(e.y + n.y) / 2)
                          , o = e.distance(i)
                          , s = new C(i);
                        s.expandBy(o);
                        for (var a = this.kdt.query(s), u = null, l = r.MAX_VALUE, c = a.iterator(); c.hasNext(); ) {
                            var h = c.next()
                              , f = h.getCoordinate();
                            if (!f.equals2D(e) && !f.equals2D(n)) {
                                var g = i.distance(f);
                                if (g < o) {
                                    var p = g;
                                    (null === u || p < l) && (u = f,
                                    l = p)
                                }
                            }
                        }
                        return u
                    },
                    getConstraintSegments: function() {
                        return this.segments
                    },
                    setSplitPointFinder: function(t) {
                        this.splitFinder = t
                    },
                    getConvexHull: function() {
                        return this.convexHull
                    },
                    getTolerance: function() {
                        return this.tolerance
                    },
                    enforceGabriel: function(t) {
                        for (var e = new I, n = 0, i = new I, r = t.iterator(); r.hasNext(); ) {
                            var o = r.next()
                              , s = this.findNonGabrielPoint(o);
                            if (null !== s) {
                                this.splitPt = this.splitFinder.findSplitPoint(o, s);
                                var a = this.createVertex(this.splitPt, o)
                                  , u = (this.insertSite(a),
                                new Uo(o.getStartX(),o.getStartY(),o.getStartZ(),a.getX(),a.getY(),a.getZ(),o.getData()))
                                  , l = new Uo(a.getX(),a.getY(),a.getZ(),o.getEndX(),o.getEndY(),o.getEndZ(),o.getData());
                                e.add(u),
                                e.add(l),
                                i.add(o),
                                n += 1
                            }
                        }
                        return t.removeAll(i),
                        t.addAll(e),
                        n
                    },
                    createVertex: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0]
                              , e = null;
                            return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(t, null) : new To(t)
                        }
                        if (2 === arguments.length) {
                            var n = arguments[0]
                              , i = arguments[1]
                              , e = null;
                            return e = null !== this.vertexFactory ? this.vertexFactory.createVertex(n, i) : new To(n),
                            e.setOnConstraint(!0),
                            e
                        }
                    },
                    getSubdivision: function() {
                        return this.subdiv
                    },
                    computeBoundingBox: function() {
                        var t = Xo.computeVertexEnvelope(this.initialVertices)
                          , e = Xo.computeVertexEnvelope(this.segVertices)
                          , n = new C(t);
                        n.expandToInclude(e);
                        var i = .2 * n.getWidth()
                          , r = .2 * n.getHeight()
                          , o = Math.max(i, r);
                        this.computeAreaEnv = new C(n),
                        this.computeAreaEnv.expandBy(o)
                    },
                    setVertexFactory: function(t) {
                        this.vertexFactory = t
                    },
                    formInitialDelaunay: function() {
                        this.computeBoundingBox(),
                        this.subdiv = new Fo(this.computeAreaEnv,this.tolerance),
                        this.subdiv.setLocator(new Mo(this.subdiv)),
                        this.incDel = new Oo(this.subdiv),
                        this.insertSites(this.initialVertices)
                    },
                    insertSite: function() {
                        if (arguments[0]instanceof To) {
                            var t = arguments[0]
                              , e = this.kdt.insert(t.getCoordinate(), t);
                            if (e.isRepeated()) {
                                var n = e.getData();
                                return n.merge(t),
                                n
                            }
                            return this.incDel.insertSite(t),
                            t
                        }
                        if (arguments[0]instanceof d) {
                            var i = arguments[0];
                            this.insertSite(this.createVertex(i))
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Xo
                    }
                }),
                Xo.computeVertexEnvelope = function(t) {
                    for (var e = new C, n = t.iterator(); n.hasNext(); ) {
                        var i = n.next();
                        e.expandToInclude(i.getCoordinate())
                    }
                    return e
                }
                ,
                Xo.MAX_SPLIT_ITER = 99,
                e(Ho.prototype, {
                    create: function() {
                        if (null !== this.subdiv)
                            return null;
                        var t = Ho.envelope(this.siteCoords)
                          , e = Ho.toVertices(this.siteCoords);
                        this.subdiv = new Fo(t,this.tolerance),
                        new Oo(this.subdiv).insertSites(e)
                    },
                    setTolerance: function(t) {
                        this.tolerance = t
                    },
                    setSites: function() {
                        if (arguments[0]instanceof q) {
                            var t = arguments[0];
                            this.siteCoords = Ho.extractUniqueCoordinates(t)
                        } else if (b(arguments[0], m)) {
                            var e = arguments[0];
                            this.siteCoords = Ho.unique(X.toCoordinateArray(e))
                        }
                    },
                    getEdges: function(t) {
                        return this.create(),
                        this.subdiv.getEdges(t)
                    },
                    getSubdivision: function() {
                        return this.create(),
                        this.subdiv
                    },
                    getTriangles: function(t) {
                        return this.create(),
                        this.subdiv.getTriangles(t)
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Ho
                    }
                }),
                Ho.extractUniqueCoordinates = function(t) {
                    if (null === t)
                        return new N;
                    var e = t.getCoordinates();
                    return Ho.unique(e)
                }
                ,
                Ho.envelope = function(t) {
                    for (var e = new C, n = t.iterator(); n.hasNext(); ) {
                        var i = n.next();
                        e.expandToInclude(i)
                    }
                    return e
                }
                ,
                Ho.unique = function(t) {
                    var e = X.copyDeep(t);
                    return ut.sort(e),
                    new N(e,!1)
                }
                ,
                Ho.toVertices = function(t) {
                    for (var e = new I, n = t.iterator(); n.hasNext(); ) {
                        var i = n.next();
                        e.add(new Lo(i))
                    }
                    return e
                }
                ,
                e(Wo.prototype, {
                    createSiteVertices: function(t) {
                        for (var e = new I, n = t.iterator(); n.hasNext(); ) {
                            var i = n.next();
                            this.constraintVertexMap.containsKey(i) || e.add(new To(i))
                        }
                        return e
                    },
                    create: function() {
                        if (null !== this.subdiv)
                            return null;
                        var t = Ho.envelope(this.siteCoords)
                          , e = new I;
                        null !== this.constraintLines && (t.expandToInclude(this.constraintLines.getEnvelopeInternal()),
                        this.createVertices(this.constraintLines),
                        e = Wo.createConstraintSegments(this.constraintLines));
                        var n = this.createSiteVertices(this.siteCoords)
                          , i = new Xo(n,this.tolerance);
                        i.setConstraints(e, new I(this.constraintVertexMap.values())),
                        i.formInitialDelaunay(),
                        i.enforceConstraints(),
                        this.subdiv = i.getSubdivision()
                    },
                    setTolerance: function(t) {
                        this.tolerance = t
                    },
                    setConstraints: function(t) {
                        this.constraintLines = t
                    },
                    setSites: function(t) {
                        this.siteCoords = Ho.extractUniqueCoordinates(t)
                    },
                    getEdges: function(t) {
                        return this.create(),
                        this.subdiv.getEdges(t)
                    },
                    getSubdivision: function() {
                        return this.create(),
                        this.subdiv
                    },
                    getTriangles: function(t) {
                        return this.create(),
                        this.subdiv.getTriangles(t)
                    },
                    createVertices: function(t) {
                        for (var e = t.getCoordinates(), n = 0; n < e.length; n++) {
                            var i = new To(e[n]);
                            this.constraintVertexMap.put(e[n], i)
                        }
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Wo
                    }
                }),
                Wo.createConstraintSegments = function() {
                    if (1 === arguments.length) {
                        for (var t = arguments[0], e = Un.getLines(t), n = new I, i = e.iterator(); i.hasNext(); ) {
                            var r = i.next();
                            Wo.createConstraintSegments(r, n)
                        }
                        return n
                    }
                    if (2 === arguments.length)
                        for (var o = arguments[0], s = arguments[1], a = o.getCoordinates(), i = 1; i < a.length; i++)
                            s.add(new Uo(a[i - 1],a[i]))
                }
                ,
                e(Jo.prototype, {
                    create: function() {
                        if (null !== this.subdiv)
                            return null;
                        var t = Ho.envelope(this.siteCoords);
                        this.diagramEnv = t;
                        var e = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());
                        this.diagramEnv.expandBy(e),
                        null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv);
                        var n = Ho.toVertices(this.siteCoords);
                        this.subdiv = new Fo(t,this.tolerance),
                        new Oo(this.subdiv).insertSites(n)
                    },
                    getDiagram: function(t) {
                        this.create();
                        var e = this.subdiv.getVoronoiDiagram(t);
                        return Jo.clipGeometryCollection(e, this.diagramEnv)
                    },
                    setTolerance: function(t) {
                        this.tolerance = t
                    },
                    setSites: function() {
                        if (arguments[0]instanceof q) {
                            var t = arguments[0];
                            this.siteCoords = Ho.extractUniqueCoordinates(t)
                        } else if (b(arguments[0], m)) {
                            var e = arguments[0];
                            this.siteCoords = Ho.unique(X.toCoordinateArray(e))
                        }
                    },
                    setClipEnvelope: function(t) {
                        this.clipEnv = t
                    },
                    getSubdivision: function() {
                        return this.create(),
                        this.subdiv
                    },
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return Jo
                    }
                }),
                Jo.clipGeometryCollection = function(t, e) {
                    for (var n = t.getFactory().toGeometry(e), i = new I, r = 0; r < t.getNumGeometries(); r++) {
                        var o = t.getGeometryN(r)
                          , s = null;
                        e.contains(o.getEnvelopeInternal()) ? s = o : e.intersects(o.getEnvelopeInternal()) && (s = n.intersection(o),
                        s.setUserData(o.getUserData())),
                        null === s || s.isEmpty() || i.add(s)
                    }
                    return t.getFactory().createGeometryCollection(ne.toGeometryArray(i))
                }
                ;
                var Ms = Object.freeze({
                    Vertex: Lo
                })
                  , As = Object.freeze({
                    ConformingDelaunayTriangulationBuilder: Wo,
                    DelaunayTriangulationBuilder: Ho,
                    VoronoiDiagramBuilder: Jo,
                    quadedge: Ms
                });
                e($o.prototype, {
                    interfaces_: function() {
                        return []
                    },
                    getClass: function() {
                        return $o
                    }
                }),
                $o.union = function(t, e) {
                    if (t.isEmpty() || e.isEmpty()) {
                        if (t.isEmpty() && e.isEmpty())
                            return ni.createEmptyResult(ni.UNION, t, e, t.getFactory());
                        if (t.isEmpty())
                            return e.copy();
                        if (e.isEmpty())
                            return t.copy()
                    }
                    return t.checkNotGeometryCollection(t),
                    t.checkNotGeometryCollection(e),
                    ri.overlayOp(t, e, ni.UNION)
                }
                ,
                e(q.prototype, {
                    equalsTopo: function(t) {
                        return !!this.getEnvelopeInternal().equals(t.getEnvelopeInternal()) && io.relate(this, t).isEquals(this.getDimension(), t.getDimension())
                    },
                    union: function() {
                        if (0 === arguments.length)
                            return uo.union(this);
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return $o.union(this, t)
                        }
                    },
                    isValid: function() {
                        return zr.isValid(this)
                    },
                    intersection: function(t) {
                        if (this.isEmpty() || t.isEmpty())
                            return ni.createEmptyResult(ni.INTERSECTION, this, t, this.factory);
                        if (this.isGeometryCollection()) {
                            var e = t;
                            return ln.map(this, {
                                interfaces_: function() {
                                    return [MapOp]
                                },
                                map: function(t) {
                                    return t.intersection(e)
                                }
                            })
                        }
                        return this.checkNotGeometryCollection(this),
                        this.checkNotGeometryCollection(t),
                        ri.overlayOp(this, t, ni.INTERSECTION)
                    },
                    covers: function(t) {
                        return io.covers(this, t)
                    },
                    coveredBy: function(t) {
                        return io.coveredBy(this, t)
                    },
                    touches: function(t) {
                        return io.touches(this, t)
                    },
                    intersects: function(t) {
                        return io.intersects(this, t)
                    },
                    within: function(t) {
                        return io.within(this, t)
                    },
                    overlaps: function(t) {
                        return io.overlaps(this, t)
                    },
                    disjoint: function(t) {
                        return io.disjoint(this, t)
                    },
                    crosses: function(t) {
                        return io.crosses(this, t)
                    },
                    buffer: function() {
                        if (1 === arguments.length) {
                            var t = arguments[0];
                            return dr.bufferOp(this, t)
                        }
                        if (2 === arguments.length) {
                            var e = arguments[0]
                              , n = arguments[1];
                            return dr.bufferOp(this, e, n)
                        }
                        if (3 === arguments.length) {
                            var i = arguments[0]
                              , r = arguments[1]
                              , o = arguments[2];
                            return dr.bufferOp(this, i, r, o)
                        }
                    },
                    convexHull: function() {
                        return new me(this).getConvexHull()
                    },
                    relate: function() {
                        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)
                            e[n] = arguments[n];
                        return io.relate.apply(io, [this].concat(e))
                    },
                    getCentroid: function() {
                        if (this.isEmpty())
                            return this.factory.createPoint();
                        var t = fe.getCentroid(this);
                        return this.createPointFromInternalCoord(t, this)
                    },
                    getInteriorPoint: function() {
                        if (this.isEmpty())
                            return this.factory.createPoint();
                        var t = null
                          , e = this.getDimension();
                        if (0 === e) {
                            var n = new ui(this);
                            t = n.getInteriorPoint()
                        } else if (1 === e) {
                            var n = new ai(this);
                            t = n.getInteriorPoint()
                        } else {
                            var n = new oi(this);
                            t = n.getInteriorPoint()
                        }
                        return this.createPointFromInternalCoord(t, this)
                    },
                    symDifference: function(t) {
                        if (this.isEmpty() || t.isEmpty()) {
                            if (this.isEmpty() && t.isEmpty())
                                return ni.createEmptyResult(ni.SYMDIFFERENCE, this, t, this.factory);
                            if (this.isEmpty())
                                return t.copy();
                            if (t.isEmpty())
                                return this.copy()
                        }
                        return this.checkNotGeometryCollection(this),
                        this.checkNotGeometryCollection(t),
                        ri.overlayOp(this, t, ni.SYMDIFFERENCE)
                    },
                    createPointFromInternalCoord: function(t, e) {
                        return e.getPrecisionModel().makePrecise(t),
                        e.getFactory().createPoint(t)
                    },
                    toText: function() {
                        return (new re).write(this)
                    },
                    toString: function() {
                        this.toText()
                    },
                    contains: function(t) {
                        return io.contains(this, t)
                    },
                    difference: function(t) {
                        return this.isEmpty() ? ni.createEmptyResult(ni.DIFFERENCE, this, t, this.factory) : t.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this),
                        this.checkNotGeometryCollection(t),
                        ri.overlayOp(this, t, ni.DIFFERENCE))
                    },
                    isSimple: function() {
                        return new Xi(this).isSimple()
                    },
                    isWithinDistance: function(t, e) {
                        return !(this.getEnvelopeInternal().distance(t.getEnvelopeInternal()) > e) && vr.isWithinDistance(this, t, e)
                    },
                    distance: function(t) {
                        return vr.distance(this, t)
                    },
                    isEquivalentClass: function(t) {
                        return this.getClass() === t.getClass()
                    }
                });
                t.version = "1.3.0 (6e65adb)",
                t.algorithm = cs,
                t.densify = hs,
                t.dissolve = fs,
                t.geom = us,
                t.geomgraph = ds,
                t.index = ms,
                t.io = xs,
                t.noding = Is,
                t.operation = Rs,
                t.precision = Os,
                t.simplify = Ps,
                t.triangulate = As,
                Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            })
        }
        , {}],
        22: [function(t, e, n) {
            function i(t) {
                if (!t)
                    throw new Error("No obj passed");
                var e = r(t);
                if (e.length > 1 && "number" == typeof e[0] && "number" == typeof e[1])
                    return e;
                throw new Error("Coordinate is not a valid Point")
            }
            function r(t) {
                if (!t)
                    throw new Error("No obj passed");
                var e;
                if (t.length ? e = t : t.coordinates ? e = t.coordinates : t.geometry && t.geometry.coordinates && (e = t.geometry.coordinates),
                e)
                    return o(e),
                    e;
                throw new Error("No valid coordinates")
            }
            function o(t) {
                if (t.length > 1 && "number" == typeof t[0] && "number" == typeof t[1])
                    return !0;
                if (Array.isArray(t[0]) && t[0].length)
                    return o(t[0]);
                throw new Error("coordinates must only contain numbers")
            }
            function s(t, e, n) {
                if (!e || !n)
                    throw new Error("type and name required");
                if (!t || t.type !== e)
                    throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
            }
            function a(t, e, n) {
                if (!t)
                    throw new Error("No feature passed");
                if (!n)
                    throw new Error(".featureOf() requires a name");
                if (!t || "Feature" !== t.type || !t.geometry)
                    throw new Error("Invalid input to " + n + ", Feature with geometry required");
                if (!t.geometry || t.geometry.type !== e)
                    throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
            }
            function u(t, e, n) {
                if (!t)
                    throw new Error("No featureCollection passed");
                if (!n)
                    throw new Error(".collectionOf() requires a name");
                if (!t || "FeatureCollection" !== t.type)
                    throw new Error("Invalid input to " + n + ", FeatureCollection required");
                for (var i = 0; i < t.features.length; i++) {
                    var r = t.features[i];
                    if (!r || "Feature" !== r.type || !r.geometry)
                        throw new Error("Invalid input to " + n + ", Feature with geometry required");
                    if (!r.geometry || r.geometry.type !== e)
                        throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + r.geometry.type)
                }
            }
            function l(t) {
                if (!t)
                    throw new Error("<geojson> is required");
                if (t.geometry)
                    return t.geometry;
                if (t.coordinates || t.geometries)
                    return t;
                throw new Error("<geojson> must be a Feature or Geometry Object")
            }
            function c(t) {
                return l(t).type
            }
            e.exports = {
                geojsonType: s,
                collectionOf: u,
                featureOf: a,
                getCoord: i,
                getCoords: r,
                containsNumber: o,
                getGeom: l,
                getGeomType: c
            }
        }
        , {}],
        23: [function(t, e, n) {
            function i(t) {
                var e = t % 360;
                return e < 0 && (e += 360),
                e
            }
            var r = t("@turf/destination")
              , o = t("@turf/circle")
              , s = t("@turf/helpers").lineString;
            e.exports = function(t, e, n, a, u, l) {
                if (!t)
                    throw new Error("center is required");
                if (void 0 === n || null === n)
                    throw new Error("bearing1 is required");
                if (void 0 === a || null === a)
                    throw new Error("bearing2 is required");
                if (!e)
                    throw new Error("radius is required");
                u = u || 64;
                var c = i(n)
                  , h = i(a)
                  , f = t.properties;
                if (c === h)
                    return s(o(t, e, u, l).geometry.coordinates[0], f);
                for (var d = c, g = c < h ? h : h + 360, p = d, m = [], y = 0; p < g; )
                    m.push(r(t, e, p, l).geometry.coordinates),
                    y++,
                    p = d + 360 * y / u;
                return p > g && m.push(r(t, e, g, l).geometry.coordinates),
                s(m, f)
            }
        }
        , {
            "@turf/circle": 12,
            "@turf/destination": 24,
            "@turf/helpers": 25
        }],
        24: [function(t, e, n) {
            arguments[4][13][0].apply(n, arguments)
        }
        , {
            "@turf/helpers": 25,
            "@turf/invariant": 26,
            dup: 13
        }],
        25: [function(t, e, n) {
            arguments[4][14][0].apply(n, arguments)
        }
        , {
            dup: 14
        }],
        26: [function(t, e, n) {
            arguments[4][15][0].apply(n, arguments)
        }
        , {
            dup: 15
        }],
        27: [function(t, e, n) {
            function i(t, e) {
                var n = a(t)
                  , i = a(e);
                if (2 !== n.length)
                    throw new Error("<intersects> line1 must only contain 2 coordinates");
                if (2 !== i.length)
                    throw new Error("<intersects> line2 must only contain 2 coordinates");
                var r = n[0][0]
                  , o = n[0][1]
                  , s = n[1][0]
                  , u = n[1][1]
                  , c = i[0][0]
                  , h = i[0][1]
                  , f = i[1][0]
                  , d = i[1][1]
                  , g = (d - h) * (s - r) - (f - c) * (u - o)
                  , p = (f - c) * (o - h) - (d - h) * (r - c)
                  , m = (s - r) * (o - h) - (u - o) * (r - c);
                if (0 === g)
                    return null;
                var y = p / g
                  , v = m / g;
                if (y >= 0 && y <= 1 && v >= 0 && v <= 1) {
                    return l([r + y * (s - r), o + y * (u - o)])
                }
                return null
            }
            var r = t("@turf/meta")
              , o = t("geojson-rbush")
              , s = t("@turf/helpers")
              , a = t("@turf/invariant").getCoords
              , u = t("@turf/line-segment")
              , l = s.point
              , c = r.featureEach
              , h = s.featureCollection;
            e.exports = function(t, e) {
                var n = {}
                  , r = [];
                if ("LineString" === t.type && (t = s.feature(t)),
                "LineString" === e.type && (e = s.feature(e)),
                "Feature" === t.type && "Feature" === e.type && "LineString" === t.geometry.type && "LineString" === e.geometry.type && 2 === t.geometry.coordinates.length && 2 === e.geometry.coordinates.length) {
                    var l = i(t, e);
                    return l && r.push(l),
                    h(r)
                }
                var f = o();
                return f.load(u(e)),
                c(u(t), function(t) {
                    c(f.search(t), function(e) {
                        var o = i(t, e);
                        if (o) {
                            var s = a(o).join(",");
                            n[s] || (n[s] = !0,
                            r.push(o))
                        }
                    })
                }),
                h(r)
            }
        }
        , {
            "@turf/helpers": 19,
            "@turf/invariant": 22,
            "@turf/line-segment": 28,
            "@turf/meta": 32,
            "geojson-rbush": 48
        }],
        28: [function(t, e, n) {
            function i(t, e) {
                var n = []
                  , i = t.geometry;
                switch (i.type) {
                case "Polygon":
                    n = a(i);
                    break;
                case "LineString":
                    n = [a(i)]
                }
                n.forEach(function(n) {
                    r(n, t.properties).forEach(function(t) {
                        t.id = e.length,
                        e.push(t)
                    })
                })
            }
            function r(t, e) {
                var n = [];
                return t.reduce(function(t, i) {
                    var r = l([t, i], e);
                    return r.bbox = o(t, i),
                    n.push(r),
                    i
                }),
                n
            }
            function o(t, e) {
                var n = t[0]
                  , i = t[1]
                  , r = e[0]
                  , o = e[1];
                return [n < r ? n : r, i < o ? i : o, n > r ? n : r, i > o ? i : o]
            }
            var s = t("@turf/helpers")
              , a = t("@turf/invariant").getCoords
              , u = t("@turf/meta").flattenEach
              , l = s.lineString
              , c = s.featureCollection;
            e.exports = function(t) {
                if (!t)
                    throw new Error("geojson is required");
                var e = [];
                return u(t, function(t) {
                    i(t, e)
                }),
                c(e)
            }
        }
        , {
            "@turf/helpers": 19,
            "@turf/invariant": 22,
            "@turf/meta": 32
        }],
        29: [function(t, e, n) {
            function i(t) {
                return t.geometry ? t.geometry.type : t.type
            }
            function r(t, e) {
                var n = []
                  , i = f();
                return y(e, function(e) {
                    if (n.forEach(function(t, e) {
                        t.id = e
                    }),
                    n.length) {
                        var r = i.search(e)
                          , a = s(e, r);
                        n = n.filter(function(t) {
                            return t.id !== a.id
                        }),
                        i.remove(a),
                        y(o(a, e), function(t) {
                            n.push(t),
                            i.insert(t)
                        })
                    } else
                        n = o(t, e).features,
                        i.load(g(n))
                }),
                g(n)
            }
            function o(t, e) {
                var n = []
                  , i = f()
                  , r = l(t);
                i.load(r);
                var o = i.search(e);
                if (!o.features.length)
                    return g([t]);
                var a = s(e, o)
                  , u = [c(r.features[0])[0]]
                  , h = v(r, function(t, i, r) {
                    var o = c(i)[1]
                      , s = c(e);
                    return r === a.id ? (t.push(s),
                    n.push(p(t)),
                    s[0] === o[0] && s[1] === o[1] ? [s] : [s, o]) : (t.push(o),
                    t)
                }, u);
                return h.length > 1 && n.push(p(h)),
                g(n)
            }
            function s(t, e) {
                var n, i;
                if (!e.features)
                    throw new Error("<lines> must contain features");
                return 1 === e.features.length ? e.features[0] : (y(e, function(e) {
                    var r = u(e, t)
                      , o = r.properties.dist;
                    void 0 === n ? (i = e,
                    n = o) : o < n && (i = e,
                    n = o)
                }),
                i)
            }
            var a = t("@turf/flatten")
              , u = t("@turf/point-on-line")
              , l = t("@turf/line-segment")
              , c = t("@turf/invariant").getCoords
              , h = t("@turf/line-intersect")
              , f = t("geojson-rbush")
              , d = t("@turf/helpers")
              , g = d.featureCollection
              , p = d.lineString
              , m = t("@turf/meta")
              , y = m.featureEach
              , v = m.featureReduce;
            e.exports = function(t, e) {
                if ("LineString" !== i(t))
                    throw new Error("<line> must be LineString");
                if ("FeatureCollection" === i(e))
                    throw new Error("<splitter> cannot be a FeatureCollection");
                switch (i(e)) {
                case "Point":
                    return o(t, e);
                case "MultiPoint":
                    return r(t, a(e));
                case "LineString":
                case "MultiLineString":
                case "Polygon":
                case "MultiPolygon":
                    return r(t, h(t, e));
                default:
                    throw new Error("<splitter> geometry type is not supported")
                }
            }
        }
        , {
            "@turf/flatten": 18,
            "@turf/helpers": 19,
            "@turf/invariant": 22,
            "@turf/line-intersect": 27,
            "@turf/line-segment": 28,
            "@turf/meta": 32,
            "@turf/point-on-line": 33,
            "geojson-rbush": 48
        }],
        30: [function(t, e, n) {
            function i(t, e, n, i) {
                e = e || t.properties || {};
                var l = u(t)
                  , h = r(t);
                if (!l.length)
                    throw new Error("line must contain coordinates");
                switch (h) {
                case "LineString":
                    return n && (l = o(l)),
                    c([l], e);
                case "MultiLineString":
                    var d = []
                      , g = 0;
                    return l.forEach(function(t) {
                        if (n && (t = o(t)),
                        i) {
                            var e = s(a(f(t)));
                            e > g ? (d.unshift(t),
                            g = e) : d.push(t)
                        } else
                            d.push(t)
                    }),
                    c(d, e);
                default:
                    throw new Error("geometry type " + h + " is not supported")
                }
            }
            function r(t) {
                return t.geometry ? t.geometry.type : t.type
            }
            function o(t) {
                var e = t[0]
                  , n = e[0]
                  , i = e[1]
                  , r = t[t.length - 1]
                  , o = r[0]
                  , s = r[1];
                return n === o && i === s || t.push(e),
                t
            }
            function s(t) {
                var e = t[0]
                  , n = t[1]
                  , i = t[2]
                  , r = t[3];
                return Math.abs(e - i) * Math.abs(n - r)
            }
            var a = t("@turf/bbox")
              , u = t("@turf/invariant").getCoords
              , l = t("@turf/helpers")
              , c = l.polygon
              , h = l.multiPolygon
              , f = l.lineString;
            e.exports = function(t, e, n, o) {
                if (!t)
                    throw new Error("lines is required");
                switch (n = void 0 === n || n,
                o = void 0 === o || o,
                r(t)) {
                case "FeatureCollection":
                case "GeometryCollection":
                    var s = [];
                    return (t.features ? t.features : t.geometries).forEach(function(t) {
                        s.push(u(i(t, {}, n, o)))
                    }),
                    h(s, e)
                }
                return i(t, e, n, o)
            }
        }
        , {
            "@turf/bbox": 31,
            "@turf/helpers": 19,
            "@turf/invariant": 22
        }],
        31: [function(t, e, n) {
            var i = t("@turf/meta").coordEach;
            e.exports = function(t) {
                var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                return i(t, function(t) {
                    e[0] > t[0] && (e[0] = t[0]),
                    e[1] > t[1] && (e[1] = t[1]),
                    e[2] < t[0] && (e[2] = t[0]),
                    e[3] < t[1] && (e[3] = t[1])
                }),
                e
            }
        }
        , {
            "@turf/meta": 32
        }],
        32: [function(t, e, n) {
            function i(t, e, n) {
                var r, o, s, a, u, l, c, h, f, d, g = 0, p = 0, m = "FeatureCollection" === t.type, y = "Feature" === t.type, v = m ? t.features.length : 1;
                for (r = 0; r < v; r++)
                    for (f = m ? t.features[r].geometry : y ? t.geometry : t,
                    d = "GeometryCollection" === f.type,
                    c = d ? f.geometries.length : 1,
                    a = 0; a < c; a++)
                        if (l = d ? f.geometries[a] : f,
                        h = l.coordinates,
                        g = !n || "Polygon" !== l.type && "MultiPolygon" !== l.type ? 0 : 1,
                        "Point" === l.type)
                            e(h, p),
                            p++;
                        else if ("LineString" === l.type || "MultiPoint" === l.type)
                            for (o = 0; o < h.length; o++)
                                e(h[o], p),
                                p++;
                        else if ("Polygon" === l.type || "MultiLineString" === l.type)
                            for (o = 0; o < h.length; o++)
                                for (s = 0; s < h[o].length - g; s++)
                                    e(h[o][s], p),
                                    p++;
                        else if ("MultiPolygon" === l.type)
                            for (o = 0; o < h.length; o++)
                                for (s = 0; s < h[o].length; s++)
                                    for (u = 0; u < h[o][s].length - g; u++)
                                        e(h[o][s][u], p),
                                        p++;
                        else {
                            if ("GeometryCollection" !== l.type)
                                throw new Error("Unknown Geometry Type");
                            for (o = 0; o < l.geometries.length; o++)
                                i(l.geometries[o], e, n)
                        }
            }
            function r(t, e, n, r) {
                var o = n;
                return i(t, function(t, i) {
                    o = 0 === i && void 0 === n ? t : e(o, t, i)
                }, r),
                o
            }
            function o(t, e) {
                var n;
                switch (t.type) {
                case "FeatureCollection":
                    for (n = 0; n < t.features.length; n++)
                        e(t.features[n].properties, n);
                    break;
                case "Feature":
                    e(t.properties, 0)
                }
            }
            function s(t, e, n) {
                var i = n;
                return o(t, function(t, r) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r)
                }),
                i
            }
            function a(t, e) {
                if ("Feature" === t.type)
                    e(t, 0);
                else if ("FeatureCollection" === t.type)
                    for (var n = 0; n < t.features.length; n++)
                        e(t.features[n], n)
            }
            function u(t, e, n) {
                var i = n;
                return a(t, function(t, r) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r)
                }),
                i
            }
            function l(t) {
                var e = [];
                return i(t, function(t) {
                    e.push(t)
                }),
                e
            }
            function c(t, e) {
                var n, i, r, o, s, a, u, l, c = 0, h = "FeatureCollection" === t.type, f = "Feature" === t.type, d = h ? t.features.length : 1;
                for (n = 0; n < d; n++)
                    for (a = h ? t.features[n].geometry : f ? t.geometry : t,
                    l = h ? t.features[n].properties : f ? t.properties : {},
                    u = "GeometryCollection" === a.type,
                    s = u ? a.geometries.length : 1,
                    r = 0; r < s; r++)
                        if (o = u ? a.geometries[r] : a,
                        "Point" === o.type || "LineString" === o.type || "MultiPoint" === o.type || "Polygon" === o.type || "MultiLineString" === o.type || "MultiPolygon" === o.type)
                            e(o, c, l),
                            c++;
                        else {
                            if ("GeometryCollection" !== o.type)
                                throw new Error("Unknown Geometry Type");
                            for (i = 0; i < o.geometries.length; i++)
                                e(o.geometries[i], c, l),
                                c++
                        }
            }
            function h(t, e, n) {
                var i = n;
                return c(t, function(t, r, o) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r, o)
                }),
                i
            }
            function f(t, e) {
                c(t, function(t, n, i) {
                    switch (t.type) {
                    case "Point":
                    case "LineString":
                    case "Polygon":
                        return void e(g(t, i), n, 0)
                    }
                    var r;
                    switch (t.type) {
                    case "MultiPoint":
                        r = "Point";
                        break;
                    case "MultiLineString":
                        r = "LineString";
                        break;
                    case "MultiPolygon":
                        r = "Polygon"
                    }
                    t.coordinates.forEach(function(t, o) {
                        e(g({
                            type: r,
                            coordinates: t
                        }, i), n, o)
                    })
                })
            }
            function d(t, e, n) {
                var i = n;
                return f(t, function(t, r, o) {
                    i = 0 === r && 0 === o && void 0 === n ? t : e(i, t, r, o)
                }),
                i
            }
            function g(t, e) {
                if (!t)
                    throw new Error("No geometry passed");
                return {
                    type: "Feature",
                    properties: e || {},
                    geometry: t
                }
            }
            e.exports = {
                coordEach: i,
                coordReduce: r,
                propEach: o,
                propReduce: s,
                featureEach: a,
                featureReduce: u,
                coordAll: l,
                geomEach: c,
                geomReduce: h,
                flattenEach: f,
                flattenReduce: d
            }
        }
        , {}],
        33: [function(t, e, n) {
            var i = t("@turf/distance")
              , r = t("@turf/helpers")
              , o = t("@turf/bearing")
              , s = t("@turf/destination")
              , a = t("@turf/line-intersect")
              , u = r.point
              , l = r.lineString;
            e.exports = function(t, e, n) {
                var r;
                if ("Feature" === t.type)
                    r = t.geometry.coordinates;
                else {
                    if ("LineString" !== t.type)
                        throw new Error("input must be a LineString Feature or Geometry");
                    r = t.coordinates
                }
                for (var c = u([1 / 0, 1 / 0], {
                    dist: 1 / 0
                }), h = 0, f = 0; f < r.length - 1; f++) {
                    var d = u(r[f])
                      , g = u(r[f + 1]);
                    d.properties.dist = i(e, d, n),
                    g.properties.dist = i(e, g, n);
                    var p = i(d, g, n)
                      , m = Math.max(d.properties.dist, g.properties.dist)
                      , y = o(d, g)
                      , v = s(e, m, y + 90, n)
                      , E = s(e, m, y - 90, n)
                      , x = a(l([v.geometry.coordinates, E.geometry.coordinates]), l([d.geometry.coordinates, g.geometry.coordinates]))
                      , I = null;
                    x.features.length > 0 && (I = x.features[0],
                    I.properties.dist = i(e, I, n),
                    I.properties.location = h + i(d, I, n)),
                    d.properties.dist < c.properties.dist && (c = d,
                    c.properties.index = f,
                    c.properties.location = h),
                    g.properties.dist < c.properties.dist && (c = g,
                    c.properties.index = f + 1,
                    c.properties.location = h + p),
                    I && I.properties.dist < c.properties.dist && (c = I,
                    c.properties.index = f),
                    h += p
                }
                return c
            }
        }
        , {
            "@turf/bearing": 9,
            "@turf/destination": 16,
            "@turf/distance": 17,
            "@turf/helpers": 19,
            "@turf/line-intersect": 27
        }],
        34: [function(t, e, n) {
            function i(t, e) {
                return t.length > 1 ? u(t, e) : a(t[0], e)
            }
            function r(t) {
                return t.geometry ? t.geometry.type : t.type
            }
            var o = t("@turf/invariant").getCoords
              , s = t("@turf/helpers")
              , a = s.lineString
              , u = s.multiLineString
              , l = s.featureCollection;
            e.exports = function(t, e) {
                var n = r(t)
                  , s = o(t);
                if (e = e || t.properties || {},
                !s.length)
                    throw new Error("polygon must contain coordinates");
                switch (n) {
                case "Polygon":
                    return i(s, e);
                case "MultiPolygon":
                    var a = [];
                    return s.forEach(function(t) {
                        a.push(i(t, e))
                    }),
                    l(a);
                default:
                    throw new Error("geom " + n + " not supported")
                }
            }
        }
        , {
            "@turf/helpers": 19,
            "@turf/invariant": 22
        }],
        35: [function(t, e, n) {
            function i(t) {
                var e = t % 360;
                return e < 0 && (e += 360),
                e
            }
            var r = t("@turf/circle")
              , o = t("@turf/meta").coordEach
              , s = t("@turf/helpers")
              , a = t("@turf/invariant").getCoords
              , u = s.polygon
              , l = t("@turf/line-arc");
            e.exports = function(t, e, n, s, c, h) {
                if (!t)
                    throw new Error("center is required");
                if (void 0 === n || null === n)
                    throw new Error("bearing1 is required");
                if (void 0 === s || null === s)
                    throw new Error("bearing2 is required");
                if (!e)
                    throw new Error("radius is required");
                if (c = c || 64,
                i(n) === i(s))
                    return r(t, e, c, h);
                var f = a(t)
                  , d = l(t, e, n, s, c, h)
                  , g = [[f]];
                return o(d, function(t) {
                    g[0].push(t)
                }),
                g[0].push(f),
                u(g)
            }
        }
        , {
            "@turf/circle": 12,
            "@turf/helpers": 36,
            "@turf/invariant": 37,
            "@turf/line-arc": 23,
            "@turf/meta": 38
        }],
        36: [function(t, e, n) {
            arguments[4][14][0].apply(n, arguments)
        }
        , {
            dup: 14
        }],
        37: [function(t, e, n) {
            arguments[4][15][0].apply(n, arguments)
        }
        , {
            dup: 15
        }],
        38: [function(t, e, n) {
            function i(t, e, n) {
                if (null !== t) {
                    var r, o, s, a, u, l, c, h, f, d, g = 0, p = 0, m = t.type, y = "FeatureCollection" === m, v = "Feature" === m, E = y ? t.features.length : 1;
                    for (r = 0; r < E; r++) {
                        var x = 0;
                        for (f = y ? t.features[r].geometry : v ? t.geometry : t,
                        d = !!f && "GeometryCollection" === f.type,
                        c = d ? f.geometries.length : 1,
                        o = 0; o < c; o++)
                            if (null !== (l = d ? f.geometries[o] : f)) {
                                h = l.coordinates;
                                var I = l.type;
                                switch (g = !n || "Polygon" !== I && "MultiPolygon" !== I ? 0 : 1,
                                I) {
                                case null:
                                    break;
                                case "Point":
                                    e(h, p, r, x),
                                    p++,
                                    x++;
                                    break;
                                case "LineString":
                                case "MultiPoint":
                                    for (s = 0; s < h.length; s++)
                                        e(h[s], p, r, x),
                                        p++,
                                        x++;
                                    break;
                                case "Polygon":
                                case "MultiLineString":
                                    for (s = 0; s < h.length; s++)
                                        for (a = 0; a < h[s].length - g; a++)
                                            e(h[s][a], p, r, x),
                                            p++,
                                            x++;
                                    break;
                                case "MultiPolygon":
                                    for (s = 0; s < h.length; s++)
                                        for (a = 0; a < h[s].length; a++)
                                            for (u = 0; u < h[s][a].length - g; u++)
                                                e(h[s][a][u], p, r, x),
                                                p++,
                                                x++;
                                    break;
                                case "GeometryCollection":
                                    for (s = 0; s < l.geometries.length; s++)
                                        i(l.geometries[s], e, n);
                                    break;
                                default:
                                    throw new Error("Unknown Geometry Type")
                                }
                            }
                    }
                }
            }
            function r(t, e, n, r) {
                var o = n;
                return i(t, function(t, i, r, s) {
                    o = 0 === i && void 0 === n ? t : e(o, t, i, r, s)
                }, r),
                o
            }
            function o(t, e) {
                var n;
                switch (t.type) {
                case "FeatureCollection":
                    for (n = 0; n < t.features.length; n++)
                        e(t.features[n].properties, n);
                    break;
                case "Feature":
                    e(t.properties, 0)
                }
            }
            function s(t, e, n) {
                var i = n;
                return o(t, function(t, r) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r)
                }),
                i
            }
            function a(t, e) {
                if ("Feature" === t.type)
                    e(t, 0);
                else if ("FeatureCollection" === t.type)
                    for (var n = 0; n < t.features.length; n++)
                        e(t.features[n], n)
            }
            function u(t, e, n) {
                var i = n;
                return a(t, function(t, r) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r)
                }),
                i
            }
            function l(t) {
                var e = [];
                return i(t, function(t) {
                    e.push(t)
                }),
                e
            }
            function c(t, e) {
                var n, i, r, o, s, a, u, l, c = 0, h = "FeatureCollection" === t.type, f = "Feature" === t.type, d = h ? t.features.length : 1;
                for (n = 0; n < d; n++)
                    for (a = h ? t.features[n].geometry : f ? t.geometry : t,
                    l = h ? t.features[n].properties : f ? t.properties : {},
                    u = !!a && "GeometryCollection" === a.type,
                    s = u ? a.geometries.length : 1,
                    r = 0; r < s; r++)
                        if (null !== (o = u ? a.geometries[r] : a))
                            switch (o.type) {
                            case "Point":
                            case "LineString":
                            case "MultiPoint":
                            case "Polygon":
                            case "MultiLineString":
                            case "MultiPolygon":
                                e(o, c, l),
                                c++;
                                break;
                            case "GeometryCollection":
                                for (i = 0; i < o.geometries.length; i++)
                                    e(o.geometries[i], c, l),
                                    c++;
                                break;
                            default:
                                throw new Error("Unknown Geometry Type")
                            }
                        else
                            e(null, c, l),
                            c++
            }
            function h(t, e, n) {
                var i = n;
                return c(t, function(t, r, o) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r, o)
                }),
                i
            }
            function f(t, e) {
                c(t, function(t, n, i) {
                    var r = null === t ? null : t.type;
                    switch (r) {
                    case null:
                    case "Point":
                    case "LineString":
                    case "Polygon":
                        return void e(m(t, i), n, 0)
                    }
                    var o;
                    switch (r) {
                    case "MultiPoint":
                        o = "Point";
                        break;
                    case "MultiLineString":
                        o = "LineString";
                        break;
                    case "MultiPolygon":
                        o = "Polygon"
                    }
                    t.coordinates.forEach(function(t, r) {
                        e(m({
                            type: o,
                            coordinates: t
                        }, i), n, r)
                    })
                })
            }
            function d(t, e, n) {
                var i = n;
                return f(t, function(t, r, o) {
                    i = 0 === r && 0 === o && void 0 === n ? t : e(i, t, r, o)
                }),
                i
            }
            function g(t, e) {
                f(t, function(t, n) {
                    var i = 0;
                    if (t.geometry) {
                        var o = t.geometry.type;
                        "Point" !== o && "MultiPoint" !== o && r(t, function(r, o) {
                            var s = y([r, o], t.properties);
                            return e(s, n, i),
                            i++,
                            o
                        })
                    }
                })
            }
            function p(t, e, n) {
                var i = n;
                return g(t, function(t, r, o) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r, o)
                }),
                i
            }
            function m(t, e) {
                if (void 0 === t)
                    throw new Error("No geometry passed");
                return {
                    type: "Feature",
                    properties: e || {},
                    geometry: t
                }
            }
            function y(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                if (t.length < 2)
                    throw new Error("Coordinates must be an array of two or more positions");
                return {
                    type: "Feature",
                    properties: e || {},
                    geometry: {
                        type: "LineString",
                        coordinates: t
                    }
                }
            }
            e.exports = {
                coordEach: i,
                coordReduce: r,
                propEach: o,
                propReduce: s,
                featureEach: a,
                featureReduce: u,
                coordAll: l,
                geomEach: c,
                geomReduce: h,
                flattenEach: f,
                flattenReduce: d,
                segmentEach: g,
                segmentReduce: p
            }
        }
        , {}],
        39: [function(t, e, n) {
            var i = t("jsts");
            e.exports = function() {
                for (var t = new i.io.GeoJSONReader, e = t.read(JSON.stringify(arguments[0].geometry)), n = 1; n < arguments.length; n++)
                    e = e.union(t.read(JSON.stringify(arguments[n].geometry)));
                return e = (new i.io.GeoJSONWriter).write(e),
                {
                    type: "Feature",
                    geometry: e,
                    properties: arguments[0].properties
                }
            }
        }
        , {
            jsts: 40
        }],
        40: [function(t, e, n) {
            arguments[4][21][0].apply(n, arguments)
        }
        , {
            dup: 21
        }],
        41: [function(t, e, n) {}
        , {}],
        42: [function(t, e, n) {
            function i() {
                if (!(this instanceof i))
                    return new i;
                this._bbox = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                this._valid = !1
            }
            e.exports = i,
            i.prototype.include = function(t) {
                return this._valid = !0,
                this._bbox[0] = Math.min(this._bbox[0], t[0]),
                this._bbox[1] = Math.min(this._bbox[1], t[1]),
                this._bbox[2] = Math.max(this._bbox[2], t[0]),
                this._bbox[3] = Math.max(this._bbox[3], t[1]),
                this
            }
            ,
            i.prototype.union = function(t) {
                return this._valid = !0,
                this._bbox[0] = Math.min(this._bbox[0], t[0]),
                this._bbox[1] = Math.min(this._bbox[1], t[1]),
                this._bbox[2] = Math.max(this._bbox[2], t[2]),
                this._bbox[3] = Math.max(this._bbox[3], t[3]),
                this
            }
            ,
            i.prototype.bbox = function() {
                return this._valid ? this._bbox : null
            }
            ,
            i.prototype.contains = function(t) {
                return this._valid ? this._bbox[0] <= t[0] && this._bbox[1] <= t[1] && this._bbox[2] >= t[0] && this._bbox[3] >= t[1] : null
            }
            ,
            i.prototype.polygon = function() {
                return this._valid ? {
                    type: "Polygon",
                    coordinates: [[[this._bbox[0], this._bbox[1]], [this._bbox[2], this._bbox[1]], [this._bbox[2], this._bbox[3]], [this._bbox[0], this._bbox[3]], [this._bbox[0], this._bbox[1]]]]
                } : null
            }
        }
        , {}],
        43: [function(t, e, n) {
            e.exports = function(t, e) {
                function n(t) {
                    return Array.isArray(t) && t.length && "number" == typeof t[0] ? [t] : t.reduce(function(t, e) {
                        return Array.isArray(e) && Array.isArray(e[0]) ? t.concat(n(e)) : (t.push(e),
                        t)
                    }, [])
                }
                return n(t)
            }
        }
        , {}],
        44: [function(t, e, n) {
            var i = t("geojson-normalize")
              , r = t("geojson-flatten")
              , o = t("./flatten");
            e.exports = function(t) {
                if (!t)
                    return [];
                var e = r(i(t))
                  , n = [];
                return e.features.forEach(function(t) {
                    t.geometry && (n = n.concat(o(t.geometry.coordinates)))
                }),
                n
            }
        }
        , {
            "./flatten": 43,
            "geojson-flatten": 46,
            "geojson-normalize": 47
        }],
        45: [function(t, e, n) {
            function i(t) {
                for (var e = s(), n = r(t), i = 0; i < n.length; i++)
                    e.include(n[i]);
                return e
            }
            var r = t("geojson-coords")
              , o = t("traverse")
              , s = t("extent");
            e.exports = function(t) {
                return i(t).bbox()
            }
            ,
            e.exports.polygon = function(t) {
                return i(t).polygon()
            }
            ,
            e.exports.bboxify = function(t) {
                return o(t).map(function(t) {
                    t && "string" == typeof t.type && (t.bbox = i(t).bbox(),
                    this.update(t))
                })
            }
        }
        , {
            extent: 42,
            "geojson-coords": 44,
            traverse: 59
        }],
        46: [function(t, e, n) {
            function i(t, e) {
                switch (t && t.type || null) {
                case "FeatureCollection":
                    return t.features = t.features.reduce(function(t, e) {
                        return t.concat(i(e))
                    }, []),
                    t;
                case "Feature":
                    return i(t.geometry).map(function(e) {
                        return {
                            type: "Feature",
                            properties: JSON.parse(JSON.stringify(t.properties)),
                            geometry: e
                        }
                    });
                case "MultiPoint":
                    return t.coordinates.map(function(t) {
                        return {
                            type: "Point",
                            coordinates: t
                        }
                    });
                case "MultiPolygon":
                    return t.coordinates.map(function(t) {
                        return {
                            type: "Polygon",
                            coordinates: t
                        }
                    });
                case "MultiLineString":
                    return t.coordinates.map(function(t) {
                        return {
                            type: "LineString",
                            coordinates: t
                        }
                    });
                case "GeometryCollection":
                    return t.geometries;
                case "Point":
                case "Polygon":
                case "LineString":
                    return [t];
                default:
                    return t
                }
            }
            e.exports = i
        }
        , {}],
        47: [function(t, e, n) {
            arguments[4][2][0].apply(n, arguments)
        }
        , {
            dup: 2
        }],
        48: [function(t, e, n) {
            var i = t("@turf/bbox")
              , r = t("@turf/helpers").featureCollection
              , o = t("@turf/meta").featureEach
              , s = t("@turf/bbox-polygon")
              , a = t("rbush");
            e.exports = function(t) {
                var e = a(t);
                return e.insert = function(t) {
                    if (Array.isArray(t)) {
                        const e = t;
                        t = s(e),
                        t.bbox = e
                    } else
                        t.bbox = t.bbox ? t.bbox : i(t);
                    return a.prototype.insert.call(this, t)
                }
                ,
                e.load = function(t) {
                    var e = [];
                    return Array.isArray(t) ? t.forEach(function(t) {
                        const n = s(t);
                        n.bbox = t,
                        e.push(n)
                    }) : o(t, function(t) {
                        t.bbox = t.bbox ? t.bbox : i(t),
                        e.push(t)
                    }),
                    a.prototype.load.call(this, e)
                }
                ,
                e.remove = function(t) {
                    if (Array.isArray(t)) {
                        const e = t;
                        t = s(e),
                        t.bbox = e
                    }
                    return a.prototype.remove.call(this, t)
                }
                ,
                e.clear = function() {
                    return a.prototype.clear.call(this)
                }
                ,
                e.search = function(t) {
                    var e = a.prototype.search.call(this, this.toBBox(t));
                    return r(e)
                }
                ,
                e.collides = function(t) {
                    return a.prototype.collides.call(this, this.toBBox(t))
                }
                ,
                e.all = function() {
                    var t = a.prototype.all.call(this);
                    return r(t)
                }
                ,
                e.toJSON = function() {
                    return a.prototype.toJSON.call(this)
                }
                ,
                e.fromJSON = function(t) {
                    return a.prototype.fromJSON.call(this, t)
                }
                ,
                e.toBBox = function(t) {
                    var e;
                    return e = t.bbox ? t.bbox : Array.isArray(t) && 4 === t.length ? t : i(t),
                    {
                        minX: e[0],
                        minY: e[1],
                        maxX: e[2],
                        maxY: e[3]
                    }
                }
                ,
                e
            }
        }
        , {
            "@turf/bbox": 7,
            "@turf/bbox-polygon": 6,
            "@turf/helpers": 49,
            "@turf/meta": 50,
            rbush: 58
        }],
        49: [function(t, e, n) {
            function i(t, e) {
                if (!t)
                    throw new Error("No geometry passed");
                return {
                    type: "Feature",
                    properties: e || {},
                    geometry: t
                }
            }
            e.exports.feature = i,
            e.exports.point = function(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                if (void 0 === t.length)
                    throw new Error("Coordinates must be an array");
                if (t.length < 2)
                    throw new Error("Coordinates must be at least 2 numbers long");
                if ("number" != typeof t[0] || "number" != typeof t[1])
                    throw new Error("Coordinates must numbers");
                return i({
                    type: "Point",
                    coordinates: t
                }, e)
            }
            ,
            e.exports.polygon = function(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    if (r.length < 4)
                        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                    for (var o = 0; o < r[r.length - 1].length; o++)
                        if (r[r.length - 1][o] !== r[0][o])
                            throw new Error("First and last Position are not equivalent.")
                }
                return i({
                    type: "Polygon",
                    coordinates: t
                }, e)
            }
            ,
            e.exports.lineString = function(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "LineString",
                    coordinates: t
                }, e)
            }
            ,
            e.exports.featureCollection = function(t) {
                if (!t)
                    throw new Error("No features passed");
                return {
                    type: "FeatureCollection",
                    features: t
                }
            }
            ,
            e.exports.multiLineString = function(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiLineString",
                    coordinates: t
                }, e)
            }
            ,
            e.exports.multiPoint = function(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiPoint",
                    coordinates: t
                }, e)
            }
            ,
            e.exports.multiPolygon = function(t, e) {
                if (!t)
                    throw new Error("No coordinates passed");
                return i({
                    type: "MultiPolygon",
                    coordinates: t
                }, e)
            }
            ,
            e.exports.geometryCollection = function(t, e) {
                if (!t)
                    throw new Error("No geometries passed");
                return i({
                    type: "GeometryCollection",
                    geometries: t
                }, e)
            }
            ;
            var r = {
                miles: 3960,
                nauticalmiles: 3441.145,
                degrees: 57.2957795,
                radians: 1,
                inches: 250905600,
                yards: 6969600,
                meters: 6373e3,
                metres: 6373e3,
                kilometers: 6373,
                kilometres: 6373,
                feet: 20908792.65
            };
            e.exports.radiansToDistance = function(t, e) {
                var n = r[e || "kilometers"];
                if (void 0 === n)
                    throw new Error("Invalid unit");
                return t * n
            }
            ,
            e.exports.distanceToRadians = function(t, e) {
                var n = r[e || "kilometers"];
                if (void 0 === n)
                    throw new Error("Invalid unit");
                return t / n
            }
            ,
            e.exports.distanceToDegrees = function(t, e) {
                var n = r[e || "kilometers"];
                if (void 0 === n)
                    throw new Error("Invalid unit");
                return t / n * 57.2958
            }
        }
        , {}],
        50: [function(t, e, n) {
            arguments[4][8][0].apply(n, arguments)
        }
        , {
            dup: 8
        }],
        51: [function(t, e, n) {
            var i = e.exports = function(t, e) {
                if (e || (e = 16),
                void 0 === t && (t = 128),
                t <= 0)
                    return "0";
                for (var n = Math.log(Math.pow(2, t)) / Math.log(e), r = 2; n === 1 / 0; r *= 2)
                    n = Math.log(Math.pow(2, t / r)) / Math.log(e) * r;
                for (var o = n - Math.floor(n), s = "", r = 0; r < Math.floor(n); r++) {
                    var a = Math.floor(Math.random() * e).toString(e);
                    s = a + s
                }
                if (o) {
                    var u = Math.pow(e, o)
                      , a = Math.floor(Math.random() * u).toString(e);
                    s = a + s
                }
                var l = parseInt(s, e);
                return l !== 1 / 0 && l >= Math.pow(2, t) ? i(t, e) : s
            }
            ;
            i.rack = function(t, e, n) {
                var r = function(r) {
                    var s = 0;
                    do {
                        if (s++ > 10) {
                            if (!n)
                                throw new Error("too many ID collisions, use more bits");
                            t += n
                        }
                        var a = i(t, e)
                    } while (Object.hasOwnProperty.call(o, a));return o[a] = r,
                    a
                }
                  , o = r.hats = {};
                return r.get = function(t) {
                    return r.hats[t]
                }
                ,
                r.set = function(t, e) {
                    return r.hats[t] = e,
                    r
                }
                ,
                r.bits = t || 128,
                r.base = e || 16,
                r
            }
        }
        , {}],
        52: [function(t, e, n) {
            (function(i) {
                var r = function() {
                    function t() {
                        this.yy = {}
                    }
                    var e = function(t, e, n, i) {
                        for (n = n || {},
                        i = t.length; i--; n[t[i]] = e)
                            ;
                        return n
                    }
                      , n = [1, 12]
                      , i = [1, 13]
                      , r = [1, 9]
                      , o = [1, 10]
                      , s = [1, 11]
                      , a = [1, 14]
                      , u = [1, 15]
                      , l = [14, 18, 22, 24]
                      , c = [18, 22]
                      , h = [22, 24]
                      , f = {
                        trace: function() {},
                        yy: {},
                        symbols_: {
                            error: 2,
                            JSONString: 3,
                            STRING: 4,
                            JSONNumber: 5,
                            NUMBER: 6,
                            JSONNullLiteral: 7,
                            NULL: 8,
                            JSONBooleanLiteral: 9,
                            TRUE: 10,
                            FALSE: 11,
                            JSONText: 12,
                            JSONValue: 13,
                            EOF: 14,
                            JSONObject: 15,
                            JSONArray: 16,
                            "{": 17,
                            "}": 18,
                            JSONMemberList: 19,
                            JSONMember: 20,
                            ":": 21,
                            ",": 22,
                            "[": 23,
                            "]": 24,
                            JSONElementList: 25,
                            $accept: 0,
                            $end: 1
                        },
                        terminals_: {
                            2: "error",
                            4: "STRING",
                            6: "NUMBER",
                            8: "NULL",
                            10: "TRUE",
                            11: "FALSE",
                            14: "EOF",
                            17: "{",
                            18: "}",
                            21: ":",
                            22: ",",
                            23: "[",
                            24: "]"
                        },
                        productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],
                        performAction: function(t, e, n, i, r, o, s) {
                            var a = o.length - 1;
                            switch (r) {
                            case 1:
                                this.$ = t.replace(/\\(\\|")/g, "$1").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "\t").replace(/\\v/g, "\v").replace(/\\f/g, "\f").replace(/\\b/g, "\b");
                                break;
                            case 2:
                                this.$ = Number(t);
                                break;
                            case 3:
                                this.$ = null;
                                break;
                            case 4:
                                this.$ = !0;
                                break;
                            case 5:
                                this.$ = !1;
                                break;
                            case 6:
                                return this.$ = o[a - 1];
                            case 13:
                                this.$ = {},
                                Object.defineProperty(this.$, "__line__", {
                                    value: this._$.first_line,
                                    enumerable: !1
                                });
                                break;
                            case 14:
                            case 19:
                                this.$ = o[a - 1],
                                Object.defineProperty(this.$, "__line__", {
                                    value: this._$.first_line,
                                    enumerable: !1
                                });
                                break;
                            case 15:
                                this.$ = [o[a - 2], o[a]];
                                break;
                            case 16:
                                this.$ = {},
                                this.$[o[a][0]] = o[a][1];
                                break;
                            case 17:
                                this.$ = o[a - 2],
                                void 0 !== o[a - 2][o[a][0]] && (this.$.__duplicateProperties__ || Object.defineProperty(this.$, "__duplicateProperties__", {
                                    value: [],
                                    enumerable: !1
                                }),
                                this.$.__duplicateProperties__.push(o[a][0])),
                                o[a - 2][o[a][0]] = o[a][1];
                                break;
                            case 18:
                                this.$ = [],
                                Object.defineProperty(this.$, "__line__", {
                                    value: this._$.first_line,
                                    enumerable: !1
                                });
                                break;
                            case 20:
                                this.$ = [o[a]];
                                break;
                            case 21:
                                this.$ = o[a - 2],
                                o[a - 2].push(o[a])
                            }
                        },
                        table: [{
                            3: 5,
                            4: n,
                            5: 6,
                            6: i,
                            7: 3,
                            8: r,
                            9: 4,
                            10: o,
                            11: s,
                            12: 1,
                            13: 2,
                            15: 7,
                            16: 8,
                            17: a,
                            23: u
                        }, {
                            1: [3]
                        }, {
                            14: [1, 16]
                        }, e(l, [2, 7]), e(l, [2, 8]), e(l, [2, 9]), e(l, [2, 10]), e(l, [2, 11]), e(l, [2, 12]), e(l, [2, 3]), e(l, [2, 4]), e(l, [2, 5]), e([14, 18, 21, 22, 24], [2, 1]), e(l, [2, 2]), {
                            3: 20,
                            4: n,
                            18: [1, 17],
                            19: 18,
                            20: 19
                        }, {
                            3: 5,
                            4: n,
                            5: 6,
                            6: i,
                            7: 3,
                            8: r,
                            9: 4,
                            10: o,
                            11: s,
                            13: 23,
                            15: 7,
                            16: 8,
                            17: a,
                            23: u,
                            24: [1, 21],
                            25: 22
                        }, {
                            1: [2, 6]
                        }, e(l, [2, 13]), {
                            18: [1, 24],
                            22: [1, 25]
                        }, e(c, [2, 16]), {
                            21: [1, 26]
                        }, e(l, [2, 18]), {
                            22: [1, 28],
                            24: [1, 27]
                        }, e(h, [2, 20]), e(l, [2, 14]), {
                            3: 20,
                            4: n,
                            20: 29
                        }, {
                            3: 5,
                            4: n,
                            5: 6,
                            6: i,
                            7: 3,
                            8: r,
                            9: 4,
                            10: o,
                            11: s,
                            13: 30,
                            15: 7,
                            16: 8,
                            17: a,
                            23: u
                        }, e(l, [2, 19]), {
                            3: 5,
                            4: n,
                            5: 6,
                            6: i,
                            7: 3,
                            8: r,
                            9: 4,
                            10: o,
                            11: s,
                            13: 31,
                            15: 7,
                            16: 8,
                            17: a,
                            23: u
                        }, e(c, [2, 17]), e(c, [2, 15]), e(h, [2, 21])],
                        defaultActions: {
                            16: [2, 6]
                        },
                        parseError: function(t, e) {
                            function n(t, e) {
                                this.message = t,
                                this.hash = e
                            }
                            if (!e.recoverable)
                                throw n.prototype = Error,
                                new n(t,e);
                            this.trace(t)
                        },
                        parse: function(t) {
                            var e = this
                              , n = [0]
                              , i = [null]
                              , r = []
                              , o = this.table
                              , s = ""
                              , a = 0
                              , u = 0
                              , l = 0
                              , c = r.slice.call(arguments, 1)
                              , h = Object.create(this.lexer)
                              , f = {
                                yy: {}
                            };
                            for (var d in this.yy)
                                Object.prototype.hasOwnProperty.call(this.yy, d) && (f.yy[d] = this.yy[d]);
                            h.setInput(t, f.yy),
                            f.yy.lexer = h,
                            f.yy.parser = this,
                            void 0 === h.yylloc && (h.yylloc = {});
                            var g = h.yylloc;
                            r.push(g);
                            var p = h.options && h.options.ranges;
                            "function" == typeof f.yy.parseError ? this.parseError = f.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
                            for (var m, y, v, E, x, I, N, C, w, _ = function() {
                                var t;
                                return t = h.lex() || 1,
                                "number" != typeof t && (t = e.symbols_[t] || t),
                                t
                            }, S = {}; ; ) {
                                if (v = n[n.length - 1],
                                this.defaultActions[v] ? E = this.defaultActions[v] : (null !== m && void 0 !== m || (m = _()),
                                E = o[v] && o[v][m]),
                                void 0 === E || !E.length || !E[0]) {
                                    var b = "";
                                    w = [];
                                    for (I in o[v])
                                        this.terminals_[I] && I > 2 && w.push("'" + this.terminals_[I] + "'");
                                    b = h.showPosition ? "Parse error on line " + (a + 1) + ":\n" + h.showPosition() + "\nExpecting " + w.join(", ") + ", got '" + (this.terminals_[m] || m) + "'" : "Parse error on line " + (a + 1) + ": Unexpected " + (1 == m ? "end of input" : "'" + (this.terminals_[m] || m) + "'"),
                                    this.parseError(b, {
                                        text: h.match,
                                        token: this.terminals_[m] || m,
                                        line: h.yylineno,
                                        loc: g,
                                        expected: w
                                    })
                                }
                                if (E[0]instanceof Array && E.length > 1)
                                    throw new Error("Parse Error: multiple actions possible at state: " + v + ", token: " + m);
                                switch (E[0]) {
                                case 1:
                                    n.push(m),
                                    i.push(h.yytext),
                                    r.push(h.yylloc),
                                    n.push(E[1]),
                                    m = null,
                                    y ? (m = y,
                                    y = null) : (u = h.yyleng,
                                    s = h.yytext,
                                    a = h.yylineno,
                                    g = h.yylloc,
                                    l > 0 && l--);
                                    break;
                                case 2:
                                    if (N = this.productions_[E[1]][1],
                                    S.$ = i[i.length - N],
                                    S._$ = {
                                        first_line: r[r.length - (N || 1)].first_line,
                                        last_line: r[r.length - 1].last_line,
                                        first_column: r[r.length - (N || 1)].first_column,
                                        last_column: r[r.length - 1].last_column
                                    },
                                    p && (S._$.range = [r[r.length - (N || 1)].range[0], r[r.length - 1].range[1]]),
                                    void 0 !== (x = this.performAction.apply(S, [s, u, a, f.yy, E[1], i, r].concat(c))))
                                        return x;
                                    N && (n = n.slice(0, -1 * N * 2),
                                    i = i.slice(0, -1 * N),
                                    r = r.slice(0, -1 * N)),
                                    n.push(this.productions_[E[1]][0]),
                                    i.push(S.$),
                                    r.push(S._$),
                                    C = o[n[n.length - 2]][n[n.length - 1]],
                                    n.push(C);
                                    break;
                                case 3:
                                    return !0
                                }
                            }
                            return !0
                        }
                    }
                      , d = function() {
                        return {
                            EOF: 1,
                            parseError: function(t, e) {
                                if (!this.yy.parser)
                                    throw new Error(t);
                                this.yy.parser.parseError(t, e)
                            },
                            setInput: function(t, e) {
                                return this.yy = e || this.yy || {},
                                this._input = t,
                                this._more = this._backtrack = this.done = !1,
                                this.yylineno = this.yyleng = 0,
                                this.yytext = this.matched = this.match = "",
                                this.conditionStack = ["INITIAL"],
                                this.yylloc = {
                                    first_line: 1,
                                    first_column: 0,
                                    last_line: 1,
                                    last_column: 0
                                },
                                this.options.ranges && (this.yylloc.range = [0, 0]),
                                this.offset = 0,
                                this
                            },
                            input: function() {
                                var t = this._input[0];
                                return this.yytext += t,
                                this.yyleng++,
                                this.offset++,
                                this.match += t,
                                this.matched += t,
                                t.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++,
                                this.yylloc.last_line++) : this.yylloc.last_column++,
                                this.options.ranges && this.yylloc.range[1]++,
                                this._input = this._input.slice(1),
                                t
                            },
                            unput: function(t) {
                                var e = t.length
                                  , n = t.split(/(?:\r\n?|\n)/g);
                                this._input = t + this._input,
                                this.yytext = this.yytext.substr(0, this.yytext.length - e),
                                this.offset -= e;
                                var i = this.match.split(/(?:\r\n?|\n)/g);
                                this.match = this.match.substr(0, this.match.length - 1),
                                this.matched = this.matched.substr(0, this.matched.length - 1),
                                n.length - 1 && (this.yylineno -= n.length - 1);
                                var r = this.yylloc.range;
                                return this.yylloc = {
                                    first_line: this.yylloc.first_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.first_column,
                                    last_column: n ? (n.length === i.length ? this.yylloc.first_column : 0) + i[i.length - n.length].length - n[0].length : this.yylloc.first_column - e
                                },
                                this.options.ranges && (this.yylloc.range = [r[0], r[0] + this.yyleng - e]),
                                this.yyleng = this.yytext.length,
                                this
                            },
                            more: function() {
                                return this._more = !0,
                                this
                            },
                            reject: function() {
                                return this.options.backtrack_lexer ? (this._backtrack = !0,
                                this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                                    text: "",
                                    token: null,
                                    line: this.yylineno
                                })
                            },
                            less: function(t) {
                                this.unput(this.match.slice(t))
                            },
                            pastInput: function() {
                                var t = this.matched.substr(0, this.matched.length - this.match.length);
                                return (t.length > 20 ? "..." : "") + t.substr(-20).replace(/\n/g, "")
                            },
                            upcomingInput: function() {
                                var t = this.match;
                                return t.length < 20 && (t += this._input.substr(0, 20 - t.length)),
                                (t.substr(0, 20) + (t.length > 20 ? "..." : "")).replace(/\n/g, "")
                            },
                            showPosition: function() {
                                var t = this.pastInput()
                                  , e = new Array(t.length + 1).join("-");
                                return t + this.upcomingInput() + "\n" + e + "^"
                            },
                            test_match: function(t, e) {
                                var n, i, r;
                                if (this.options.backtrack_lexer && (r = {
                                    yylineno: this.yylineno,
                                    yylloc: {
                                        first_line: this.yylloc.first_line,
                                        last_line: this.last_line,
                                        first_column: this.yylloc.first_column,
                                        last_column: this.yylloc.last_column
                                    },
                                    yytext: this.yytext,
                                    match: this.match,
                                    matches: this.matches,
                                    matched: this.matched,
                                    yyleng: this.yyleng,
                                    offset: this.offset,
                                    _more: this._more,
                                    _input: this._input,
                                    yy: this.yy,
                                    conditionStack: this.conditionStack.slice(0),
                                    done: this.done
                                },
                                this.options.ranges && (r.yylloc.range = this.yylloc.range.slice(0))),
                                i = t[0].match(/(?:\r\n?|\n).*/g),
                                i && (this.yylineno += i.length),
                                this.yylloc = {
                                    first_line: this.yylloc.last_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.last_column,
                                    last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + t[0].length
                                },
                                this.yytext += t[0],
                                this.match += t[0],
                                this.matches = t,
                                this.yyleng = this.yytext.length,
                                this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]),
                                this._more = !1,
                                this._backtrack = !1,
                                this._input = this._input.slice(t[0].length),
                                this.matched += t[0],
                                n = this.performAction.call(this, this.yy, this, e, this.conditionStack[this.conditionStack.length - 1]),
                                this.done && this._input && (this.done = !1),
                                n)
                                    return n;
                                if (this._backtrack) {
                                    for (var o in r)
                                        this[o] = r[o];
                                    return !1
                                }
                                return !1
                            },
                            next: function() {
                                if (this.done)
                                    return this.EOF;
                                this._input || (this.done = !0);
                                var t, e, n, i;
                                this._more || (this.yytext = "",
                                this.match = "");
                                for (var r = this._currentRules(), o = 0; o < r.length; o++)
                                    if ((n = this._input.match(this.rules[r[o]])) && (!e || n[0].length > e[0].length)) {
                                        if (e = n,
                                        i = o,
                                        this.options.backtrack_lexer) {
                                            if (!1 !== (t = this.test_match(n, r[o])))
                                                return t;
                                            if (this._backtrack) {
                                                e = !1;
                                                continue
                                            }
                                            return !1
                                        }
                                        if (!this.options.flex)
                                            break
                                    }
                                return e ? !1 !== (t = this.test_match(e, r[i])) && t : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                                    text: "",
                                    token: null,
                                    line: this.yylineno
                                })
                            },
                            lex: function() {
                                var t = this.next();
                                return t || this.lex()
                            },
                            begin: function(t) {
                                this.conditionStack.push(t)
                            },
                            popState: function() {
                                return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0]
                            },
                            _currentRules: function() {
                                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules
                            },
                            topState: function(t) {
                                return t = this.conditionStack.length - 1 - Math.abs(t || 0),
                                t >= 0 ? this.conditionStack[t] : "INITIAL"
                            },
                            pushState: function(t) {
                                this.begin(t)
                            },
                            stateStackSize: function() {
                                return this.conditionStack.length
                            },
                            options: {},
                            performAction: function(t, e, n, i) {
                                switch (n) {
                                case 0:
                                    break;
                                case 1:
                                    return 6;
                                case 2:
                                    return e.yytext = e.yytext.substr(1, e.yyleng - 2),
                                    4;
                                case 3:
                                    return 17;
                                case 4:
                                    return 18;
                                case 5:
                                    return 23;
                                case 6:
                                    return 24;
                                case 7:
                                    return 22;
                                case 8:
                                    return 21;
                                case 9:
                                    return 10;
                                case 10:
                                    return 11;
                                case 11:
                                    return 8;
                                case 12:
                                    return 14;
                                case 13:
                                    return "INVALID"
                                }
                            },
                            rules: [/^(?:\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/, /^(?:"(?:\\[\\"bfnrt\/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/, /^(?:\{)/, /^(?:\})/, /^(?:\[)/, /^(?:\])/, /^(?:,)/, /^(?::)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:null\b)/, /^(?:$)/, /^(?:.)/],
                            conditions: {
                                INITIAL: {
                                    rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                                    inclusive: !0
                                }
                            }
                        }
                    }();
                    return f.lexer = d,
                    t.prototype = f,
                    f.Parser = t,
                    new t
                }();
                void 0 !== t && void 0 !== n && (n.parser = r,
                n.Parser = r.Parser,
                n.parse = function() {
                    return r.parse.apply(r, arguments)
                }
                ,
                n.main = function(e) {
                    e[1] || (console.log("Usage: " + e[0] + " FILE"),
                    i.exit(1));
                    var r = t("fs").readFileSync(t("path").normalize(e[1]), "utf8");
                    return n.parser.parse(r)
                }
                ,
                void 0 !== e && t.main === e && n.main(i.argv.slice(1)))
            }
            ).call(this, t("_process"))
        }
        , {
            _process: 56,
            fs: 41,
            path: 54
        }],
        53: [function(t, e, n) {
            (function(t) {
                function i(t, e) {
                    for (var n = -1, i = null == t ? 0 : t.length, r = 0, o = []; ++n < i; ) {
                        var s = t[n];
                        e(s, n, t) && (o[r++] = s)
                    }
                    return o
                }
                function r(t, e) {
                    for (var n = -1, i = e.length, r = t.length; ++n < i; )
                        t[r + n] = e[n];
                    return t
                }
                function o(t, e) {
                    for (var n = -1, i = null == t ? 0 : t.length; ++n < i; )
                        if (e(t[n], n, t))
                            return !0;
                    return !1
                }
                function s(t, e) {
                    for (var n = -1, i = Array(t); ++n < t; )
                        i[n] = e(n);
                    return i
                }
                function a(t, e) {
                    return t.has(e)
                }
                function u(t, e) {
                    return null == t ? void 0 : t[e]
                }
                function l(t) {
                    var e = -1
                      , n = Array(t.size);
                    return t.forEach(function(t, i) {
                        n[++e] = [i, t]
                    }),
                    n
                }
                function c(t) {
                    var e = -1
                      , n = Array(t.size);
                    return t.forEach(function(t) {
                        n[++e] = t
                    }),
                    n
                }
                function h(t) {
                    var e = -1
                      , n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n; ) {
                        var i = t[e];
                        this.set(i[0], i[1])
                    }
                }
                function f() {
                    this.__data__ = we ? we(null) : {},
                    this.size = 0
                }
                function d(t) {
                    var e = this.has(t) && delete this.__data__[t];
                    return this.size -= e ? 1 : 0,
                    e
                }
                function g(t) {
                    var e = this.__data__;
                    if (we) {
                        var n = e[t];
                        return n === vt ? void 0 : n
                    }
                    return se.call(e, t) ? e[t] : void 0
                }
                function p(t) {
                    var e = this.__data__;
                    return we ? void 0 !== e[t] : se.call(e, t)
                }
                function m(t, e) {
                    var n = this.__data__;
                    return this.size += this.has(t) ? 0 : 1,
                    n[t] = we && void 0 === e ? vt : e,
                    this
                }
                function y(t) {
                    var e = -1
                      , n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n; ) {
                        var i = t[e];
                        this.set(i[0], i[1])
                    }
                }
                function v() {
                    this.__data__ = [],
                    this.size = 0
                }
                function E(t) {
                    var e = this.__data__
                      , n = q(e, t);
                    return !(n < 0) && (n == e.length - 1 ? e.pop() : ge.call(e, n, 1),
                    --this.size,
                    !0)
                }
                function x(t) {
                    var e = this.__data__
                      , n = q(e, t);
                    return n < 0 ? void 0 : e[n][1]
                }
                function I(t) {
                    return q(this.__data__, t) > -1
                }
                function N(t, e) {
                    var n = this.__data__
                      , i = q(n, t);
                    return i < 0 ? (++this.size,
                    n.push([t, e])) : n[i][1] = e,
                    this
                }
                function C(t) {
                    var e = -1
                      , n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n; ) {
                        var i = t[e];
                        this.set(i[0], i[1])
                    }
                }
                function w() {
                    this.size = 0,
                    this.__data__ = {
                        hash: new h,
                        map: new (xe || y),
                        string: new h
                    }
                }
                function _(t) {
                    var e = Z(this, t).delete(t);
                    return this.size -= e ? 1 : 0,
                    e
                }
                function S(t) {
                    return Z(this, t).get(t)
                }
                function b(t) {
                    return Z(this, t).has(t)
                }
                function L(t, e) {
                    var n = Z(this, t)
                      , i = n.size;
                    return n.set(t, e),
                    this.size += n.size == i ? 0 : 1,
                    this
                }
                function T(t) {
                    var e = -1
                      , n = null == t ? 0 : t.length;
                    for (this.__data__ = new C; ++e < n; )
                        this.add(t[e])
                }
                function R(t) {
                    return this.__data__.set(t, vt),
                    this
                }
                function O(t) {
                    return this.__data__.has(t)
                }
                function P(t) {
                    var e = this.__data__ = new y(t);
                    this.size = e.size
                }
                function M() {
                    this.__data__ = new y,
                    this.size = 0
                }
                function A(t) {
                    var e = this.__data__
                      , n = e.delete(t);
                    return this.size = e.size,
                    n
                }
                function D(t) {
                    return this.__data__.get(t)
                }
                function F(t) {
                    return this.__data__.has(t)
                }
                function G(t, e) {
                    var n = this.__data__;
                    if (n instanceof y) {
                        var i = n.__data__;
                        if (!xe || i.length < yt - 1)
                            return i.push([t, e]),
                            this.size = ++n.size,
                            this;
                        n = this.__data__ = new C(i)
                    }
                    return n.set(t, e),
                    this.size = n.size,
                    this
                }
                function k(t, e) {
                    var n = De(t)
                      , i = !n && Ae(t)
                      , r = !n && !i && Fe(t)
                      , o = !n && !i && !r && Ge(t)
                      , a = n || i || r || o
                      , u = a ? s(t.length, String) : []
                      , l = u.length;
                    for (var c in t)
                        !e && !se.call(t, c) || a && ("length" == c || r && ("offset" == c || "parent" == c) || o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || et(c, l)) || u.push(c);
                    return u
                }
                function q(t, e) {
                    for (var n = t.length; n--; )
                        if (at(t[n][0], e))
                            return n;
                    return -1
                }
                function B(t, e, n) {
                    var i = e(t);
                    return De(t) ? i : r(i, n(t))
                }
                function U(t) {
                    return null == t ? void 0 === t ? qt : Pt : pe && pe in Object(t) ? tt(t) : ot(t)
                }
                function V(t) {
                    return dt(t) && U(t) == Nt
                }
                function z(t, e, n, i, r) {
                    return t === e || (null == t || null == e || !dt(t) && !dt(e) ? t !== t && e !== e : j(t, e, n, i, z, r))
                }
                function j(t, e, n, i, r, o) {
                    var s = De(t)
                      , a = De(e)
                      , u = s ? Ct : Me(t)
                      , l = a ? Ct : Me(e);
                    u = u == Nt ? Mt : u,
                    l = l == Nt ? Mt : l;
                    var c = u == Mt
                      , h = l == Mt
                      , f = u == l;
                    if (f && Fe(t)) {
                        if (!Fe(e))
                            return !1;
                        s = !0,
                        c = !1
                    }
                    if (f && !c)
                        return o || (o = new P),
                        s || Ge(t) ? W(t, e, n, i, r, o) : J(t, e, u, n, i, r, o);
                    if (!(n & Et)) {
                        var d = c && se.call(t, "__wrapped__")
                          , g = h && se.call(e, "__wrapped__");
                        if (d || g) {
                            var p = d ? t.value() : t
                              , m = g ? e.value() : e;
                            return o || (o = new P),
                            r(p, m, n, i, o)
                        }
                    }
                    return !!f && (o || (o = new P),
                    $(t, e, n, i, r, o))
                }
                function Y(t) {
                    return !(!ft(t) || it(t)) && (ct(t) ? le : zt).test(st(t))
                }
                function X(t) {
                    return dt(t) && ht(t.length) && !!Yt[U(t)]
                }
                function H(t) {
                    if (!rt(t))
                        return ve(t);
                    var e = [];
                    for (var n in Object(t))
                        se.call(t, n) && "constructor" != n && e.push(n);
                    return e
                }
                function W(t, e, n, i, r, s) {
                    var u = n & Et
                      , l = t.length
                      , c = e.length;
                    if (l != c && !(u && c > l))
                        return !1;
                    var h = s.get(t);
                    if (h && s.get(e))
                        return h == e;
                    var f = -1
                      , d = !0
                      , g = n & xt ? new T : void 0;
                    for (s.set(t, e),
                    s.set(e, t); ++f < l; ) {
                        var p = t[f]
                          , m = e[f];
                        if (i)
                            var y = u ? i(m, p, f, e, t, s) : i(p, m, f, t, e, s);
                        if (void 0 !== y) {
                            if (y)
                                continue;
                            d = !1;
                            break
                        }
                        if (g) {
                            if (!o(e, function(t, e) {
                                if (!a(g, e) && (p === t || r(p, t, n, i, s)))
                                    return g.push(e)
                            })) {
                                d = !1;
                                break
                            }
                        } else if (p !== m && !r(p, m, n, i, s)) {
                            d = !1;
                            break
                        }
                    }
                    return s.delete(t),
                    s.delete(e),
                    d
                }
                function J(t, e, n, i, r, o, s) {
                    switch (n) {
                    case Ut:
                        if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
                            return !1;
                        t = t.buffer,
                        e = e.buffer;
                    case Bt:
                        return !(t.byteLength != e.byteLength || !o(new fe(t), new fe(e)));
                    case _t:
                    case St:
                    case Ot:
                        return at(+t, +e);
                    case bt:
                        return t.name == e.name && t.message == e.message;
                    case Dt:
                    case Gt:
                        return t == e + "";
                    case Rt:
                        var a = l;
                    case Ft:
                        var u = i & Et;
                        if (a || (a = c),
                        t.size != e.size && !u)
                            return !1;
                        var h = s.get(t);
                        if (h)
                            return h == e;
                        i |= xt,
                        s.set(t, e);
                        var f = W(a(t), a(e), i, r, o, s);
                        return s.delete(t),
                        f;
                    case kt:
                        if (Oe)
                            return Oe.call(t) == Oe.call(e)
                    }
                    return !1
                }
                function $(t, e, n, i, r, o) {
                    var s = n & Et
                      , a = K(t)
                      , u = a.length;
                    if (u != K(e).length && !s)
                        return !1;
                    for (var l = u; l--; ) {
                        var c = a[l];
                        if (!(s ? c in e : se.call(e, c)))
                            return !1
                    }
                    var h = o.get(t);
                    if (h && o.get(e))
                        return h == e;
                    var f = !0;
                    o.set(t, e),
                    o.set(e, t);
                    for (var d = s; ++l < u; ) {
                        c = a[l];
                        var g = t[c]
                          , p = e[c];
                        if (i)
                            var m = s ? i(p, g, c, e, t, o) : i(g, p, c, t, e, o);
                        if (!(void 0 === m ? g === p || r(g, p, n, i, o) : m)) {
                            f = !1;
                            break
                        }
                        d || (d = "constructor" == c)
                    }
                    if (f && !d) {
                        var y = t.constructor
                          , v = e.constructor;
                        y != v && "constructor"in t && "constructor"in e && !("function" == typeof y && y instanceof y && "function" == typeof v && v instanceof v) && (f = !1)
                    }
                    return o.delete(t),
                    o.delete(e),
                    f
                }
                function K(t) {
                    return B(t, gt, Pe)
                }
                function Z(t, e) {
                    var n = t.__data__;
                    return nt(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
                }
                function Q(t, e) {
                    var n = u(t, e);
                    return Y(n) ? n : void 0
                }
                function tt(t) {
                    var e = se.call(t, pe)
                      , n = t[pe];
                    try {
                        t[pe] = void 0;
                        var i = !0
                    } catch (t) {}
                    var r = ue.call(t);
                    return i && (e ? t[pe] = n : delete t[pe]),
                    r
                }
                function et(t, e) {
                    return !!(e = null == e ? It : e) && ("number" == typeof t || jt.test(t)) && t > -1 && t % 1 == 0 && t < e
                }
                function nt(t) {
                    var e = typeof t;
                    return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
                }
                function it(t) {
                    return !!ae && ae in t
                }
                function rt(t) {
                    var e = t && t.constructor;
                    return t === ("function" == typeof e && e.prototype || ie)
                }
                function ot(t) {
                    return ue.call(t)
                }
                function st(t) {
                    if (null != t) {
                        try {
                            return oe.call(t)
                        } catch (t) {}
                        try {
                            return t + ""
                        } catch (t) {}
                    }
                    return ""
                }
                function at(t, e) {
                    return t === e || t !== t && e !== e
                }
                function ut(t) {
                    return null != t && ht(t.length) && !ct(t)
                }
                function lt(t, e) {
                    return z(t, e)
                }
                function ct(t) {
                    if (!ft(t))
                        return !1;
                    var e = U(t);
                    return e == Lt || e == Tt || e == wt || e == At
                }
                function ht(t) {
                    return "number" == typeof t && t > -1 && t % 1 == 0 && t <= It
                }
                function ft(t) {
                    var e = typeof t;
                    return null != t && ("object" == e || "function" == e)
                }
                function dt(t) {
                    return null != t && "object" == typeof t
                }
                function gt(t) {
                    return ut(t) ? k(t) : H(t)
                }
                function pt() {
                    return []
                }
                function mt() {
                    return !1
                }
                var yt = 200
                  , vt = "__lodash_hash_undefined__"
                  , Et = 1
                  , xt = 2
                  , It = 9007199254740991
                  , Nt = "[object Arguments]"
                  , Ct = "[object Array]"
                  , wt = "[object AsyncFunction]"
                  , _t = "[object Boolean]"
                  , St = "[object Date]"
                  , bt = "[object Error]"
                  , Lt = "[object Function]"
                  , Tt = "[object GeneratorFunction]"
                  , Rt = "[object Map]"
                  , Ot = "[object Number]"
                  , Pt = "[object Null]"
                  , Mt = "[object Object]"
                  , At = "[object Proxy]"
                  , Dt = "[object RegExp]"
                  , Ft = "[object Set]"
                  , Gt = "[object String]"
                  , kt = "[object Symbol]"
                  , qt = "[object Undefined]"
                  , Bt = "[object ArrayBuffer]"
                  , Ut = "[object DataView]"
                  , Vt = /[\\^$.*+?()[\]{}|]/g
                  , zt = /^\[object .+?Constructor\]$/
                  , jt = /^(?:0|[1-9]\d*)$/
                  , Yt = {};
                Yt["[object Float32Array]"] = Yt["[object Float64Array]"] = Yt["[object Int8Array]"] = Yt["[object Int16Array]"] = Yt["[object Int32Array]"] = Yt["[object Uint8Array]"] = Yt["[object Uint8ClampedArray]"] = Yt["[object Uint16Array]"] = Yt["[object Uint32Array]"] = !0,
                Yt[Nt] = Yt[Ct] = Yt[Bt] = Yt[_t] = Yt[Ut] = Yt[St] = Yt[bt] = Yt[Lt] = Yt[Rt] = Yt[Ot] = Yt[Mt] = Yt[Dt] = Yt[Ft] = Yt[Gt] = Yt["[object WeakMap]"] = !1;
                var Xt = "object" == typeof t && t && t.Object === Object && t
                  , Ht = "object" == typeof self && self && self.Object === Object && self
                  , Wt = Xt || Ht || Function("return this")()
                  , Jt = "object" == typeof n && n && !n.nodeType && n
                  , $t = Jt && "object" == typeof e && e && !e.nodeType && e
                  , Kt = $t && $t.exports === Jt
                  , Zt = Kt && Xt.process
                  , Qt = function() {
                    try {
                        return Zt && Zt.binding && Zt.binding("util")
                    } catch (t) {}
                }()
                  , te = Qt && Qt.isTypedArray
                  , ee = Array.prototype
                  , ne = Function.prototype
                  , ie = Object.prototype
                  , re = Wt["__core-js_shared__"]
                  , oe = ne.toString
                  , se = ie.hasOwnProperty
                  , ae = function() {
                    var t = /[^.]+$/.exec(re && re.keys && re.keys.IE_PROTO || "");
                    return t ? "Symbol(src)_1." + t : ""
                }()
                  , ue = ie.toString
                  , le = RegExp("^" + oe.call(se).replace(Vt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
                  , ce = Kt ? Wt.Buffer : void 0
                  , he = Wt.Symbol
                  , fe = Wt.Uint8Array
                  , de = ie.propertyIsEnumerable
                  , ge = ee.splice
                  , pe = he ? he.toStringTag : void 0
                  , me = Object.getOwnPropertySymbols
                  , ye = ce ? ce.isBuffer : void 0
                  , ve = function(t, e) {
                    return function(n) {
                        return t(e(n))
                    }
                }(Object.keys, Object)
                  , Ee = Q(Wt, "DataView")
                  , xe = Q(Wt, "Map")
                  , Ie = Q(Wt, "Promise")
                  , Ne = Q(Wt, "Set")
                  , Ce = Q(Wt, "WeakMap")
                  , we = Q(Object, "create")
                  , _e = st(Ee)
                  , Se = st(xe)
                  , be = st(Ie)
                  , Le = st(Ne)
                  , Te = st(Ce)
                  , Re = he ? he.prototype : void 0
                  , Oe = Re ? Re.valueOf : void 0;
                h.prototype.clear = f,
                h.prototype.delete = d,
                h.prototype.get = g,
                h.prototype.has = p,
                h.prototype.set = m,
                y.prototype.clear = v,
                y.prototype.delete = E,
                y.prototype.get = x,
                y.prototype.has = I,
                y.prototype.set = N,
                C.prototype.clear = w,
                C.prototype.delete = _,
                C.prototype.get = S,
                C.prototype.has = b,
                C.prototype.set = L,
                T.prototype.add = T.prototype.push = R,
                T.prototype.has = O,
                P.prototype.clear = M,
                P.prototype.delete = A,
                P.prototype.get = D,
                P.prototype.has = F,
                P.prototype.set = G;
                var Pe = me ? function(t) {
                    return null == t ? [] : (t = Object(t),
                    i(me(t), function(e) {
                        return de.call(t, e)
                    }))
                }
                : pt
                  , Me = U;
                (Ee && Me(new Ee(new ArrayBuffer(1))) != Ut || xe && Me(new xe) != Rt || Ie && "[object Promise]" != Me(Ie.resolve()) || Ne && Me(new Ne) != Ft || Ce && "[object WeakMap]" != Me(new Ce)) && (Me = function(t) {
                    var e = U(t)
                      , n = e == Mt ? t.constructor : void 0
                      , i = n ? st(n) : "";
                    if (i)
                        switch (i) {
                        case _e:
                            return Ut;
                        case Se:
                            return Rt;
                        case be:
                            return "[object Promise]";
                        case Le:
                            return Ft;
                        case Te:
                            return "[object WeakMap]"
                        }
                    return e
                }
                );
                var Ae = V(function() {
                    return arguments
                }()) ? V : function(t) {
                    return dt(t) && se.call(t, "callee") && !de.call(t, "callee")
                }
                  , De = Array.isArray
                  , Fe = ye || mt
                  , Ge = te ? function(t) {
                    return function(e) {
                        return t(e)
                    }
                }(te) : X;
                e.exports = lt
            }
            ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }
        , {}],
        54: [function(t, e, n) {
            (function(t) {
                function e(t, e) {
                    for (var n = 0, i = t.length - 1; i >= 0; i--) {
                        var r = t[i];
                        "." === r ? t.splice(i, 1) : ".." === r ? (t.splice(i, 1),
                        n++) : n && (t.splice(i, 1),
                        n--)
                    }
                    if (e)
                        for (; n--; n)
                            t.unshift("..");
                    return t
                }
                function i(t, e) {
                    if (t.filter)
                        return t.filter(e);
                    for (var n = [], i = 0; i < t.length; i++)
                        e(t[i], i, t) && n.push(t[i]);
                    return n
                }
                var r = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/
                  , o = function(t) {
                    return r.exec(t).slice(1)
                };
                n.resolve = function() {
                    for (var n = "", r = !1, o = arguments.length - 1; o >= -1 && !r; o--) {
                        var s = o >= 0 ? arguments[o] : t.cwd();
                        if ("string" != typeof s)
                            throw new TypeError("Arguments to path.resolve must be strings");
                        s && (n = s + "/" + n,
                        r = "/" === s.charAt(0))
                    }
                    return n = e(i(n.split("/"), function(t) {
                        return !!t
                    }), !r).join("/"),
                    (r ? "/" : "") + n || "."
                }
                ,
                n.normalize = function(t) {
                    var r = n.isAbsolute(t)
                      , o = "/" === s(t, -1);
                    return t = e(i(t.split("/"), function(t) {
                        return !!t
                    }), !r).join("/"),
                    t || r || (t = "."),
                    t && o && (t += "/"),
                    (r ? "/" : "") + t
                }
                ,
                n.isAbsolute = function(t) {
                    return "/" === t.charAt(0)
                }
                ,
                n.join = function() {
                    var t = Array.prototype.slice.call(arguments, 0);
                    return n.normalize(i(t, function(t, e) {
                        if ("string" != typeof t)
                            throw new TypeError("Arguments to path.join must be strings");
                        return t
                    }).join("/"))
                }
                ,
                n.relative = function(t, e) {
                    function i(t) {
                        for (var e = 0; e < t.length && "" === t[e]; e++)
                            ;
                        for (var n = t.length - 1; n >= 0 && "" === t[n]; n--)
                            ;
                        return e > n ? [] : t.slice(e, n - e + 1)
                    }
                    t = n.resolve(t).substr(1),
                    e = n.resolve(e).substr(1);
                    for (var r = i(t.split("/")), o = i(e.split("/")), s = Math.min(r.length, o.length), a = s, u = 0; u < s; u++)
                        if (r[u] !== o[u]) {
                            a = u;
                            break
                        }
                    for (var l = [], u = a; u < r.length; u++)
                        l.push("..");
                    return l = l.concat(o.slice(a)),
                    l.join("/")
                }
                ,
                n.sep = "/",
                n.delimiter = ":",
                n.dirname = function(t) {
                    var e = o(t)
                      , n = e[0]
                      , i = e[1];
                    return n || i ? (i && (i = i.substr(0, i.length - 1)),
                    n + i) : "."
                }
                ,
                n.basename = function(t, e) {
                    var n = o(t)[2];
                    return e && n.substr(-1 * e.length) === e && (n = n.substr(0, n.length - e.length)),
                    n
                }
                ,
                n.extname = function(t) {
                    return o(t)[3]
                }
                ;
                var s = "b" === "ab".substr(-1) ? function(t, e, n) {
                    return t.substr(e, n)
                }
                : function(t, e, n) {
                    return e < 0 && (e = t.length + e),
                    t.substr(e, n)
                }
            }
            ).call(this, t("_process"))
        }
        , {
            _process: 56
        }],
        55: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                this.x = t,
                this.y = e
            }
            e.exports = i,
            i.prototype = {
                clone: function() {
                    return new i(this.x,this.y)
                },
                add: function(t) {
                    return this.clone()._add(t)
                },
                sub: function(t) {
                    return this.clone()._sub(t)
                },
                mult: function(t) {
                    return this.clone()._mult(t)
                },
                div: function(t) {
                    return this.clone()._div(t)
                },
                rotate: function(t) {
                    return this.clone()._rotate(t)
                },
                matMult: function(t) {
                    return this.clone()._matMult(t)
                },
                unit: function() {
                    return this.clone()._unit()
                },
                perp: function() {
                    return this.clone()._perp()
                },
                round: function() {
                    return this.clone()._round()
                },
                mag: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                equals: function(t) {
                    return this.x === t.x && this.y === t.y
                },
                dist: function(t) {
                    return Math.sqrt(this.distSqr(t))
                },
                distSqr: function(t) {
                    var e = t.x - this.x
                      , n = t.y - this.y;
                    return e * e + n * n
                },
                angle: function() {
                    return Math.atan2(this.y, this.x)
                },
                angleTo: function(t) {
                    return Math.atan2(this.y - t.y, this.x - t.x)
                },
                angleWith: function(t) {
                    return this.angleWithSep(t.x, t.y)
                },
                angleWithSep: function(t, e) {
                    return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e)
                },
                _matMult: function(t) {
                    var e = t[0] * this.x + t[1] * this.y
                      , n = t[2] * this.x + t[3] * this.y;
                    return this.x = e,
                    this.y = n,
                    this
                },
                _add: function(t) {
                    return this.x += t.x,
                    this.y += t.y,
                    this
                },
                _sub: function(t) {
                    return this.x -= t.x,
                    this.y -= t.y,
                    this
                },
                _mult: function(t) {
                    return this.x *= t,
                    this.y *= t,
                    this
                },
                _div: function(t) {
                    return this.x /= t,
                    this.y /= t,
                    this
                },
                _unit: function() {
                    return this._div(this.mag()),
                    this
                },
                _perp: function() {
                    var t = this.y;
                    return this.y = this.x,
                    this.x = -t,
                    this
                },
                _rotate: function(t) {
                    var e = Math.cos(t)
                      , n = Math.sin(t)
                      , i = e * this.x - n * this.y
                      , r = n * this.x + e * this.y;
                    return this.x = i,
                    this.y = r,
                    this
                },
                _round: function() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this
                }
            },
            i.convert = function(t) {
                return t instanceof i ? t : Array.isArray(t) ? new i(t[0],t[1]) : t
            }
        }
        , {}],
        56: [function(t, e, n) {
            function i() {
                throw new Error("setTimeout has not been defined")
            }
            function r() {
                throw new Error("clearTimeout has not been defined")
            }
            function o(t) {
                if (h === setTimeout)
                    return setTimeout(t, 0);
                if ((h === i || !h) && setTimeout)
                    return h = setTimeout,
                    setTimeout(t, 0);
                try {
                    return h(t, 0)
                } catch (e) {
                    try {
                        return h.call(null, t, 0)
                    } catch (e) {
                        return h.call(this, t, 0)
                    }
                }
            }
            function s(t) {
                if (f === clearTimeout)
                    return clearTimeout(t);
                if ((f === r || !f) && clearTimeout)
                    return f = clearTimeout,
                    clearTimeout(t);
                try {
                    return f(t)
                } catch (e) {
                    try {
                        return f.call(null, t)
                    } catch (e) {
                        return f.call(this, t)
                    }
                }
            }
            function a() {
                m && g && (m = !1,
                g.length ? p = g.concat(p) : y = -1,
                p.length && u())
            }
            function u() {
                if (!m) {
                    var t = o(a);
                    m = !0;
                    for (var e = p.length; e; ) {
                        for (g = p,
                        p = []; ++y < e; )
                            g && g[y].run();
                        y = -1,
                        e = p.length
                    }
                    g = null,
                    m = !1,
                    s(t)
                }
            }
            function l(t, e) {
                this.fun = t,
                this.array = e
            }
            function c() {}
            var h, f, d = e.exports = {};
            !function() {
                try {
                    h = "function" == typeof setTimeout ? setTimeout : i
                } catch (t) {
                    h = i
                }
                try {
                    f = "function" == typeof clearTimeout ? clearTimeout : r
                } catch (t) {
                    f = r
                }
            }();
            var g, p = [], m = !1, y = -1;
            d.nextTick = function(t) {
                var e = new Array(arguments.length - 1);
                if (arguments.length > 1)
                    for (var n = 1; n < arguments.length; n++)
                        e[n - 1] = arguments[n];
                p.push(new l(t,e)),
                1 !== p.length || m || o(u)
            }
            ,
            l.prototype.run = function() {
                this.fun.apply(null, this.array)
            }
            ,
            d.title = "browser",
            d.browser = !0,
            d.env = {},
            d.argv = [],
            d.version = "",
            d.versions = {},
            d.on = c,
            d.addListener = c,
            d.once = c,
            d.off = c,
            d.removeListener = c,
            d.removeAllListeners = c,
            d.emit = c,
            d.prependListener = c,
            d.prependOnceListener = c,
            d.listeners = function(t) {
                return []
            }
            ,
            d.binding = function(t) {
                throw new Error("process.binding is not supported")
            }
            ,
            d.cwd = function() {
                return "/"
            }
            ,
            d.chdir = function(t) {
                throw new Error("process.chdir is not supported")
            }
            ,
            d.umask = function() {
                return 0
            }
        }
        , {}],
        57: [function(t, e, n) {
            "use strict";
            function i(t, e, n, s, a) {
                for (n = n || 0,
                s = s || t.length - 1,
                a = a || o; s > n; ) {
                    if (s - n > 600) {
                        var u = s - n + 1
                          , l = e - n + 1
                          , c = Math.log(u)
                          , h = .5 * Math.exp(2 * c / 3)
                          , f = .5 * Math.sqrt(c * h * (u - h) / u) * (l - u / 2 < 0 ? -1 : 1);
                        i(t, e, Math.max(n, Math.floor(e - l * h / u + f)), Math.min(s, Math.floor(e + (u - l) * h / u + f)), a)
                    }
                    var d = t[e]
                      , g = n
                      , p = s;
                    for (r(t, n, e),
                    a(t[s], d) > 0 && r(t, n, s); g < p; ) {
                        for (r(t, g, p),
                        g++,
                        p--; a(t[g], d) < 0; )
                            g++;
                        for (; a(t[p], d) > 0; )
                            p--
                    }
                    0 === a(t[n], d) ? r(t, n, p) : (p++,
                    r(t, p, s)),
                    p <= e && (n = p + 1),
                    e <= p && (s = p - 1)
                }
            }
            function r(t, e, n) {
                var i = t[e];
                t[e] = t[n],
                t[n] = i
            }
            function o(t, e) {
                return t < e ? -1 : t > e ? 1 : 0
            }
            e.exports = i
        }
        , {}],
        58: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                if (!(this instanceof i))
                    return new i(t,e);
                this._maxEntries = Math.max(4, t || 9),
                this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)),
                e && this._initFormat(e),
                this.clear()
            }
            function r(t, e, n) {
                if (!n)
                    return e.indexOf(t);
                for (var i = 0; i < e.length; i++)
                    if (n(t, e[i]))
                        return i;
                return -1
            }
            function o(t, e) {
                s(t, 0, t.children.length, e, t)
            }
            function s(t, e, n, i, r) {
                r || (r = m(null)),
                r.minX = 1 / 0,
                r.minY = 1 / 0,
                r.maxX = -1 / 0,
                r.maxY = -1 / 0;
                for (var o, s = e; s < n; s++)
                    o = t.children[s],
                    a(r, t.leaf ? i(o) : o);
                return r
            }
            function a(t, e) {
                return t.minX = Math.min(t.minX, e.minX),
                t.minY = Math.min(t.minY, e.minY),
                t.maxX = Math.max(t.maxX, e.maxX),
                t.maxY = Math.max(t.maxY, e.maxY),
                t
            }
            function u(t, e) {
                return t.minX - e.minX
            }
            function l(t, e) {
                return t.minY - e.minY
            }
            function c(t) {
                return (t.maxX - t.minX) * (t.maxY - t.minY)
            }
            function h(t) {
                return t.maxX - t.minX + (t.maxY - t.minY)
            }
            function f(t, e) {
                return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY))
            }
            function d(t, e) {
                var n = Math.max(t.minX, e.minX)
                  , i = Math.max(t.minY, e.minY)
                  , r = Math.min(t.maxX, e.maxX)
                  , o = Math.min(t.maxY, e.maxY);
                return Math.max(0, r - n) * Math.max(0, o - i)
            }
            function g(t, e) {
                return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
            }
            function p(t, e) {
                return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
            }
            function m(t) {
                return {
                    children: t,
                    height: 1,
                    leaf: !0,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                }
            }
            function y(t, e, n, i, r) {
                for (var o, s = [e, n]; s.length; )
                    n = s.pop(),
                    e = s.pop(),
                    n - e <= i || (o = e + Math.ceil((n - e) / i / 2) * i,
                    v(t, o, e, n, r),
                    s.push(e, o, o, n))
            }
            e.exports = i;
            var v = t("quickselect");
            i.prototype = {
                all: function() {
                    return this._all(this.data, [])
                },
                search: function(t) {
                    var e = this.data
                      , n = []
                      , i = this.toBBox;
                    if (!p(t, e))
                        return n;
                    for (var r, o, s, a, u = []; e; ) {
                        for (r = 0,
                        o = e.children.length; r < o; r++)
                            s = e.children[r],
                            a = e.leaf ? i(s) : s,
                            p(t, a) && (e.leaf ? n.push(s) : g(t, a) ? this._all(s, n) : u.push(s));
                        e = u.pop()
                    }
                    return n
                },
                collides: function(t) {
                    var e = this.data
                      , n = this.toBBox;
                    if (!p(t, e))
                        return !1;
                    for (var i, r, o, s, a = []; e; ) {
                        for (i = 0,
                        r = e.children.length; i < r; i++)
                            if (o = e.children[i],
                            s = e.leaf ? n(o) : o,
                            p(t, s)) {
                                if (e.leaf || g(t, s))
                                    return !0;
                                a.push(o)
                            }
                        e = a.pop()
                    }
                    return !1
                },
                load: function(t) {
                    if (!t || !t.length)
                        return this;
                    if (t.length < this._minEntries) {
                        for (var e = 0, n = t.length; e < n; e++)
                            this.insert(t[e]);
                        return this
                    }
                    var i = this._build(t.slice(), 0, t.length - 1, 0);
                    if (this.data.children.length)
                        if (this.data.height === i.height)
                            this._splitRoot(this.data, i);
                        else {
                            if (this.data.height < i.height) {
                                var r = this.data;
                                this.data = i,
                                i = r
                            }
                            this._insert(i, this.data.height - i.height - 1, !0)
                        }
                    else
                        this.data = i;
                    return this
                },
                insert: function(t) {
                    return t && this._insert(t, this.data.height - 1),
                    this
                },
                clear: function() {
                    return this.data = m([]),
                    this
                },
                remove: function(t, e) {
                    if (!t)
                        return this;
                    for (var n, i, o, s, a = this.data, u = this.toBBox(t), l = [], c = []; a || l.length; ) {
                        if (a || (a = l.pop(),
                        i = l[l.length - 1],
                        n = c.pop(),
                        s = !0),
                        a.leaf && -1 !== (o = r(t, a.children, e)))
                            return a.children.splice(o, 1),
                            l.push(a),
                            this._condense(l),
                            this;
                        s || a.leaf || !g(a, u) ? i ? (n++,
                        a = i.children[n],
                        s = !1) : a = null : (l.push(a),
                        c.push(n),
                        n = 0,
                        i = a,
                        a = a.children[0])
                    }
                    return this
                },
                toBBox: function(t) {
                    return t
                },
                compareMinX: u,
                compareMinY: l,
                toJSON: function() {
                    return this.data
                },
                fromJSON: function(t) {
                    return this.data = t,
                    this
                },
                _all: function(t, e) {
                    for (var n = []; t; )
                        t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children),
                        t = n.pop();
                    return e
                },
                _build: function(t, e, n, i) {
                    var r, s = n - e + 1, a = this._maxEntries;
                    if (s <= a)
                        return r = m(t.slice(e, n + 1)),
                        o(r, this.toBBox),
                        r;
                    i || (i = Math.ceil(Math.log(s) / Math.log(a)),
                    a = Math.ceil(s / Math.pow(a, i - 1))),
                    r = m([]),
                    r.leaf = !1,
                    r.height = i;
                    var u, l, c, h, f = Math.ceil(s / a), d = f * Math.ceil(Math.sqrt(a));
                    for (y(t, e, n, d, this.compareMinX),
                    u = e; u <= n; u += d)
                        for (c = Math.min(u + d - 1, n),
                        y(t, u, c, f, this.compareMinY),
                        l = u; l <= c; l += f)
                            h = Math.min(l + f - 1, c),
                            r.children.push(this._build(t, l, h, i - 1));
                    return o(r, this.toBBox),
                    r
                },
                _chooseSubtree: function(t, e, n, i) {
                    for (var r, o, s, a, u, l, h, d; ; ) {
                        if (i.push(e),
                        e.leaf || i.length - 1 === n)
                            break;
                        for (h = d = 1 / 0,
                        r = 0,
                        o = e.children.length; r < o; r++)
                            s = e.children[r],
                            u = c(s),
                            l = f(t, s) - u,
                            l < d ? (d = l,
                            h = u < h ? u : h,
                            a = s) : l === d && u < h && (h = u,
                            a = s);
                        e = a || e.children[0]
                    }
                    return e
                },
                _insert: function(t, e, n) {
                    var i = this.toBBox
                      , r = n ? t : i(t)
                      , o = []
                      , s = this._chooseSubtree(r, this.data, e, o);
                    for (s.children.push(t),
                    a(s, r); e >= 0 && o[e].children.length > this._maxEntries; )
                        this._split(o, e),
                        e--;
                    this._adjustParentBBoxes(r, o, e)
                },
                _split: function(t, e) {
                    var n = t[e]
                      , i = n.children.length
                      , r = this._minEntries;
                    this._chooseSplitAxis(n, r, i);
                    var s = this._chooseSplitIndex(n, r, i)
                      , a = m(n.children.splice(s, n.children.length - s));
                    a.height = n.height,
                    a.leaf = n.leaf,
                    o(n, this.toBBox),
                    o(a, this.toBBox),
                    e ? t[e - 1].children.push(a) : this._splitRoot(n, a)
                },
                _splitRoot: function(t, e) {
                    this.data = m([t, e]),
                    this.data.height = t.height + 1,
                    this.data.leaf = !1,
                    o(this.data, this.toBBox)
                },
                _chooseSplitIndex: function(t, e, n) {
                    var i, r, o, a, u, l, h, f;
                    for (l = h = 1 / 0,
                    i = e; i <= n - e; i++)
                        r = s(t, 0, i, this.toBBox),
                        o = s(t, i, n, this.toBBox),
                        a = d(r, o),
                        u = c(r) + c(o),
                        a < l ? (l = a,
                        f = i,
                        h = u < h ? u : h) : a === l && u < h && (h = u,
                        f = i);
                    return f
                },
                _chooseSplitAxis: function(t, e, n) {
                    var i = t.leaf ? this.compareMinX : u
                      , r = t.leaf ? this.compareMinY : l;
                    this._allDistMargin(t, e, n, i) < this._allDistMargin(t, e, n, r) && t.children.sort(i)
                },
                _allDistMargin: function(t, e, n, i) {
                    t.children.sort(i);
                    var r, o, u = this.toBBox, l = s(t, 0, e, u), c = s(t, n - e, n, u), f = h(l) + h(c);
                    for (r = e; r < n - e; r++)
                        o = t.children[r],
                        a(l, t.leaf ? u(o) : o),
                        f += h(l);
                    for (r = n - e - 1; r >= e; r--)
                        o = t.children[r],
                        a(c, t.leaf ? u(o) : o),
                        f += h(c);
                    return f
                },
                _adjustParentBBoxes: function(t, e, n) {
                    for (var i = n; i >= 0; i--)
                        a(e[i], t)
                },
                _condense: function(t) {
                    for (var e, n = t.length - 1; n >= 0; n--)
                        0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children,
                        e.splice(e.indexOf(t[n]), 1)) : this.clear() : o(t[n], this.toBBox)
                },
                _initFormat: function(t) {
                    var e = ["return a", " - b", ";"];
                    this.compareMinX = new Function("a","b",e.join(t[0])),
                    this.compareMinY = new Function("a","b",e.join(t[1])),
                    this.toBBox = new Function("a","return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};")
                }
            }
        }
        , {
            quickselect: 57
        }],
        59: [function(t, e, n) {
            function i(t) {
                this.value = t
            }
            function r(t, e, n) {
                var i = []
                  , r = []
                  , s = !0;
                return function t(a) {
                    function u() {
                        if ("object" == typeof f.node && null !== f.node) {
                            f.keys && f.node_ === f.node || (f.keys = g(f.node)),
                            f.isLeaf = 0 == f.keys.length;
                            for (var t = 0; t < r.length; t++)
                                if (r[t].node_ === a) {
                                    f.circular = r[t];
                                    break
                                }
                        } else
                            f.isLeaf = !0,
                            f.keys = null;
                        f.notLeaf = !f.isLeaf,
                        f.notRoot = !f.isRoot
                    }
                    var l = n ? o(a) : a
                      , c = {}
                      , h = !0
                      , f = {
                        node: l,
                        node_: a,
                        path: [].concat(i),
                        parent: r[r.length - 1],
                        parents: r,
                        key: i.slice(-1)[0],
                        isRoot: 0 === i.length,
                        level: i.length,
                        circular: null,
                        update: function(t, e) {
                            f.isRoot || (f.parent.node[f.key] = t),
                            f.node = t,
                            e && (h = !1)
                        },
                        delete: function(t) {
                            delete f.parent.node[f.key],
                            t && (h = !1)
                        },
                        remove: function(t) {
                            p(f.parent.node) ? f.parent.node.splice(f.key, 1) : delete f.parent.node[f.key],
                            t && (h = !1)
                        },
                        keys: null,
                        before: function(t) {
                            c.before = t
                        },
                        after: function(t) {
                            c.after = t
                        },
                        pre: function(t) {
                            c.pre = t
                        },
                        post: function(t) {
                            c.post = t
                        },
                        stop: function() {
                            s = !1
                        },
                        block: function() {
                            h = !1
                        }
                    };
                    if (!s)
                        return f;
                    u();
                    var d = e.call(f, f.node);
                    return void 0 !== d && f.update && f.update(d),
                    c.before && c.before.call(f, f.node),
                    h ? ("object" != typeof f.node || null === f.node || f.circular || (r.push(f),
                    u(),
                    m(f.keys, function(e, r) {
                        i.push(e),
                        c.pre && c.pre.call(f, f.node[e], e);
                        var o = t(f.node[e]);
                        n && y.call(f.node, e) && (f.node[e] = o.node),
                        o.isLast = r == f.keys.length - 1,
                        o.isFirst = 0 == r,
                        c.post && c.post.call(f, o),
                        i.pop()
                    }),
                    r.pop()),
                    c.after && c.after.call(f, f.node),
                    f) : f
                }(t).node
            }
            function o(t) {
                if ("object" == typeof t && null !== t) {
                    var e;
                    if (p(t))
                        e = [];
                    else if (a(t))
                        e = new Date(t.getTime ? t.getTime() : t);
                    else if (u(t))
                        e = new RegExp(t);
                    else if (l(t))
                        e = {
                            message: t.message
                        };
                    else if (c(t))
                        e = new Boolean(t);
                    else if (h(t))
                        e = new Number(t);
                    else if (f(t))
                        e = new String(t);
                    else if (Object.create && Object.getPrototypeOf)
                        e = Object.create(Object.getPrototypeOf(t));
                    else if (t.constructor === Object)
                        e = {};
                    else {
                        var n = t.constructor && t.constructor.prototype || t.__proto__ || {}
                          , i = function() {};
                        i.prototype = n,
                        e = new i
                    }
                    return m(g(t), function(n) {
                        e[n] = t[n]
                    }),
                    e
                }
                return t
            }
            function s(t) {
                return Object.prototype.toString.call(t)
            }
            function a(t) {
                return "[object Date]" === s(t)
            }
            function u(t) {
                return "[object RegExp]" === s(t)
            }
            function l(t) {
                return "[object Error]" === s(t)
            }
            function c(t) {
                return "[object Boolean]" === s(t)
            }
            function h(t) {
                return "[object Number]" === s(t)
            }
            function f(t) {
                return "[object String]" === s(t)
            }
            var d = e.exports = function(t) {
                return new i(t)
            }
            ;
            i.prototype.get = function(t) {
                for (var e = this.value, n = 0; n < t.length; n++) {
                    var i = t[n];
                    if (!e || !y.call(e, i)) {
                        e = void 0;
                        break
                    }
                    e = e[i]
                }
                return e
            }
            ,
            i.prototype.has = function(t) {
                for (var e = this.value, n = 0; n < t.length; n++) {
                    var i = t[n];
                    if (!e || !y.call(e, i))
                        return !1;
                    e = e[i]
                }
                return !0
            }
            ,
            i.prototype.set = function(t, e) {
                for (var n = this.value, i = 0; i < t.length - 1; i++) {
                    var r = t[i];
                    y.call(n, r) || (n[r] = {}),
                    n = n[r]
                }
                return n[t[i]] = e,
                e
            }
            ,
            i.prototype.map = function(t) {
                return r(this.value, t, !0)
            }
            ,
            i.prototype.forEach = function(t) {
                return this.value = r(this.value, t, !1),
                this.value
            }
            ,
            i.prototype.reduce = function(t, e) {
                var n = 1 === arguments.length
                  , i = n ? this.value : e;
                return this.forEach(function(e) {
                    this.isRoot && n || (i = t.call(this, i, e))
                }),
                i
            }
            ,
            i.prototype.paths = function() {
                var t = [];
                return this.forEach(function(e) {
                    t.push(this.path)
                }),
                t
            }
            ,
            i.prototype.nodes = function() {
                var t = [];
                return this.forEach(function(e) {
                    t.push(this.node)
                }),
                t
            }
            ,
            i.prototype.clone = function() {
                var t = []
                  , e = [];
                return function n(i) {
                    for (var r = 0; r < t.length; r++)
                        if (t[r] === i)
                            return e[r];
                    if ("object" == typeof i && null !== i) {
                        var s = o(i);
                        return t.push(i),
                        e.push(s),
                        m(g(i), function(t) {
                            s[t] = n(i[t])
                        }),
                        t.pop(),
                        e.pop(),
                        s
                    }
                    return i
                }(this.value)
            }
            ;
            var g = Object.keys || function(t) {
                var e = [];
                for (var n in t)
                    e.push(n);
                return e
            }
              , p = Array.isArray || function(t) {
                return "[object Array]" === Object.prototype.toString.call(t)
            }
              , m = function(t, e) {
                if (t.forEach)
                    return t.forEach(e);
                for (var n = 0; n < t.length; n++)
                    e(t[n], n, t)
            };
            m(g(i.prototype), function(t) {
                d[t] = function(e) {
                    var n = [].slice.call(arguments, 1)
                      , r = new i(e);
                    return r[t].apply(r, n)
                }
            });
            var y = Object.hasOwnProperty || function(t, e) {
                return e in t
            }
        }
        , {}],
        60: [function(t, e, n) {
            e.exports.RADIUS = 6378137,
            e.exports.FLATTENING = 1 / 298.257223563,
            e.exports.POLAR_RADIUS = 6356752.3142
        }
        , {}],
        61: [function(t, e, n) {
            function i() {
                for (var t = {}, e = 0; e < arguments.length; e++) {
                    var n = arguments[e];
                    for (var i in n)
                        r.call(n, i) && (t[i] = n[i])
                }
                return t
            }
            e.exports = i;
            var r = Object.prototype.hasOwnProperty
        }
        , {}],
        62: [function(t, e, n) {
            "use strict";
            var i = t("lodash.isequal")
              , r = t("@mapbox/geojson-normalize")
              , o = t("hat")
              , s = t("./lib/features_at")
              , a = t("./lib/string_sets_are_equal")
              , u = t("@mapbox/geojsonhint")
              , l = t("./constants")
              , c = t("./lib/string_set")
              , h = {
                Polygon: t("./feature_types/polygon"),
                LineString: t("./feature_types/line_string"),
                Point: t("./feature_types/point"),
                MultiPolygon: t("./feature_types/multi_feature"),
                MultiLineString: t("./feature_types/multi_feature"),
                MultiPoint: t("./feature_types/multi_feature")
            };
            e.exports = function(t, e) {
                return e.modes = l.modes,
                e.getFeatureIdsAt = function(e) {
                    return s.click({
                        point: e
                    }, null, t).map(function(t) {
                        return t.properties.id
                    })
                }
                ,
                e.getSelectedIds = function() {
                    return t.store.getSelectedIds()
                }
                ,
                e.getSelected = function() {
                    return {
                        type: l.geojsonTypes.FEATURE_COLLECTION,
                        features: t.store.getSelectedIds().map(function(e) {
                            return t.store.get(e)
                        }).map(function(t) {
                            return t.toGeoJSON()
                        })
                    }
                }
                ,
                e.getSelectedPoints = function() {
                    return {
                        type: l.geojsonTypes.FEATURE_COLLECTION,
                        features: t.store.getSelectedCoordinates().map(function(t) {
                            return {
                                type: l.geojsonTypes.FEATURE,
                                properties: {},
                                geometry: {
                                    type: l.geojsonTypes.POINT,
                                    coordinates: t.coordinates
                                }
                            }
                        })
                    }
                }
                ,
                e.set = function(n) {
                    if (void 0 === n.type || n.type !== l.geojsonTypes.FEATURE_COLLECTION || !Array.isArray(n.features))
                        throw new Error("Invalid FeatureCollection");
                    var i = t.store.createRenderBatch()
                      , r = t.store.getAllIds().slice()
                      , o = e.add(n)
                      , s = new c(o);
                    return r = r.filter(function(t) {
                        return !s.has(t)
                    }),
                    r.length && e.delete(r),
                    i(),
                    o
                }
                ,
                e.add = function(e) {
                    var n = u.hint(e, {
                        precisionWarning: !1
                    }).filter(function(t) {
                        return "message" !== t.level
                    });
                    if (n.length)
                        throw new Error(n[0].message);
                    var s = JSON.parse(JSON.stringify(r(e)))
                      , a = s.features.map(function(e) {
                        if (e.id = e.id || o(),
                        null === e.geometry)
                            throw new Error("Invalid geometry: null");
                        if (void 0 === t.store.get(e.id) || t.store.get(e.id).type !== e.geometry.type) {
                            var n = h[e.geometry.type];
                            if (void 0 === n)
                                throw new Error("Invalid geometry type: " + e.geometry.type + ".");
                            var r = new n(t,e);
                            t.store.add(r)
                        } else {
                            var s = t.store.get(e.id);
                            s.properties = e.properties,
                            i(s.getCoordinates(), e.geometry.coordinates) || s.incomingCoords(e.geometry.coordinates)
                        }
                        return e.id
                    });
                    return t.store.render(),
                    a
                }
                ,
                e.get = function(e) {
                    var n = t.store.get(e);
                    if (n)
                        return n.toGeoJSON()
                }
                ,
                e.getAll = function() {
                    return {
                        type: l.geojsonTypes.FEATURE_COLLECTION,
                        features: t.store.getAll().map(function(t) {
                            return t.toGeoJSON()
                        })
                    }
                }
                ,
                e.delete = function(n) {
                    return t.store.delete(n, {
                        silent: !0
                    }),
                    e.getMode() !== l.modes.DIRECT_SELECT || t.store.getSelectedIds().length ? t.store.render() : t.events.changeMode(l.modes.SIMPLE_SELECT, void 0, {
                        silent: !0
                    }),
                    e
                }
                ,
                e.deleteAll = function() {
                    return t.store.delete(t.store.getAllIds(), {
                        silent: !0
                    }),
                    e.getMode() === l.modes.DIRECT_SELECT ? t.events.changeMode(l.modes.SIMPLE_SELECT, void 0, {
                        silent: !0
                    }) : t.store.render(),
                    e
                }
                ,
                e.changeMode = function(n) {
                    var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return n === l.modes.SIMPLE_SELECT && e.getMode() === l.modes.SIMPLE_SELECT ? a(i.featureIds || [], t.store.getSelectedIds()) ? e : (t.store.setSelected(i.featureIds, {
                        silent: !0
                    }),
                    t.store.render(),
                    e) : n === l.modes.DIRECT_SELECT && e.getMode() === l.modes.DIRECT_SELECT && i.featureId === t.store.getSelectedIds()[0] ? e : (t.events.changeMode(n, i, {
                        silent: !0
                    }),
                    e)
                }
                ,
                e.getMode = function() {
                    return t.events.getMode()
                }
                ,
                e.trash = function() {
                    return t.events.trash({
                        silent: !0
                    }),
                    e
                }
                ,
                e.combineFeatures = function() {
                    return t.events.combineFeatures({
                        silent: !0
                    }),
                    e
                }
                ,
                e.uncombineFeatures = function() {
                    return t.events.uncombineFeatures({
                        silent: !0
                    }),
                    e
                }
                ,
                e.unionPolygon = function() {
                    return t.events.unionPolygon({
                        silent: !0
                    }),
                    e
                }
                ,
                e.unionLine = function() {
                    return t.events.unionLine({
                        silent: !0
                    }),
                    e
                }
                ,
                e.splitLine = function() {
                    return t.events.splitLine({
                        silent: !0
                    }),
                    e
                }
                ,
                e.curveLine = function() {
                    return t.events.curveLine({
                        silent: !0
                    }),
                    e
                }
                ,
                e.setFeatureProperty = function(n, i, r) {
                    return t.store.setFeatureProperty(n, i, r),
                    e
                }
                ,
                e
            }
        }
        , {
            "./constants": 63,
            "./feature_types/line_string": 76,
            "./feature_types/multi_feature": 77,
            "./feature_types/point": 78,
            "./feature_types/polygon": 79,
            "./lib/features_at": 90,
            "./lib/string_set": 100,
            "./lib/string_sets_are_equal": 101,
            "@mapbox/geojson-normalize": 2,
            "@mapbox/geojsonhint": 3,
            hat: 51,
            "lodash.isequal": 53
        }],
        63: [function(t, e, n) {
            "use strict";
            e.exports = {
                classes: {
                    CONTROL_BASE: "minemap-ctrl",
                    CONTROL_PREFIX: "minemap-ctrl-",
                    CONTROL_BUTTON: "minemap-draw_ctrl-draw-btn",
                    CONTROL_BUTTON_LINE: "minemap-draw_line",
                    CONTROL_BUTTON_POLYGON: "minemap-draw_polygon",
                    CONTROL_BUTTON_CIRCLE: "minemap-draw_circle",
                    CONTROL_BUTTON_POINT: "minemap-draw_point",
                    CONTROL_BUTTON_TRASH: "minemap-draw_trash",
                    CONTROL_BUTTON_COMBINE_FEATURES: "minemap-draw_combine",
                    CONTROL_BUTTON_UNCOMBINE_FEATURES: "minemap-draw_uncombine",
                    CONTROL_GROUP: "minemap-ctrl-group",
                    ATTRIBUTION: "minemap-ctrl-attrib",
                    ACTIVE_BUTTON: "active",
                    BOX_SELECT: "minemap-draw_boxselect"
                },
                sources: {
                    HOT: "minemap-draw-hot",
                    COLD: "minemap-draw-cold"
                },
                cursors: {
                    ADD: "add",
                    MOVE: "move",
                    DRAG: "drag",
                    POINTER: "pointer",
                    NONE: "none"
                },
                types: {
                    POLYGON: "polygon",
                    LINE: "line_string",
                    POINT: "point",
                    CIRCLE: "circle",
                    RECTANGLE: "rectangle",
                    TRIANGLE: "triangle",
                    SECTOR: "sector"
                },
                geojsonTypes: {
                    FEATURE: "Feature",
                    POLYGON: "Polygon",
                    LINE_STRING: "LineString",
                    POINT: "Point",
                    FEATURE_COLLECTION: "FeatureCollection",
                    MULTI_PREFIX: "Multi",
                    MULTI_POINT: "MultiPoint",
                    MULTI_LINE_STRING: "MultiLineString",
                    MULTI_POLYGON: "MultiPolygon"
                },
                modes: {
                    DRAW_LINE_STRING: "draw_line_string",
                    DRAW_POLYGON: "draw_polygon",
                    DRAW_CIRCLE: "draw_circle",
                    DRAW_RECTANGLE: "draw_rectangle",
                    DRAW_TRIANGLE: "draw_triangle",
                    DRAW_SECTOR: "draw_sector",
                    DRAW_POINT: "draw_point",
                    SPLIT_POLYGON: "split_polygon",
                    SIMPLE_SELECT: "simple_select",
                    DIRECT_SELECT: "direct_select",
                    STATIC: "static"
                },
                events: {
                    CREATE: "draw.create",
                    DELETE: "draw.delete",
                    UPDATE: "draw.update",
                    SELECTION_CHANGE: "draw.selectionchange",
                    MODE_CHANGE: "draw.modechange",
                    ACTIONABLE: "draw.actionable",
                    RENDER: "draw.render",
                    COMBINE_FEATURES: "draw.combine",
                    UNCOMBINE_FEATURES: "draw.uncombine",
                    REPLACE: "draw.replace",
                    RECORD_CREATE: "edit.record.create",
                    UNDO: "edit.undo",
                    REDO: "edit.redo",
                    SELECTED: "edit.selected"
                },
                updateActions: {
                    MOVE: "move",
                    CHANGE_COORDINATES: "change_coordinates",
                    CHANGE_PROPERTIES: "change_properties"
                },
                meta: {
                    FEATURE: "feature",
                    MIDPOINT: "midpoint",
                    VERTEX: "vertex"
                },
                activeStates: {
                    ACTIVE: "true",
                    INACTIVE: "false"
                },
                LAT_MIN: -90,
                LAT_RENDERED_MIN: -85,
                LAT_MAX: 90,
                LAT_RENDERED_MAX: 85,
                LNG_MIN: -270,
                LNG_MAX: 270
            }
        }
        , {}],
        64: [function(t, e, n) {
            "use strict";
            var i = t("../constants")
              , r = function(t, e) {
                switch (e) {
                case "point":
                    t.draw.changeMode(i.modes.DRAW_POINT);
                    break;
                case "line":
                    t.draw.changeMode(i.modes.DRAW_LINE_STRING);
                    break;
                case "polygon":
                    t.draw.changeMode(i.modes.DRAW_POLYGON);
                    break;
                case "rectangle":
                    t.draw.changeMode(i.modes.DRAW_RECTANGLE);
                    break;
                case "triangle":
                    t.draw.changeMode(i.modes.DRAW_TRIANGLE);
                    break;
                case "circle":
                    t.draw.changeMode(i.modes.DRAW_CIRCLE);
                    break;
                case "sector":
                    t.draw.changeMode(i.modes.DRAW_SECTOR);
                    break;
                case "trash":
                    t.draw.trash();
                    break;
                case "combine":
                    t.draw.combineFeatures();
                    break;
                case "uncombine":
                    t.draw.uncombineFeatures();
                    break;
                case "union_polygon":
                    t.draw.unionPolygon();
                    break;
                case "split_polygon":
                    t.draw.changeMode(i.modes.SPLIT_POLYGON);
                    break;
                case "union_line":
                    t.draw.unionLine();
                    break;
                case "split_line":
                    t.draw.splitLine();
                    break;
                case "curve_line":
                    t.draw.curveLine();
                    break;
                case "undo":
                    t.undoOperation();
                    break;
                case "redo":
                    t.redoOperation();
                    break;
                case "static":
                    t.draw.changeMode(i.modes.STATIC)
                }
            };
            e.exports = r
        }
        , {
            "../constants": 63
        }],
        65: [function(t, e, n) {
            "use strict";
            var i = t("../setup")
              , r = t("../options")
              , o = t("../api")
              , s = t("../constants")
              , a = function(e, n) {
                e.styles || (e.styles = t("./theme")),
                e = r(e);
                var a = {
                    options: e
                };
                n = o(a, n),
                a.api = n;
                var u = i(a);
                return n.onAdd = u.onAdd,
                n.onRemove = u.onRemove,
                n.types = s.types,
                n.options = e,
                n
            };
            e.exports = function(t) {
                a(t, this)
            }
        }
        , {
            "../api": 62,
            "../constants": 63,
            "../options": 116,
            "../setup": 118,
            "./theme": 71
        }],
        // t => require
        // e => module
        // n => exports
        66: [function(t, e, n) {
            "use strict";
            var i = function() {
                function t(t, e) {
                    var n = []
                      , i = !0
                      , r = !1
                      , o = void 0;
                    try {
                        for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value),
                        !e || n.length !== e); i = !0)
                            ;
                    } catch (t) {
                        r = !0,
                        o = t
                    } finally {
                        try {
                            !i && a.return && a.return()
                        } finally {
                            if (r)
                                throw o
                        }
                    }
                    return n
                }
                return function(e, n) {
                    if (Array.isArray(e))
                        return e;
                    if (Symbol.iterator in Object(e))
                        return t(e, n);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                }
            }()
              , r = t("./draw")
              , o = t("./events")
              , s = t("./history/history")
              , a = t("../constants");
            e.exports = function(t) {
                t.map = null,
                t.options = {},
                t.controlPosition = void 0,
                t.events = null,
                t.draw = null,
                t.history = null,
                t.container = null;
                var e = function() {
                    return {
                        options: t.options || {},
                        controlPosition: t.controlPosition || void 0,
                        draw: t.draw || null
                    }
                };
                return {
                    init: function(n, i) {
                        var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
                        return t.draw = new r(i),
                        t.map = n,
                        t.map.addControl(t.draw, a),
                        t.options = i,
                        t.controlPosition = a,
                        t.container = n.getContainer(),
                        t.history && (t.history = null),
                        t.event && (t.event.removeEventListeners(),
                        t.event = null),
                        t.history = new s,
                        t.event = new o(t.draw,t.map,t.history,t.container),
                        t.event.addEventListeners(),
                        e()
                    },
                    setOptions: function(n) {
                        return t.draw && t.map && (t.map.removeControl(t.draw),
                        t.draw = null),
                        t.draw = new r(n),
                        t.map.addControl(t.draw, t.controlPosition),
                        t.options = n,
                        t.history && (t.history = null),
                        t.event && (t.event.removeEventListeners(),
                        t.event = null),
                        t.history = new s,
                        t.event = new o(t.draw,t.map,t.history,t.container),
                        t.event.addEventListeners(),
                        e()
                    },
                    dispose: function() {
                        return t.draw && t.map && (t.map.removeControl(t.draw),
                        t.draw = null),
                        t.history && (t.history = null),
                        t.event && (t.event.removeEventListeners(),
                        t.event = null),
                        delete t.map,
                        delete t.options,
                        delete t.controlPosition,
                        delete t.history,
                        delete t.event,
                        delete t.draw,
                        delete t.container,
                        e()
                    },
                    undoOperation: function() {
                        t.event && t.event.undoHistory()
                    },
                    redoOperation: function() {
                        t.event && t.event.redoHistory()
                    },
                    setFeatures: function(e) {
                        return t.draw.changeMode(a.modes.SIMPLE_SELECT),
                        t.draw.set(e)
                    },
                    removeFeatures: function(e) {
                        if (!Array.isArray(e))
                            throw new Error("Invalid featureIds");
                        if (0 == e.length)
                            throw new Error("featureIds不能为空");
                        return t.draw.changeMode(a.modes.SIMPLE_SELECT, {
                            featureIds: e
                        }),
                        t.draw.trash(),
                        e
                    },
                    setSelected: function(e) {
                        if (!Array.isArray(e))
                            throw new Error("Invalid featureIds");
                        return t.draw.changeMode(a.modes.SIMPLE_SELECT, {
                            featureIds: e
                        }),
                        e
                    },
                    setFeatureProperties: function(e) {
                        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                          , r = !0
                          , o = !1
                          , s = void 0;
                        try {
                            for (var a, u = Object.entries(n)[Symbol.iterator](); !(r = (a = u.next()).done); r = !0) {
                                var l = i(a.value, 2)
                                  , c = l[0]
                                  , h = l[1];
                                t.draw.setFeatureProperty(e, c, h)
                            }
                        } catch (t) {
                            o = !0,
                            s = t
                        } finally {
                            try {
                                !r && u.return && u.return()
                            } finally {
                                if (o)
                                    throw s
                            }
                        }
                        return t.draw.get(e)
                    },
                    getAllHistoryRecords: function() {
                        return t.history ? t.history.getAllRecords() : []
                    },
                    clearHistoryRecords: function() {
                        t.history && t.history.clear()
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "./draw": 65,
            "./events": 67,
            "./history/history": 68
        }],
        // t => require
        // e => module
        // n => exports
        67: [function(t, e, n) {
            "use strict";
            function i(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n,
                t
            }
            var r = t("../constants")
              , o = t("./history/record");
            // t=> draw , e=> map , n=> history , s=> container 
            e.exports = function(t, e, n, s) {
                var a, u, l = {
                    type: (a = {},
                    i(a, r.events.DELETE, 1),
                    i(a, r.events.UPDATE, 2),
                    i(a, r.events.CREATE, 3),
                    i(a, r.events.REPLACE, 4),
                    a),
                    action: (u = {},
                    i(u, r.updateActions.MOVE, 1),
                    i(u, r.updateActions.CHANGE_COORDINATES, 2),
                    i(u, r.updateActions.CHANGE_PROPERTIES, 3),
                    u)
                }, c = {};
                c.onDrawCreate = function(t) {
                    var i = new o(3,0,t.features);
                    n.addRecord(i),
                    e.fire(r.events.RECORD_CREATE, {
                        record: i
                    })
                }
                ,
                c.onDrawUpdate = function(t) {
                    var i = new o(2,l.action[t.action] || 0,t.features,t.prevFeatures);
                    n.addRecord(i),
                    e.fire(r.events.RECORD_CREATE, {
                        record: i
                    })
                }
                ,
                c.onDrawDelete = function(t) {
                    var i = new o(1,0,t.features);
                    n.addRecord(i),
                    e.fire(r.events.RECORD_CREATE, {
                        record: i
                    })
                }
                ,
                c.onDrawCombine = function(t) {
                    var i = new o(4,0,t.createdFeatures,t.deletedFeatures);
                    n.addRecord(i),
                    e.fire(r.events.RECORD_CREATE, {
                        record: i
                    })
                }
                ,
                c.onDrawUncombine = function(t) {
                    var i = new o(4,0,t.createdFeatures,t.deletedFeatures);
                    n.addRecord(i),
                    e.fire(r.events.RECORD_CREATE, {
                        record: i
                    })
                }
                ,
                c.onDrawReplace = function(t) {
                    var i = new o(4,0,t.createdFeatures,t.deletedFeatures);
                    n.addRecord(i),
                    e.fire(r.events.RECORD_CREATE, {
                        record: i
                    })
                }
                ,
                c.onKeydown = function(t) {
                    90 == t.keyCode ? (t.preventDefault(),
                    h.undoHistory()) : 89 == t.keyCode && (t.preventDefault(),
                    h.redoHistory())
                }
                ;
                 // t=> draw , e=> map , n=> history , s=> container 
                var h = {
                    addEventListeners: function() {
                        e && (e.on(r.events.CREATE, c.onDrawCreate),
                        e.on(r.events.UPDATE, c.onDrawUpdate),
                        e.on(r.events.DELETE, c.onDrawDelete),
                        e.on(r.events.COMBINE_FEATURES, c.onDrawCombine),
                        e.on(r.events.UNCOMBINE_FEATURES, c.onDrawUncombine),
                        e.on(r.events.REPLACE, c.onDrawReplace),
                        s.addEventListener("keydown", c.onKeydown))
                    },
                    removeEventListeners: function() {
                        e && (e.off(r.events.CREATE, c.onDrawCreate),
                        e.off(r.events.UPDATE, c.onDrawUpdate),
                        e.off(r.events.DELETE, c.onDrawDelete),
                        e.off(r.events.COMBINE_FEATURES, c.onDrawCombine),
                        e.off(r.events.UNCOMBINE_FEATURES, c.onDrawUncombine),
                        e.off(r.events.REPLACE, c.onDrawReplace),
                        s.removeEventListener("keydown", c.onKeydown))
                    },
                    undoHistory: function() {
                        if (t && n) {
                            var i = n.undoRecord();
                            if (i) {
                                if (1 == i.getType()) {
                                    var o = i.getFeatures();
                                    if (o.length > 0) {
                                        o.map(function(e) {
                                            t.add(Object.assign({}, e, {
                                                type: e.type || r.geojsonTypes.FEATURE
                                            }))
                                        });
                                        var s = o.map(function(t) {
                                            return t.id
                                        });
                                        t.changeMode(r.modes.SIMPLE_SELECT, {
                                            featureIds: s
                                        })
                                    }
                                } else if (2 == i.getType()) {
                                    var a = i.getFeatures();
                                    if (a.length > 0) {
                                        var u = a.map(function(t) {
                                            return t.id
                                        });
                                        t.delete(u)
                                    }
                                    var l = i.getPrevFeatures();
                                    if (l.length > 0) {
                                        l.map(function(e) {
                                            t.add(Object.assign({}, e, {
                                                type: e.type || r.geojsonTypes.FEATURE
                                            }))
                                        });
                                        var c = l.map(function(t) {
                                            return t.id
                                        });
                                        t.changeMode(r.modes.SIMPLE_SELECT, {
                                            featureIds: c
                                        })
                                    }
                                } else if (3 == i.getType()) {
                                    var h = i.getFeatures();
                                    if (h.length > 0) {
                                        var f = h.map(function(t) {
                                            return t.id
                                        });
                                        t.delete(f)
                                    }
                                } else if (4 == i.getType()) {
                                    var d = i.getFeatures();
                                    if (d.length > 0) {
                                        var g = d.map(function(t) {
                                            return t.id
                                        });
                                        t.delete(g)
                                    }
                                    var p = i.getPrevFeatures();
                                    if (p.length > 0) {
                                        p.map(function(e) {
                                            t.add(Object.assign({}, e, {
                                                type: e.type || r.geojsonTypes.FEATURE
                                            }))
                                        });
                                        var m = p.map(function(t) {
                                            return t.id
                                        });
                                        t.changeMode(r.modes.SIMPLE_SELECT, {
                                            featureIds: m
                                        })
                                    }
                                }
                                e.fire(r.events.UNDO, {
                                    record: i
                                })
                            }
                        }
                    },
                    redoHistory: function() {
                        if (t && n) {
                            var i = n.redoRecord();
                            if (i) {
                                t.getAll();
                                if (3 == i.getType()) {
                                    var o = i.getFeatures();
                                    if (o.length > 0) {
                                        o.map(function(e) {
                                            t.add(Object.assign({}, e, {
                                                type: e.type || r.geojsonTypes.FEATURE
                                            }))
                                        });
                                        var s = o.map(function(t) {
                                            return t.id
                                        });
                                        t.changeMode(r.modes.SIMPLE_SELECT, {
                                            featureIds: s
                                        })
                                    }
                                } else if (2 == i.getType()) {
                                    var a = i.getPrevFeatures();
                                    if (a.length > 0) {
                                        var u = a.map(function(t) {
                                            return t.id
                                        });
                                        t.delete(u)
                                    }
                                    var l = i.getFeatures();
                                    if (l.length > 0) {
                                        l.map(function(e) {
                                            t.add(Object.assign({}, e, {
                                                type: e.type || r.geojsonTypes.FEATURE
                                            }))
                                        });
                                        var c = l.map(function(t) {
                                            return t.id
                                        });
                                        t.changeMode(r.modes.SIMPLE_SELECT, {
                                            featureIds: c
                                        })
                                    }
                                } else if (1 == i.getType()) {
                                    var h = i.getFeatures();
                                    if (h.length > 0) {
                                        var f = h.map(function(t) {
                                            return t.id
                                        });
                                        t.delete(f)
                                    }
                                } else if (4 == i.getType()) {
                                    var d = i.getPrevFeatures();
                                    if (d.length > 0) {
                                        var g = d.map(function(t) {
                                            return t.id
                                        });
                                        t.delete(g)
                                    }
                                    var p = i.getFeatures();
                                    if (p.length > 0) {
                                        p.map(function(e) {
                                            t.add(Object.assign({}, e, {
                                                type: e.type || r.geojsonTypes.FEATURE
                                            }))
                                        });
                                        var m = p.map(function(t) {
                                            return t.id
                                        });
                                        t.changeMode(r.modes.SIMPLE_SELECT, {
                                            featureIds: m
                                        })
                                    }
                                }
                                e.fire(r.events.REDO, {
                                    record: i
                                })
                            }
                        }
                    }
                };
                return h
            }
        }
        , {
            "../constants": 63,
            "./history/record": 69
        }],
        68: [function(t, e, n) {
            "use strict";
            var i = function() {
                this.cursor = -1,
                this.recordes = []
            };
            i.prototype.addRecord = function(t) {
                if (t) {
                    this.cursor + 1 < this.recordes.length && (this.recordes = this.recordes.slice(0, this.cursor + 1)),
                    this.recordes.push(t);
                    var e = this.recordes.length;
                    this.cursor = e - 1
                }
                return this
            }
            ,
            i.prototype.undoRecord = function() {
                var t = this.recordes.length
                  , e = null;
                return 0 == t && (this.cursor = -1),
                t > 0 && this.cursor > -1 && (e = this.recordes[this.cursor],
                this.cursor = this.cursor - 1),
                e
            }
            ,
            i.prototype.redoRecord = function() {
                var t = this.recordes.length;
                0 == t && (this.cursor = -1);
                var e = null;
                return t > 0 && this.cursor < t - 1 && (e = this.recordes[this.cursor + 1],
                this.cursor = this.cursor + 1),
                e
            }
            ,
            i.prototype.getCurrentRecord = function() {
                var t = this.recordes.length;
                if (0 == t)
                    return null;
                var e = null;
                return this.cursor > -1 && this.cursor < t && (e = this.recordes[this.cursor]),
                e
            }
            ,
            i.prototype.getAllRecords = function() {
                return this.recordes
            }
            ,
            i.prototype.clear = function() {
                this.cursor = -1,
                this.recordes = []
            }
            ,
            e.exports = i
        }
        , {}],
        69: [function(t, e, n) {
            "use strict";
            var i = function(t, e, n, i) {
                this.type = t || 0,
                this.action = e || 0,
                this.features = n || [],
                this.prevFeatures = i || []
            };
            i.prototype.getType = function() {
                return this.type || 0
            }
            ,
            i.prototype.getAction = function() {
                return this.action || 0
            }
            ,
            i.prototype.getFeatures = function() {
                return this.features || []
            }
            ,
            i.prototype.getPrevFeatures = function() {
                return this.prevFeatures || []
            }
            ,
            e.exports = i
        }
        , {}],
        70: [function(t, e, n) {
            "use strict";
            var i = t("./btn_ctrl")
              , r = t("./edit_handler")
              , o = {}
              , s = {} //ctx
              , a = r(s);
            o.init = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
                return Object.assign(o, a.init(t, e, n))
            }
            ,
            o.setOptions = function(t) {
                return Object.assign(o, a.setOptions(t))
            }
            ,
            o.dispose = function() {
                return Object.assign(o, a.dispose())
            }
            ,
            o.undoOperation = function() {
                a.undoOperation()
            }
            ,
            o.redoOperation = function() {
                a.redoOperation()
            }
            ,
            o.onBtnCtrlActive = function(t) {
                i(o, t)
            }
            ,
            o.setFeatures = function(t) {
                return a.setFeatures(t)
            }
            ,
            o.removeFeatures = function(t) {
                return a.removeFeatures(t)
            }
            ,
            o.setSelected = function(t) {
                return a.setSelected(t)
            }
            ,
            o.setFeatureProperties = function(t, e) {
                return a.setFeatureProperties(t, e)
            }
            ,
            o.getAllHistoryRecords = function() {
                return a.getAllHistoryRecords()
            }
            ,
            o.clearHistoryRecords = function() {
                return a.clearHistoryRecords()
            }
            ,
            window.minemap && (minemap.edit = o),
            e.exports = o
        }
        , {
            "./btn_ctrl": 64,
            "./edit_handler": 66
        }],
        71: [function(t, e, n) {
            "use strict";
            e.exports = [{
                id: "gl-draw-polygon-fill-inactive",
                type: "fill",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
                paint: {
                    "fill-color": "#55B1F3",
                    "fill-outline-color": "#55B1F3",
                    "fill-opacity": .1
                }
            }, {
                id: "gl-draw-polygon-fill-active",
                type: "fill",
                filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]],
                paint: {
                    "fill-color": "#F05668",
                    "fill-outline-color": "#F05668",
                    "fill-opacity": .1
                }
            }, {
                id: "gl-draw-polygon-midpoint",
                type: "circle",
                filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]],
                paint: {
                    "circle-radius": 4,
                    "circle-color": "#F05668"
                }
            }, {
                id: "gl-draw-polygon-stroke-inactive",
                type: "line",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#55B1F3",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-polygon-stroke-active",
                type: "line",
                filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#F05668",
                    "line-dasharray": [.2, 2],
                    "line-width": 2
                }
            }, {
                id: "gl-draw-line-inactive",
                type: "line",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#55B1F3",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-line-active",
                type: "line",
                filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#F05668",
                    "line-dasharray": [.2, 2],
                    "line-width": 2
                }
            }, {
                id: "gl-draw-polygon-and-line-vertex-stroke-inactive",
                type: "circle",
                filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 6,
                    "circle-color": "#fff"
                }
            }, {
                id: "gl-draw-polygon-and-line-vertex-inactive",
                type: "circle",
                filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 4,
                    "circle-color": "#F05668"
                }
            }, {
                id: "gl-draw-point-point-stroke-inactive",
                type: "circle",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 6,
                    "circle-opacity": 1,
                    "circle-color": "#fff"
                }
            }, {
                id: "gl-draw-point-inactive",
                type: "circle",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 4,
                    "circle-color": "#55B1F3"
                }
            }, {
                id: "gl-draw-point-stroke-active",
                type: "circle",
                filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]],
                paint: {
                    "circle-radius": 8,
                    "circle-color": "#fff"
                }
            }, {
                id: "gl-draw-point-active",
                type: "circle",
                filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]],
                paint: {
                    "circle-radius": 6,
                    "circle-color": "#F05668"
                }
            }, {
                id: "gl-draw-polygon-fill-static",
                type: "fill",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]],
                paint: {
                    "fill-color": "#404040",
                    "fill-outline-color": "#404040",
                    "fill-opacity": .1
                }
            }, {
                id: "gl-draw-polygon-stroke-static",
                type: "line",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#404040",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-line-static",
                type: "line",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#404040",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-point-static",
                type: "circle",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]],
                paint: {
                    "circle-radius": 4,
                    "circle-color": "#404040"
                }
            }]
        }
        , {}],
        72: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                if (void 0 === t || null === t || isNaN(t))
                    throw new Error("num is required");
                if (e && !(e >= 0))
                    throw new Error("precision must be a positive number");
                var n = Math.pow(10, e || 0);
                return Math.round(t * n) / n
            }
            e.exports = function(t, e) {
                if (!t || !e)
                    return !1;
                if (2 != t.length || 2 != e.length)
                    return !1;
                var n = [i(t[0], 5), i(t[1], 5)]
                  , r = [i(e[0], 5), i(e[1], 5)];
                return n[0] == r[0] && n[1] == r[1]
            }
        }
        , {}],
        73: [function(t, e, n) {
            "use strict";
            function i(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n,
                t
            }
            var r, o = t("./lib/mode_handler"), s = t("./lib/get_features_and_set_cursor"), a = t("./lib/features_at"), u = t("./lib/is_click"), l = t("./lib/is_tap"), c = t("./constants"), h = (r = {},
            i(r, c.modes.SIMPLE_SELECT, t("./modes/simple_select")),
            i(r, c.modes.DIRECT_SELECT, t("./modes/direct_select")),
            i(r, c.modes.DRAW_POINT, t("./modes/draw_point")),
            i(r, c.modes.DRAW_LINE_STRING, t("./modes/draw_line_string")),
            i(r, c.modes.DRAW_POLYGON, t("./modes/draw_polygon")),
            i(r, c.modes.DRAW_RECTANGLE, t("./modes/draw_rectangle")),
            i(r, c.modes.DRAW_TRIANGLE, t("./modes/draw_triangle")),
            i(r, c.modes.DRAW_SECTOR, t("./modes/draw_sector")),
            i(r, c.modes.DRAW_CIRCLE, t("./modes/draw_circle")),
            i(r, c.modes.SPLIT_POLYGON, t("./modes/split_polygon")),
            i(r, c.modes.STATIC, t("./modes/static")),
            r);
            e.exports = function(t) {
                function e(e, n) {
                    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    g.stop();
                    var r = h[e];
                    if (void 0 === r)
                        throw new Error(e + " is not valid");
                    d = e;
                    var s = r(t, n);
                    g = o(s, t),
                    i.silent || t.map.fire(c.events.MODE_CHANGE, {
                        mode: e
                    }),
                    t.store.setDirty(),
                    t.store.render()
                }
                function n(e) {
                    var n = !1;
                    Object.keys(e).forEach(function(t) {
                        if (void 0 === m[t])
                            throw new Error("Invalid action type");
                        m[t] !== e[t] && (n = !0),
                        m[t] = e[t]
                    }),
                    n && t.map.fire(c.events.ACTIONABLE, {
                        actions: m
                    })
                }
                var i = {}
                  , r = {}
                  , f = {}
                  , d = c.modes.SIMPLE_SELECT
                  , g = o(h.simple_select(t), t);
                f.drag = function(e, n) {
                    n({
                        point: e.point,
                        time: (new Date).getTime()
                    }) ? (t.ui.queueMapClasses({
                        mouse: c.cursors.DRAG
                    }),
                    g.drag(e)) : e.originalEvent.stopPropagation()
                }
                ,
                f.mousedrag = function(t) {
                    f.drag(t, function(t) {
                        return !u(i, t)
                    })
                }
                ,
                f.touchdrag = function(t) {
                    f.drag(t, function(t) {
                        return !l(r, t)
                    })
                }
                ,
                f.mousemove = function(e) {
                    if (1 === (void 0 !== e.originalEvent.buttons ? e.originalEvent.buttons : e.originalEvent.which))
                        return f.mousedrag(e);
                    var n = s(e, t);
                    e.featureTarget = n,
                    g.mousemove(e)
                }
                ,
                f.mousedown = function(e) {
                    i = {
                        time: (new Date).getTime(),
                        point: e.point
                    };
                    var n = s(e, t);
                    e.featureTarget = n,
                    g.mousedown(e)
                }
                ,
                f.mouseup = function(e) {
                    var n = s(e, t);
                    e.featureTarget = n,
                    u(i, {
                        point: e.point,
                        time: (new Date).getTime()
                    }) ? g.click(e) : g.mouseup(e)
                }
                ,
                f.mouseout = function(t) {
                    g.mouseout(t)
                }
                ,
                f.touchstart = function(e) {
                    if (e.originalEvent.preventDefault(),
                    t.options.touchEnabled) {
                        r = {
                            time: (new Date).getTime(),
                            point: e.point
                        };
                        var n = a.touch(e, null, t)[0];
                        e.featureTarget = n,
                        g.touchstart(e)
                    }
                }
                ,
                f.touchmove = function(e) {
                    if (e.originalEvent.preventDefault(),
                    t.options.touchEnabled)
                        return g.touchmove(e),
                        f.touchdrag(e)
                }
                ,
                f.touchend = function(e) {
                    if (e.originalEvent.preventDefault(),
                    t.options.touchEnabled) {
                        var n = a.touch(e, null, t)[0];
                        e.featureTarget = n,
                        l(r, {
                            time: (new Date).getTime(),
                            point: e.point
                        }) ? g.tap(e) : g.touchend(e)
                    }
                }
                ;
                var p = function(t) {
                    return !(46 === t || t >= 48 && t <= 57)
                };
                f.keydown = function(n) {
                    46 === n.keyCode && t.options.controls.trash ? (n.preventDefault(),
                    g.trash()) : p(n.keyCode) ? g.keydown(n) : 49 === n.keyCode && t.options.controls.point ? e(c.modes.DRAW_POINT) : 50 === n.keyCode && t.options.controls.line_string ? e(c.modes.DRAW_LINE_STRING) : 51 === n.keyCode && t.options.controls.polygon ? e(c.modes.DRAW_POLYGON) : 52 === n.keyCode && t.options.controls.circle && e(c.modes.DRAW_POLYGON)
                }
                ,
                f.keyup = function(t) {
                    p(t.keyCode) && g.keyup(t)
                }
                ,
                f.zoomend = function() {
                    t.store.changeZoom()
                }
                ,
                f.data = function(e) {
                    if ("style" === e.dataType) {
                        var n = t.setup
                          , i = t.map
                          , r = t.options
                          , o = t.store;
                        r.styles.some(function(t) {
                            return i.getLayer(t.id)
                        }) || (n.addLayers(),
                        o.setDirty(),
                        o.render())
                    }
                }
                ;
                var m = {
                    trash: !1,
                    combineFeatures: !1,
                    uncombineFeatures: !1
                };
                return {
                    changeMode: e,
                    actionable: n,
                    currentModeName: function() {
                        return d
                    },
                    currentModeRender: function(t, e) {
                        return g.render(t, e)
                    },
                    fire: function(t, e) {
                        f[t] && f[t](e)
                    },
                    addEventListeners: function() {
                        t.map.on("mousemove", f.mousemove),
                        t.map.on("mousedown", f.mousedown),
                        t.map.on("mouseup", f.mouseup),
                        t.map.on("data", f.data),
                        t.map.on("touchmove", f.touchmove),
                        t.map.on("touchstart", f.touchstart),
                        t.map.on("touchend", f.touchend),
                        t.container.addEventListener("mouseout", f.mouseout),
                        t.options.keybindings && (t.container.addEventListener("keydown", f.keydown),
                        t.container.addEventListener("keyup", f.keyup))
                    },
                    removeEventListeners: function() {
                        t.map.off("mousemove", f.mousemove),
                        t.map.off("mousedown", f.mousedown),
                        t.map.off("mouseup", f.mouseup),
                        t.map.off("data", f.data),
                        t.map.off("touchmove", f.touchmove),
                        t.map.off("touchstart", f.touchstart),
                        t.map.off("touchend", f.touchend),
                        t.container.removeEventListener("mouseout", f.mouseout),
                        t.options.keybindings && (t.container.removeEventListener("keydown", f.keydown),
                        t.container.removeEventListener("keyup", f.keyup))
                    },
                    trash: function(t) {
                        g.trash(t)
                    },
                    combineFeatures: function() {
                        g.combineFeatures()
                    },
                    uncombineFeatures: function() {
                        g.uncombineFeatures()
                    },
                    unionPolygon: function() {
                        g.unionPolygon()
                    },
                    unionLine: function() {
                        g.unionLine()
                    },
                    splitLine: function() {
                        g.splitLine()
                    },
                    curveLine: function() {
                        g.curveLine()
                    },
                    getMode: function() {
                        return d
                    }
                }
            }
        }
        , {
            "./constants": 63,
            "./lib/features_at": 90,
            "./lib/get_features_and_set_cursor": 91,
            "./lib/is_click": 92,
            "./lib/is_tap": 94,
            "./lib/mode_handler": 96,
            "./modes/direct_select": 105,
            "./modes/draw_circle": 106,
            "./modes/draw_line_string": 107,
            "./modes/draw_point": 108,
            "./modes/draw_polygon": 109,
            "./modes/draw_rectangle": 110,
            "./modes/draw_sector": 111,
            "./modes/draw_triangle": 112,
            "./modes/simple_select": 113,
            "./modes/split_polygon": 114,
            "./modes/static": 115
        }],
        74: [function(t, e, n) {
            "use strict";
            function i(t, e, n) {
                n || (n = 64);
                for (var i, r, o, s = {
                    latitude: t[1],
                    longitude: t[0]
                }, a = e, u = [], l = a / (111.32 * Math.cos(s.latitude * Math.PI / 180)), c = a / 110.574, h = 0; h < n; h++)
                    i = h / n * (2 * Math.PI),
                    r = l * Math.cos(i),
                    o = c * Math.sin(i),
                    u.push([s.longitude + r, s.latitude + o]);
                return u.push(u[0]),
                [u]
            }
            function r(t, e) {
                var n = u[e || "kilometers"];
                if (void 0 === n)
                    throw new Error("Invalid unit");
                return t * n
            }
            function o(t, e, n) {
                var i = Math.PI / 180
                  , o = t
                  , s = e
                  , a = i * (s[1] - o[1])
                  , u = i * (s[0] - o[0])
                  , l = i * o[1]
                  , c = i * s[1]
                  , h = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(u / 2), 2) * Math.cos(l) * Math.cos(c);
                return r(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), "kilometers")
            }
            var s = t("./feature")
              , a = function(t, e) {
                s.call(this, t, e),
                this.coordinates = this.coordinates.map(function(t) {
                    return t.slice(0, -1)
                })
            };
            a.prototype = Object.create(s.prototype),
            a.prototype.isValid = function() {
                return 0 !== this.coordinates.length && this.coordinates.every(function(t) {
                    return t.length > 2
                })
            }
            ,
            a.prototype.incomingCoords = function(t) {
                this.coordinates = t.map(function(t) {
                    return t.slice(0, -1)
                }),
                this.changed()
            }
            ,
            a.prototype.setCoordinates = function(t) {
                this.coordinates = t,
                this.changed()
            }
            ,
            a.prototype.addCoordinate = function(t, e, n) {
                this.changed();
                var i = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                });
                this.coordinates[i[0]].splice(i[1], 0, [e, n])
            }
            ,
            a.prototype.removeCoordinate = function(t) {
                this.changed();
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                n && (n.splice(e[1], 1),
                n.length < 3 && this.coordinates.splice(e[0], 1))
            }
            ,
            a.prototype.getCoordinate = function(t) {
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                return JSON.parse(JSON.stringify(n[e[1]]))
            }
            ,
            a.prototype.getCoordinates = function() {
                return this.coordinates.map(function(t) {
                    return t.concat([t[0]])
                })
            }
            ,
            a.prototype.updateCoordinate = function(t, e, n) {
                this.changed();
                var r = t.split(".")
                  , s = parseInt(r[0], 10)
                  , a = parseInt(r[1], 10);
                0 == a && (this.center = [e, n],
                this.coordinates[s][a] = [e, n],
                this.properties.center = [e, n],
                this.properties.radius = 100,
                this.properties.id = this.id),
                1 == a && (this.properties.radius = o(this.center, [e, n]),
                this.coordinates = i(this.center, o(this.center, [e, n]))),
                void 0 === this.coordinates[s] && (this.coordinates[s] = [])
            }
            ,
            e.exports = a;
            var u = {
                miles: 3960,
                nauticalmiles: 3441.145,
                degrees: 57.2957795,
                radians: 1,
                inches: 250905600,
                yards: 6969600,
                meters: 6373e3,
                metres: 6373e3,
                kilometers: 6373,
                kilometres: 6373
            }
        }
        , {
            "./feature": 75
        }],
        75: [function(t, e, n) {
            "use strict";
            var i = t("hat")
              , r = t("../constants")
              , o = function(t, e) {
                this.ctx = t,
                this.properties = e.properties || {},
                this.coordinates = e.geometry.coordinates,
                this.id = e.id || i(),
                this.type = e.geometry.type
            };
            o.prototype.changed = function() {
                this.ctx.store.featureChanged(this.id)
            }
            ,
            o.prototype.incomingCoords = function(t) {
                this.setCoordinates(t)
            }
            ,
            o.prototype.setCoordinates = function(t) {
                this.coordinates = t,
                this.changed()
            }
            ,
            o.prototype.getCoordinates = function() {
                return JSON.parse(JSON.stringify(this.coordinates))
            }
            ,
            o.prototype.setProperty = function(t, e) {
                this.properties[t] = e
            }
            ,
            o.prototype.toGeoJSON = function() {
                return JSON.parse(JSON.stringify({
                    id: this.id,
                    type: r.geojsonTypes.FEATURE,
                    properties: this.properties,
                    geometry: {
                        coordinates: this.getCoordinates(),
                        type: this.type
                    }
                }))
            }
            ,
            o.prototype.internal = function(t) {
                var e = {
                    id: this.id,
                    meta: r.meta.FEATURE,
                    "meta:type": this.type,
                    active: r.activeStates.INACTIVE,
                    mode: t
                };
                if (this.ctx.options.userProperties)
                    for (var n in this.properties)
                        e["user_" + n] = this.properties[n];
                return {
                    type: r.geojsonTypes.FEATURE,
                    properties: e,
                    geometry: {
                        coordinates: this.getCoordinates(),
                        type: this.type
                    }
                }
            }
            ,
            e.exports = o
        }
        , {
            "../constants": 63,
            hat: 51
        }],
        76: [function(t, e, n) {
            "use strict";
            var i = t("./feature")
              , r = function(t, e) {
                i.call(this, t, e)
            };
            r.prototype = Object.create(i.prototype),
            r.prototype.isValid = function() {
                return this.coordinates.length > 1
            }
            ,
            r.prototype.addCoordinate = function(t, e, n) {
                this.changed();
                var i = parseInt(t, 10);
                this.coordinates.splice(i, 0, [e, n])
            }
            ,
            r.prototype.getCoordinate = function(t) {
                var e = parseInt(t, 10);
                return JSON.parse(JSON.stringify(this.coordinates[e]))
            }
            ,
            r.prototype.removeCoordinate = function(t) {
                this.changed(),
                this.coordinates.splice(parseInt(t, 10), 1)
            }
            ,
            r.prototype.updateCoordinate = function(t, e, n) {
                var i = parseInt(t, 10);
                this.coordinates[i] = [e, n],
                this.changed()
            }
            ,
            e.exports = r
        }
        , {
            "./feature": 75
        }],
        77: [function(t, e, n) {
            "use strict";
            var i = t("./feature")
              , r = t("../constants")
              , o = t("hat")
              , s = {
                MultiPoint: t("./point"),
                MultiLineString: t("./line_string"),
                MultiPolygon: t("./polygon")
            }
              , a = function(t, e, n, i, r) {
                var o = n.split(".")
                  , s = parseInt(o[0], 10)
                  , a = o[1] ? o.slice(1).join(".") : null;
                return t[s][e](a, i, r)
            }
              , u = function(t, e) {
                if (i.call(this, t, e),
                delete this.coordinates,
                this.model = s[e.geometry.type],
                void 0 === this.model)
                    throw new TypeError(e.geometry.type + " is not a valid type");
                this.features = this._coordinatesToFeatures(e.geometry.coordinates)
            };
            u.prototype = Object.create(i.prototype),
            u.prototype._coordinatesToFeatures = function(t) {
                var e = this
                  , n = this.model.bind(this);
                return t.map(function(t) {
                    return new n(e.ctx,{
                        id: o(),
                        type: r.geojsonTypes.FEATURE,
                        properties: {},
                        geometry: {
                            coordinates: t,
                            type: e.type.replace("Multi", "")
                        }
                    })
                })
            }
            ,
            u.prototype.isValid = function() {
                return this.features.every(function(t) {
                    return t.isValid()
                })
            }
            ,
            u.prototype.setCoordinates = function(t) {
                this.features = this._coordinatesToFeatures(t),
                this.changed()
            }
            ,
            u.prototype.getCoordinate = function(t) {
                return a(this.features, "getCoordinate", t)
            }
            ,
            u.prototype.getCoordinates = function() {
                return JSON.parse(JSON.stringify(this.features.map(function(t) {
                    return t.type === r.geojsonTypes.POLYGON ? t.getCoordinates() : t.coordinates
                })))
            }
            ,
            u.prototype.updateCoordinate = function(t, e, n) {
                a(this.features, "updateCoordinate", t, e, n),
                this.changed()
            }
            ,
            u.prototype.addCoordinate = function(t, e, n) {
                a(this.features, "addCoordinate", t, e, n),
                this.changed()
            }
            ,
            u.prototype.removeCoordinate = function(t) {
                a(this.features, "removeCoordinate", t),
                this.changed()
            }
            ,
            u.prototype.getFeatures = function() {
                return this.features
            }
            ,
            e.exports = u
        }
        , {
            "../constants": 63,
            "./feature": 75,
            "./line_string": 76,
            "./point": 78,
            "./polygon": 79,
            hat: 51
        }],
        78: [function(t, e, n) {
            "use strict";
            var i = t("./feature")
              , r = function(t, e) {
                i.call(this, t, e)
            };
            r.prototype = Object.create(i.prototype),
            r.prototype.isValid = function() {
                return "number" == typeof this.coordinates[0] && "number" == typeof this.coordinates[1]
            }
            ,
            r.prototype.updateCoordinate = function(t, e, n) {
                3 === arguments.length ? this.coordinates = [e, n] : this.coordinates = [t, e],
                this.changed()
            }
            ,
            r.prototype.getCoordinate = function() {
                return this.getCoordinates()
            }
            ,
            e.exports = r
        }
        , {
            "./feature": 75
        }],
        79: [function(t, e, n) {
            "use strict";
            var i = t("./feature")
              , r = function(t, e) {
                i.call(this, t, e),
                this.coordinates = this.coordinates.map(function(t) {
                    return t.slice(0, -1)
                })
            };
            r.prototype = Object.create(i.prototype),
            r.prototype.isValid = function() {
                return 0 !== this.coordinates.length && this.coordinates.every(function(t) {
                    return t.length > 2
                })
            }
            ,
            r.prototype.incomingCoords = function(t) {
                this.coordinates = t.map(function(t) {
                    return t.slice(0, -1)
                }),
                this.changed()
            }
            ,
            r.prototype.setCoordinates = function(t) {
                this.coordinates = t,
                this.changed()
            }
            ,
            r.prototype.addCoordinate = function(t, e, n) {
                this.changed();
                var i = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                });
                this.coordinates[i[0]].splice(i[1], 0, [e, n])
            }
            ,
            r.prototype.removeCoordinate = function(t) {
                this.changed();
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                n && (n.splice(e[1], 1),
                n.length < 3 && this.coordinates.splice(e[0], 1))
            }
            ,
            r.prototype.getCoordinate = function(t) {
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                return JSON.parse(JSON.stringify(n[e[1]]))
            }
            ,
            r.prototype.getCoordinates = function() {
                return this.coordinates.map(function(t) {
                    return t.concat([t[0]])
                })
            }
            ,
            r.prototype.updateCoordinate = function(t, e, n) {
                this.changed();
                var i = t.split(".")
                  , r = parseInt(i[0], 10)
                  , o = parseInt(i[1], 10);
                void 0 === this.coordinates[r] && (this.coordinates[r] = []),
                this.coordinates[r][o] = [e, n]
            }
            ,
            e.exports = r
        }
        , {
            "./feature": 75
        }],
        80: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                var n = t[0]
                  , i = t[1]
                  , r = e[0]
                  , o = e[1];
                if (n > r) {
                    var s = n;
                    n = r,
                    r = s
                }
                if (i > o) {
                    var a = i;
                    i = o,
                    o = a
                }
                var u = [n, i, r, o]
                  , l = [u[0], u[1]]
                  , c = [u[0], u[3]]
                  , h = [u[2], u[3]]
                  , f = [u[2], u[1]]
                  , d = [l, f, h, c]
                  , g = 0;
                d.map(function(e, n) {
                    t[0] === e[0] && t[1] === e[1] && (g = n)
                });
                for (var p = [], m = g; m < d.length; m++)
                    p.push(d[m]);
                for (var y = 0; y < g; y++)
                    p.push(d[y]);
                return [p]
            }
            var r = t("./feature")
              , o = function(t, e) {
                r.call(this, t, e),
                this.coordinates = this.coordinates.map(function(t) {
                    return t.slice(0, -1)
                })
            };
            o.prototype = Object.create(r.prototype),
            o.prototype.isValid = function() {
                return 0 !== this.coordinates.length && this.coordinates.every(function(t) {
                    return t.length > 2
                })
            }
            ,
            o.prototype.incomingCoords = function(t) {
                this.coordinates = t.map(function(t) {
                    return t.slice(0, -1)
                }),
                this.changed()
            }
            ,
            o.prototype.setCoordinates = function(t) {
                this.coordinates = t,
                this.changed()
            }
            ,
            o.prototype.addCoordinate = function(t, e, n) {
                this.changed();
                var i = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                });
                this.coordinates[i[0]].splice(i[1], 0, [e, n])
            }
            ,
            o.prototype.removeCoordinate = function(t) {
                this.changed();
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                n && (n.splice(e[1], 1),
                n.length < 3 && this.coordinates.splice(e[0], 1))
            }
            ,
            o.prototype.getCoordinate = function(t) {
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                return JSON.parse(JSON.stringify(n[e[1]]))
            }
            ,
            o.prototype.getCoordinates = function() {
                return this.coordinates.map(function(t) {
                    return t.concat([t[0]])
                })
            }
            ,
            o.prototype.updateCoordinate = function(t, e, n) {
                this.changed();
                var r = t.split(".")
                  , o = parseInt(r[0], 10)
                  , s = parseInt(r[1], 10);
                0 == s ? (this.start = [e, n],
                this.coordinates[o][s] = [e, n]) : 1 == s && (this.coordinates = i(this.start, [e, n])),
                void 0 === this.coordinates[o] && (this.coordinates[o] = [])
            }
            ,
            e.exports = o
        }
        , {
            "./feature": 75
        }],
        81: [function(t, e, n) {
            "use strict";
            function i(t, e, n) {
                var i = r(t, e)
                  , a = r(t, n)
                  , u = s(t, e);
                return [o(t, u, i, a).geometry.coordinates[0].slice(0, -1)]
            }
            var r = t("@turf/bearing")
              , o = t("@turf/sector")
              , s = t("@turf/distance")
              , a = t("./feature")
              , u = function(t, e) {
                a.call(this, t, e),
                this.coordinates = this.coordinates.map(function(t) {
                    return t.slice(0, -1)
                })
            };
            u.prototype = Object.create(a.prototype),
            u.prototype.isValid = function() {
                return 0 !== this.coordinates.length && this.coordinates.every(function(t) {
                    return t.length > 2
                })
            }
            ,
            u.prototype.incomingCoords = function(t) {
                this.coordinates = t.map(function(t) {
                    return t.slice(0, -1)
                }),
                this.changed()
            }
            ,
            u.prototype.setCoordinates = function(t) {
                this.coordinates = t,
                this.changed()
            }
            ,
            u.prototype.addCoordinate = function(t, e, n) {
                this.changed();
                var i = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                });
                this.coordinates[i[0]].splice(i[1], 0, [e, n])
            }
            ,
            u.prototype.removeCoordinate = function(t) {
                this.changed();
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                n && (n.splice(e[1], 1),
                n.length < 3 && this.coordinates.splice(e[0], 1))
            }
            ,
            u.prototype.getCoordinate = function(t) {
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                return JSON.parse(JSON.stringify(n[e[1]]))
            }
            ,
            u.prototype.getCoordinates = function() {
                return this.coordinates.map(function(t) {
                    return t.concat([t[0]])
                })
            }
            ,
            u.prototype.updateCoordinate = function(t, e, n) {
                this.changed();
                var r = t.split(".")
                  , o = parseInt(r[0], 10)
                  , s = parseInt(r[1], 10);
                0 == s ? (this.center = [e, n],
                this.coordinates[o][s] = [e, n]) : 1 == s ? (this.start = [e, n],
                this.coordinates[o][s] = [e, n]) : 2 == s && (this.coordinates = i(this.center, this.start, [e, n])),
                void 0 === this.coordinates[o] && (this.coordinates[o] = [])
            }
            ,
            e.exports = u
        }
        , {
            "./feature": 75,
            "@turf/bearing": 9,
            "@turf/distance": 17,
            "@turf/sector": 35
        }],
        82: [function(t, e, n) {
            "use strict";
            var i = t("./feature")
              , r = function(t, e) {
                i.call(this, t, e),
                this.coordinates = this.coordinates.map(function(t) {
                    return t.slice(0, -1)
                })
            };
            r.prototype = Object.create(i.prototype),
            r.prototype.isValid = function() {
                return 0 !== this.coordinates.length && this.coordinates.every(function(t) {
                    return t.length > 2
                })
            }
            ,
            r.prototype.incomingCoords = function(t) {
                this.coordinates = t.map(function(t) {
                    return t.slice(0, -1)
                }),
                this.changed()
            }
            ,
            r.prototype.setCoordinates = function(t) {
                this.coordinates = t,
                this.changed()
            }
            ,
            r.prototype.addCoordinate = function(t, e, n) {
                this.changed();
                var i = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                });
                this.coordinates[i[0]].splice(i[1], 0, [e, n])
            }
            ,
            r.prototype.removeCoordinate = function(t) {
                this.changed();
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                n && (n.splice(e[1], 1),
                n.length < 3 && this.coordinates.splice(e[0], 1))
            }
            ,
            r.prototype.getCoordinate = function(t) {
                var e = t.split(".").map(function(t) {
                    return parseInt(t, 10)
                })
                  , n = this.coordinates[e[0]];
                return JSON.parse(JSON.stringify(n[e[1]]))
            }
            ,
            r.prototype.getCoordinates = function() {
                return this.coordinates.map(function(t) {
                    return t.concat([t[0]])
                })
            }
            ,
            r.prototype.updateCoordinate = function(t, e, n) {
                this.changed();
                var i = t.split(".")
                  , r = parseInt(i[0], 10)
                  , o = parseInt(i[1], 10);
                0 == o ? (this.start = [e, n],
                this.coordinates[r][o] = [e, n]) : 1 == o ? (this.middle = [e, n],
                this.coordinates[r][o] = [e, n]) : 2 == o && (this.end = [e, n],
                this.coordinates[r][o] = [e, n]),
                void 0 === this.coordinates[r] && (this.coordinates[r] = [])
            }
            ,
            e.exports = r
        }
        , {
            "./feature": 75
        }],
        83: [function(t, e, n) {
            "use strict";
            var i = t("../constants");
            e.exports = {
                isOfMetaType: function(t) {
                    return function(e) {
                        var n = e.featureTarget;
                        return !!n && (!!n.properties && n.properties.meta === t)
                    }
                },
                isShiftMousedown: function(t) {
                    return !!t.originalEvent && (!!t.originalEvent.shiftKey && 0 === t.originalEvent.button)
                },
                isActiveFeature: function(t) {
                    return !!t.featureTarget && (!!t.featureTarget.properties && (t.featureTarget.properties.active === i.activeStates.ACTIVE && t.featureTarget.properties.meta === i.meta.FEATURE))
                },
                isInactiveFeature: function(t) {
                    return !!t.featureTarget && (!!t.featureTarget.properties && (t.featureTarget.properties.active === i.activeStates.INACTIVE && t.featureTarget.properties.meta === i.meta.FEATURE))
                },
                noTarget: function(t) {
                    return void 0 === t.featureTarget
                },
                isFeature: function(t) {
                    return !!t.featureTarget && (!!t.featureTarget.properties && t.featureTarget.properties.meta === i.meta.FEATURE)
                },
                isVertex: function(t) {
                    var e = t.featureTarget;
                    return !!e && (!!e.properties && e.properties.meta === i.meta.VERTEX)
                },
                isShiftDown: function(t) {
                    return !!t.originalEvent && !0 === t.originalEvent.shiftKey
                },
                isEscapeKey: function(t) {
                    return 27 === t.keyCode
                },
                isEnterKey: function(t) {
                    return 13 === t.keyCode
                },
                true: function() {
                    return !0
                }
            }
        }
        , {
            "../constants": 63
        }],
        84: [function(t, e, n) {
            "use strict";
            var i = t("geojson-extent")
              , r = t("../constants")
              , o = r.LAT_MIN
              , s = r.LAT_MAX
              , a = r.LAT_RENDERED_MIN
              , u = r.LAT_RENDERED_MAX
              , l = r.LNG_MIN
              , c = r.LNG_MAX;
            e.exports = function(t, e) {
                var n = o
                  , r = s
                  , h = o
                  , f = s
                  , d = c
                  , g = l;
                t.forEach(function(t) {
                    var e = i(t)
                      , o = e[1]
                      , s = e[3]
                      , a = e[0]
                      , u = e[2];
                    o > n && (n = o),
                    s < r && (r = s),
                    s > h && (h = s),
                    o < f && (f = o),
                    a < d && (d = a),
                    u > g && (g = u)
                });
                var p = e;
                return n + p.lat > u && (p.lat = u - n),
                h + p.lat > s && (p.lat = s - h),
                r + p.lat < a && (p.lat = a - r),
                f + p.lat < o && (p.lat = o - f),
                d + p.lng <= l && (p.lng += 360 * Math.ceil(Math.abs(p.lng) / 360)),
                g + p.lng >= c && (p.lng -= 360 * Math.ceil(Math.abs(p.lng) / 360)),
                p
            }
        }
        , {
            "../constants": 63,
            "geojson-extent": 45
        }],
        85: [function(t, e, n) {
            "use strict";
            var i = t("../constants");
            e.exports = function(t, e, n, r) {
                var o = e.geometry.coordinates
                  , s = n.geometry.coordinates;
                if (o[1] > i.LAT_RENDERED_MAX || o[1] < i.LAT_RENDERED_MIN || s[1] > i.LAT_RENDERED_MAX || s[1] < i.LAT_RENDERED_MIN)
                    return null;
                var a = r.project([o[0], o[1]])
                  , u = r.project([s[0], s[1]])
                  , l = r.unproject([(a.x + u.x) / 2, (a.y + u.y) / 2]);
                return {
                    type: i.geojsonTypes.FEATURE,
                    properties: {
                        meta: i.meta.MIDPOINT,
                        parent: t,
                        lng: l.lng,
                        lat: l.lat,
                        coord_path: n.properties.coord_path
                    },
                    geometry: {
                        type: i.geojsonTypes.POINT,
                        coordinates: [l.lng, l.lat]
                    }
                }
            }
        }
        , {
            "../constants": 63
        }],
        86: [function(t, e, n) {
            "use strict";
            function i(t) {
                function e(t, e) {
                    var i = ""
                      , s = null;
                    t.forEach(function(t, u) {
                        var l = void 0 !== e && null !== e ? e + "." + u : String(u)
                          , c = r(f, t, l, n(l));
                        if (a.midpoints && s) {
                            var h = o(f, s, c, a.map);
                            h && d.push(h)
                        }
                        s = c;
                        var g = JSON.stringify(t);
                        i !== g && d.push(c),
                        0 === u && (i = g)
                    })
                }
                function n(t) {
                    return !!a.selectedPaths && -1 !== a.selectedPaths.indexOf(t)
                }
                var a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , u = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , l = t.geometry
                  , c = l.type
                  , h = l.coordinates
                  , f = t.properties && t.properties.id
                  , d = [];
                return c === s.geojsonTypes.POINT ? d.push(r(f, h, u, n(u))) : c === s.geojsonTypes.POLYGON ? h.forEach(function(t, n) {
                    e(t, null !== u ? u + "." + n : String(n))
                }) : c === s.geojsonTypes.LINE_STRING ? e(h, u) : 0 === c.indexOf(s.geojsonTypes.MULTI_PREFIX) && function() {
                    var e = c.replace(s.geojsonTypes.MULTI_PREFIX, "");
                    h.forEach(function(n, r) {
                        var o = {
                            type: s.geojsonTypes.FEATURE,
                            properties: t.properties,
                            geometry: {
                                type: e,
                                coordinates: n
                            }
                        };
                        d = d.concat(i(o, a, r))
                    })
                }(),
                d
            }
            var r = t("./create_vertex")
              , o = t("./create_midpoint")
              , s = t("../constants");
            e.exports = i
        }
        , {
            "../constants": 63,
            "./create_midpoint": 85,
            "./create_vertex": 87
        }],
        87: [function(t, e, n) {
            "use strict";
            var i = t("../constants");
            e.exports = function(t, e, n, r) {
                return {
                    type: i.geojsonTypes.FEATURE,
                    properties: {
                        meta: i.meta.VERTEX,
                        parent: t,
                        coord_path: n,
                        active: r ? i.activeStates.ACTIVE : i.activeStates.INACTIVE
                    },
                    geometry: {
                        type: i.geojsonTypes.POINT,
                        coordinates: e
                    }
                }
            }
        }
        , {
            "../constants": 63
        }],
        88: [function(t, e, n) {
            "use strict";
            e.exports = {
                enable: function(t) {
                    setTimeout(function() {
                        t.map && t.map.doubleClickZoom && t.map.doubleClickZoom.enable()
                    }, 0)
                },
                disable: function(t) {
                    setTimeout(function() {
                        t.map && t.map.doubleClickZoom && t.map.doubleClickZoom.disable()
                    }, 0)
                }
            }
        }
        , {}],
        89: [function(t, e, n) {
            "use strict";
            e.exports = function(t, e) {
                var n = t.x - e.x
                  , i = t.y - e.y;
                return Math.sqrt(n * n + i * i)
            }
        }
        , {}],
        90: [function(t, e, n) {
            "use strict";
            function i(t, e, n) {
                return o(t, e, n, n.options.clickBuffer)
            }
            function r(t, e, n) {
                return o(t, e, n, n.options.touchBuffer)
            }
            function o(t, e, n, i) {
                if (null === n.map)
                    return [];
                var r = t ? a(t, i) : e
                  , o = {};
                n.options.styles && (o.layers = n.options.styles.map(function(t) {
                    return t.id
                }));
                var u = n.map.queryRenderedFeatures(r, o).filter(function(t) {
                    return -1 !== c.indexOf(t.properties.meta)
                })
                  , h = new l
                  , f = [];
                return u.forEach(function(t) {
                    var e = t.properties.id;
                    h.has(e) || (h.add(e),
                    f.push(t))
                }),
                s(f)
            }
            var s = t("./sort_features")
              , a = t("./map_event_to_bounding_box")
              , u = t("../constants")
              , l = t("./string_set")
              , c = [u.meta.FEATURE, u.meta.MIDPOINT, u.meta.VERTEX];
            e.exports = {
                click: i,
                touch: r
            }
        }
        , {
            "../constants": 63,
            "./map_event_to_bounding_box": 95,
            "./sort_features": 99,
            "./string_set": 100
        }],
        91: [function(t, e, n) {
            "use strict";
            var i = t("./features_at")
              , r = t("../constants");
            e.exports = function(t, e) {
                var n = i.click(t, null, e)
                  , o = {
                    mouse: r.cursors.NONE
                };
                return n[0] && (o.mouse = n[0].properties.active === r.activeStates.ACTIVE ? r.cursors.MOVE : r.cursors.POINTER,
                o.feature = n[0].properties.meta),
                -1 !== e.events.currentModeName().indexOf("draw") && (o.mouse = r.cursors.ADD),
                e.ui.queueMapClasses(o),
                e.ui.updateMapClasses(),
                n[0]
            }
        }
        , {
            "../constants": 63,
            "./features_at": 90
        }],
        92: [function(t, e, n) {
            "use strict";
            var i = t("./euclidean_distance");
            e.exports = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , r = null != n.fineTolerance ? n.fineTolerance : 4
                  , o = null != n.grossTolerance ? n.grossTolerance : 12
                  , s = null != n.interval ? n.interval : 500;
                t.point = t.point || e.point,
                t.time = t.time || e.time;
                var a = i(t.point, e.point);
                return a < r || a < o && e.time - t.time < s
            }
        }
        , {
            "./euclidean_distance": 89
        }],
        93: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                return !!t.lngLat && (t.lngLat.lng === e[0] && t.lngLat.lat === e[1])
            }
            e.exports = i
        }
        , {}],
        94: [function(t, e, n) {
            "use strict";
            var i = t("./euclidean_distance");
            e.exports = function(t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                  , r = null != n.tolerance ? n.tolerance : 25
                  , o = null != n.interval ? n.interval : 250;
                return t.point = t.point || e.point,
                t.time = t.time || e.time,
                i(t.point, e.point) < r && e.time - t.time < o
            }
        }
        , {
            "./euclidean_distance": 89
        }],
        95: [function(t, e, n) {
            "use strict";
            function i(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return [[t.point.x - e, t.point.y - e], [t.point.x + e, t.point.y + e]]
            }
            e.exports = i
        }
        , {}],
        96: [function(t, e, n) {
            "use strict";
            var i = function(t, e) {
                var n = {
                    drag: [],
                    click: [],
                    mousemove: [],
                    mousedown: [],
                    mouseup: [],
                    mouseout: [],
                    keydown: [],
                    keyup: [],
                    touchstart: [],
                    touchmove: [],
                    touchend: [],
                    tap: []
                }
                  , i = {
                    on: function(t, e, i) {
                        if (void 0 === n[t])
                            throw new Error("Invalid event type: " + t);
                        n[t].push({
                            selector: e,
                            fn: i
                        })
                    },
                    render: function(t) {
                        e.store.featureChanged(t)
                    }
                }
                  , r = function(t, r) {
                    for (var o = n[t], s = o.length; s--; ) {
                        var a = o[s];
                        if (a.selector(r)) {
                            a.fn.call(i, r),
                            e.store.render(),
                            e.ui.updateMapClasses();
                            break
                        }
                    }
                };
                return t.start.call(i),
                {
                    render: t.render,
                    stop: function() {
                        t.stop && t.stop()
                    },
                    trash: function() {
                        t.trash && (t.trash(),
                        e.store.render())
                    },
                    combineFeatures: function() {
                        t.combineFeatures && t.combineFeatures()
                    },
                    uncombineFeatures: function() {
                        t.uncombineFeatures && t.uncombineFeatures()
                    },
                    unionPolygon: function() {
                        t.unionPolygon && t.unionPolygon()
                    },
                    unionLine: function() {
                        t.unionLine && t.unionLine()
                    },
                    splitLine: function() {
                        t.splitLine && t.splitLine()
                    },
                    curveLine: function() {
                        t.curveLine && t.curveLine()
                    },
                    drag: function(t) {
                        r("drag", t)
                    },
                    click: function(t) {
                        r("click", t)
                    },
                    mousemove: function(t) {
                        r("mousemove", t)
                    },
                    mousedown: function(t) {
                        r("mousedown", t)
                    },
                    mouseup: function(t) {
                        r("mouseup", t)
                    },
                    mouseout: function(t) {
                        r("mouseout", t)
                    },
                    keydown: function(t) {
                        r("keydown", t)
                    },
                    keyup: function(t) {
                        r("keyup", t)
                    },
                    touchstart: function(t) {
                        r("touchstart", t)
                    },
                    touchmove: function(t) {
                        r("touchmove", t)
                    },
                    touchend: function(t) {
                        r("touchend", t)
                    },
                    tap: function(t) {
                        r("tap", t)
                    }
                }
            };
            e.exports = i
        }
        , {}],
        97: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                var n = e.getBoundingClientRect();
                return new r(t.clientX - n.left - e.clientLeft,t.clientY - n.top - e.clientTop)
            }
            var r = t("point-geometry");
            e.exports = i
        }
        , {
            "point-geometry": 55
        }],
        98: [function(t, e, n) {
            "use strict";
            var i = t("./constrain_feature_movement")
              , r = t("../constants");
            e.exports = function(t, e) {
                var n = i(t.map(function(t) {
                    return t.toGeoJSON()
                }), e);
                t.forEach(function(t) {
                    var e = t.getCoordinates()
                      , i = function(t) {
                        var e = {
                            lng: t[0] + n.lng,
                            lat: t[1] + n.lat
                        };
                        return [e.lng, e.lat]
                    }
                      , o = function(t) {
                        return t.map(function(t) {
                            return i(t)
                        })
                    }
                      , s = function(t) {
                        return t.map(function(t) {
                            return o(t)
                        })
                    }
                      , a = void 0;
                    t.type === r.geojsonTypes.POINT ? a = i(e) : t.type === r.geojsonTypes.LINE_STRING || t.type === r.geojsonTypes.MULTI_POINT ? a = e.map(i) : t.type === r.geojsonTypes.POLYGON || t.type === r.geojsonTypes.MULTI_LINE_STRING ? a = e.map(o) : t.type === r.geojsonTypes.MULTI_POLYGON && (a = e.map(s)),
                    t.incomingCoords(a)
                })
            }
        }
        , {
            "../constants": 63,
            "./constrain_feature_movement": 84
        }],
        99: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                var n = a[t.geometry.type] - a[e.geometry.type];
                return 0 === n && t.geometry.type === s.geojsonTypes.POLYGON ? t.area - e.area : n
            }
            function r(t) {
                return t.map(function(t) {
                    return t.geometry.type === s.geojsonTypes.POLYGON && (t.area = o.geometry({
                        type: s.geojsonTypes.FEATURE,
                        property: {},
                        geometry: t.geometry
                    })),
                    t
                }).sort(i).map(function(t) {
                    return delete t.area,
                    t
                })
            }
            var o = t("@mapbox/geojson-area")
              , s = t("../constants")
              , a = {
                Point: 0,
                LineString: 1,
                Polygon: 2
            };
            e.exports = r
        }
        , {
            "../constants": 63,
            "@mapbox/geojson-area": 1
        }],
        100: [function(t, e, n) {
            "use strict";
            function i(t) {
                if (this._items = {},
                this._length = t ? t.length : 0,
                t)
                    for (var e = 0, n = t.length; e < n; e++)
                        void 0 !== t[e] && (this._items[t[e]] = e)
            }
            i.prototype.add = function(t) {
                return this._length = this._items[t] ? this._length : this._length + 1,
                this._items[t] = this._items[t] ? this._items[t] : this._length,
                this
            }
            ,
            i.prototype.delete = function(t) {
                return this._length = this._items[t] ? this._length - 1 : this._length,
                delete this._items[t],
                this
            }
            ,
            i.prototype.has = function(t) {
                return void 0 !== this._items[t]
            }
            ,
            i.prototype.values = function() {
                var t = this;
                return Object.keys(this._items).sort(function(e, n) {
                    return t._items[e] - t._items[n]
                })
            }
            ,
            i.prototype.clear = function() {
                return this._length = 0,
                this._items = {},
                this
            }
            ,
            e.exports = i
        }
        , {}],
        101: [function(t, e, n) {
            "use strict";
            e.exports = function(t, e) {
                return t.length === e.length && JSON.stringify(t.map(function(t) {
                    return t
                }).sort()) === JSON.stringify(e.map(function(t) {
                    return t
                }).sort())
            }
        }
        , {}],
        102: [function(t, e, n) {
            "use strict";
            e.exports = [{
                id: "gl-draw-polygon-fill-inactive",
                type: "fill",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
                paint: {
                    "fill-color": "#3bb2d0",
                    "fill-outline-color": "#3bb2d0",
                    "fill-opacity": .1
                }
            }, {
                id: "gl-draw-polygon-fill-active",
                type: "fill",
                filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]],
                paint: {
                    "fill-color": "#fbb03b",
                    "fill-outline-color": "#fbb03b",
                    "fill-opacity": .1
                }
            }, {
                id: "gl-draw-polygon-midpoint",
                type: "circle",
                filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]],
                paint: {
                    "circle-radius": 3,
                    "circle-color": "#fbb03b"
                }
            }, {
                id: "gl-draw-polygon-stroke-inactive",
                type: "line",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#3bb2d0",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-polygon-stroke-active",
                type: "line",
                filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#fbb03b",
                    "line-dasharray": [.2, 2],
                    "line-width": 2
                }
            }, {
                id: "gl-draw-line-inactive",
                type: "line",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#3bb2d0",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-line-active",
                type: "line",
                filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#fbb03b",
                    "line-dasharray": [.2, 2],
                    "line-width": 2
                }
            }, {
                id: "gl-draw-polygon-and-line-vertex-stroke-inactive",
                type: "circle",
                filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 5,
                    "circle-color": "#fff"
                }
            }, {
                id: "gl-draw-polygon-and-line-vertex-inactive",
                type: "circle",
                filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 3,
                    "circle-color": "#fbb03b"
                }
            }, {
                id: "gl-draw-point-point-stroke-inactive",
                type: "circle",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 5,
                    "circle-opacity": 1,
                    "circle-color": "#fff"
                }
            }, {
                id: "gl-draw-point-inactive",
                type: "circle",
                filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]],
                paint: {
                    "circle-radius": 3,
                    "circle-color": "#3bb2d0"
                }
            }, {
                id: "gl-draw-point-stroke-active",
                type: "circle",
                filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]],
                paint: {
                    "circle-radius": 7,
                    "circle-color": "#fff"
                }
            }, {
                id: "gl-draw-point-active",
                type: "circle",
                filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]],
                paint: {
                    "circle-radius": 5,
                    "circle-color": "#fbb03b"
                }
            }, {
                id: "gl-draw-polygon-fill-static",
                type: "fill",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]],
                paint: {
                    "fill-color": "#404040",
                    "fill-outline-color": "#404040",
                    "fill-opacity": .1
                }
            }, {
                id: "gl-draw-polygon-stroke-static",
                type: "line",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#404040",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-line-static",
                type: "line",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#404040",
                    "line-width": 2
                }
            }, {
                id: "gl-draw-point-static",
                type: "circle",
                filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]],
                paint: {
                    "circle-radius": 5,
                    "circle-color": "#404040"
                }
            }]
        }
        , {}],
        103: [function(t, e, n) {
            "use strict";
            function i(t, e, n) {
                function i() {
                    o = !1,
                    s && (r.apply(n, s),
                    s = !1)
                }
                function r() {
                    o ? s = arguments : (o = !0,
                    t.apply(n, arguments),
                    setTimeout(i, e))
                }
                var o = void 0
                  , s = void 0;
                return r
            }
            e.exports = i
        }
        , {}],
        104: [function(t, e, n) {
            "use strict";
            function i(t) {
                return [].concat(t).filter(function(t) {
                    return void 0 !== t
                })
            }
            e.exports = i
        }
        , {}],
        105: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = i.noTarget
              , o = i.isOfMetaType
              , s = i.isInactiveFeature
              , a = i.isShiftDown
              , u = t("../lib/create_supplementary_points")
              , l = t("../lib/constrain_feature_movement")
              , c = t("../lib/double_click_zoom")
              , h = t("../constants")
              , f = t("../lib/common_selectors")
              , d = t("../lib/move_features")
              , g = (t("../feature_types/polygon"),
            t("../feature_types/line_string"))
              , p = t("@turf/line-split")
              , m = o(h.meta.VERTEX)
              , y = o(h.meta.MIDPOINT);
            e.exports = function(t, e) {
                function n(t, e) {
                    return e.map(function(e) {
                        return {
                            feature_id: t,
                            coord_path: e,
                            coordinates: o.getCoordinate(e)
                        }
                    })
                }
                var i = e.featureId
                  , o = t.store.get(i)
                  , v = [];
                if (!o)
                    throw new Error("You must provide a featureId to enter direct_select mode");
                if (o.type === h.geojsonTypes.POINT)
                    throw new TypeError("direct_select mode doesn't handle point features");
                var E = e.startPos || null
                  , x = !1
                  , I = !1
                  , N = e.coordPath ? [e.coordPath] : []
                  , C = n(i, N);
                t.store.setSelectedCoordinates(C);
                var w = function() {
                    t.map.fire(h.events.UPDATE, {
                        action: h.updateActions.CHANGE_COORDINATES,
                        prevFeatures: v,
                        features: t.store.getSelected().map(function(t) {
                            return t.toGeoJSON()
                        })
                    }),
                    v = t.store.getSelected().map(function(t) {
                        return t.toGeoJSON()
                    })
                }
                  , _ = function() {
                    return t.events.actionable({
                        combineFeatures: !1,
                        uncombineFeatures: !1,
                        trash: N.length > 0
                    })
                }
                  , S = function(e) {
                    t.map.dragPan.disable(),
                    I = !0,
                    E = e.lngLat
                }
                  , b = function() {
                    t.map.dragPan.enable(),
                    x = !1,
                    I = !1,
                    E = null
                }
                  , L = function(e) {
                    S(e);
                    var r = e.featureTarget.properties
                      , s = N.indexOf(r.coord_path);
                    a(e) || -1 !== s ? a(e) && -1 === s && N.push(r.coord_path) : N = [r.coord_path];
                    var u = n(i, N);
                    t.store.setSelectedCoordinates(u),
                    o.changed()
                }
                  , T = function(t) {
                    S(t);
                    var e = t.featureTarget.properties;
                    o.addCoordinate(e.coord_path, e.lng, e.lat),
                    w(),
                    N = [e.coord_path]
                }
                  , R = function(t) {
                    0 === N.length ? S(t) : b()
                }
                  , O = function(e, n) {
                    d(t.store.getSelected(), n),
                    E = e.lngLat
                }
                  , P = function(t, e) {
                    for (var n = N.map(function(t) {
                        return o.getCoordinate(t)
                    }), i = n.map(function(t) {
                        return {
                            type: h.geojsonTypes.FEATURE,
                            properties: {},
                            geometry: {
                                type: h.geojsonTypes.POINT,
                                coordinates: t
                            }
                        }
                    }), r = l(i, e), s = 0; s < n.length; s++) {
                        var a = n[s];
                        o.updateCoordinate(N[s], a[0] + r.lng, a[1] + r.lat)
                    }
                };
                return {
                    start: function() {
                        function e() {
                            t.events.changeMode(h.modes.SIMPLE_SELECT)
                        }
                        function n() {
                            t.events.changeMode(h.modes.SIMPLE_SELECT)
                        }
                        function a() {
                            N = [],
                            t.store.clearSelectedCoordinates(),
                            o.changed()
                        }
                        t.store.setSelected(i),
                        c.disable(t),
                        v = t.store.getSelected().map(function(t) {
                            return t.toGeoJSON()
                        }),
                        this.on("mousemove", f.true, function(e) {
                            var n = f.isActiveFeature(e)
                              , i = m(e)
                              , r = 0 === N.length;
                            n && r ? t.ui.queueMapClasses({
                                mouse: h.cursors.MOVE
                            }) : i && !r ? t.ui.queueMapClasses({
                                mouse: h.cursors.MOVE
                            }) : t.ui.queueMapClasses({
                                mouse: h.cursors.NONE
                            }),
                            b()
                        }),
                        this.on("mouseout", function() {
                            return x
                        }, w),
                        this.on("mousedown", m, L),
                        this.on("touchstart", m, L),
                        this.on("mousedown", f.isActiveFeature, R),
                        this.on("touchstart", f.isActiveFeature, R),
                        this.on("mousedown", y, T),
                        this.on("touchstart", y, T),
                        this.on("drag", function() {
                            return I
                        }, function(t) {
                            x = !0,
                            t.originalEvent.stopPropagation();
                            var e = {
                                lng: t.lngLat.lng - E.lng,
                                lat: t.lngLat.lat - E.lat
                            };
                            N.length > 0 ? P(0, e) : O(t, e),
                            E = t.lngLat
                        }),
                        this.on("click", f.true, b),
                        this.on("mouseup", f.true, function() {
                            x && w(),
                            b()
                        }),
                        this.on("touchend", f.true, function() {
                            x && w(),
                            b()
                        }),
                        this.on("click", r, e),
                        this.on("tap", r, e),
                        this.on("click", s, n),
                        this.on("tap", s, n),
                        this.on("click", f.isActiveFeature, a),
                        this.on("tap", f.isActiveFeature, a)
                    },
                    stop: function() {
                        c.enable(t),
                        t.store.clearSelectedCoordinates()
                    },
                    render: function(e, n) {
                        i === e.properties.id ? (e.properties.active = h.activeStates.ACTIVE,
                        n(e),
                        u(e, {
                            map: t.map,
                            midpoints: !0,
                            selectedPaths: N
                        }).forEach(n)) : (e.properties.active = h.activeStates.INACTIVE,
                        n(e)),
                        _()
                    },
                    trash: function() {
                        N.sort().reverse().forEach(function(t) {
                            return o.removeCoordinate(t)
                        }),
                        t.map.fire(h.events.UPDATE, {
                            action: h.updateActions.CHANGE_COORDINATES,
                            prevFeatures: v,
                            features: t.store.getSelected().map(function(t) {
                                return t.toGeoJSON()
                            })
                        }),
                        v = t.store.getSelected().map(function(t) {
                            return t.toGeoJSON()
                        }),
                        N = [],
                        t.store.clearSelectedCoordinates(),
                        _(),
                        !1 === o.isValid() && (t.store.delete([i]),
                        t.events.changeMode(h.modes.SIMPLE_SELECT, {}))
                    },
                    splitLine: function() {
                        var e = t.store.getSelected();
                        if (1 != e.length)
                            throw new Error("您需要且只需选择一条线");
                        if (e[0].type !== h.geojsonTypes.LINE_STRING)
                            throw new Error("您选择必须是线");
                        var n = t.store.getSelectedCoordinates();
                        if (1 != n.length)
                            throw new Error("您需要且只需选择一个断点");
                        var i = {
                            type: h.geojsonTypes.FEATURE,
                            properties: {},
                            geometry: {
                                type: h.geojsonTypes.POINT,
                                coordinates: n[0].coordinates
                            }
                        }
                          , r = p(e[0].toGeoJSON(), i);
                        if (r && r.features && r.features.length > 0) {
                            var o = []
                              , s = [];
                            r.features.map(function(n) {
                                var i = new g(t,{
                                    type: h.geojsonTypes.FEATURE,
                                    properties: e[0].properties,
                                    geometry: n.geometry
                                });
                                t.store.add(i),
                                o.push(i.toGeoJSON()),
                                s.push(i.id)
                            }),
                            t.store.delete(e[0].id, {
                                silent: !0
                            }),
                            t.map.fire(h.events.REPLACE, {
                                createdFeatures: o,
                                deletedFeatures: [e[0].toGeoJSON()]
                            }),
                            t.events.changeMode(h.modes.SIMPLE_SELECT, {
                                featureIds: s
                            })
                        }
                        _()
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/line_string": 76,
            "../feature_types/polygon": 79,
            "../lib/common_selectors": 83,
            "../lib/constrain_feature_movement": 84,
            "../lib/create_supplementary_points": 86,
            "../lib/double_click_zoom": 88,
            "../lib/move_features": 98,
            "@turf/line-split": 29
        }],
        106: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/circle")
              , o = t("../lib/double_click_zoom")
              , s = t("../constants")
              , a = t("../lib/is_event_at_coordinates")
              , u = t("../lib/create_vertex");
            e.exports = function(t) {
                var e = new r(t,{
                    type: s.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: s.geojsonTypes.POLYGON,
                        coordinates: [[]]
                    }
                })
                  , n = 0;
                return t._test && (t._test.polygon = e),
                t.store.add(e),
                {
                    start: function() {
                        function r(i) {
                            if (n > 0 && a(i, e.coordinates[0][n - 1]))
                                return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                    featureIds: [e.id]
                                });
                            t.ui.queueMapClasses({
                                mouse: s.cursors.ADD
                            }),
                            e.updateCoordinate("0." + n, i.lngLat.lng, i.lngLat.lat),
                            ++n >= 1 && (n = 1)
                        }
                        function u() {
                            return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }
                        t.store.clearSelected(),
                        o.disable(t),
                        t.ui.queueMapClasses({
                            mouse: s.cursors.ADD
                        }),
                        t.ui.setActiveButton(s.types.POLYGON),
                        this.on("mousemove", i.true, function(r) {
                            e.updateCoordinate("0." + n, r.lngLat.lng, r.lngLat.lat),
                            i.isVertex(r) && t.ui.queueMapClasses({
                                mouse: s.cursors.POINTER
                            })
                        }),
                        this.on("click", i.true, r),
                        this.on("click", i.isVertex, u),
                        this.on("tap", i.true, r),
                        this.on("tap", i.isVertex, u),
                        this.on("keyup", i.isEscapeKey, function() {
                            t.store.delete([e.id], {
                                silent: !0
                            }),
                            t.events.changeMode(s.modes.SIMPLE_SELECT)
                        }),
                        this.on("keyup", i.isEnterKey, function() {
                            t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        t.ui.queueMapClasses({
                            mouse: s.cursors.NONE
                        }),
                        o.enable(t),
                        t.ui.setActiveButton(),
                        void 0 !== t.store.get(e.id) && (e.removeCoordinate("0." + n),
                        e.isValid() ? t.map.fire(s.events.CREATE, {
                            features: [e.toGeoJSON()]
                        }) : (t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT, {}, {
                            silent: !0
                        })))
                    },
                    render: function(t, n) {
                        var i = t.properties.id === e.id;
                        if (t.properties.active = i ? s.activeStates.ACTIVE : s.activeStates.INACTIVE,
                        !i)
                            return n(t);
                        if (0 !== t.geometry.coordinates.length) {
                            var r = t.geometry.coordinates[0].length;
                            if (!(r < 2)) {
                                if (t.properties.meta = s.meta.FEATURE,
                                r > 4) {
                                    n(u(e.id, t.geometry.coordinates[0][0], "0.0", !1));
                                    var o = t.geometry.coordinates[0].length - 1;
                                    n(u(e.id, t.geometry.coordinates[0][o], "0." + o, !1))
                                }
                                if (r > 3)
                                    return n(t);
                                var a = [[t.geometry.coordinates[0][0][0], t.geometry.coordinates[0][0][1]], [t.geometry.coordinates[0][1][0], t.geometry.coordinates[0][1][1]]];
                                return n({
                                    type: s.geojsonTypes.FEATURE,
                                    properties: t.properties,
                                    geometry: {
                                        coordinates: a,
                                        type: s.geojsonTypes.LINE_STRING
                                    }
                                })
                            }
                        }
                    },
                    trash: function() {
                        t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT)
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/circle": 74,
            "../lib/common_selectors": 83,
            "../lib/create_vertex": 87,
            "../lib/double_click_zoom": 88,
            "../lib/is_event_at_coordinates": 93
        }],
        107: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/line_string")
              , o = t("../lib/is_event_at_coordinates")
              , s = t("../lib/double_click_zoom")
              , a = t("../constants")
              , u = t("../lib/create_vertex");
            e.exports = function(t) {
                var e = new r(t,{
                    type: a.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: a.geojsonTypes.LINE_STRING,
                        coordinates: []
                    }
                })
                  , n = 0;
                return t._test && (t._test.line = e),
                t.store.add(e),
                {
                    start: function() {
                        function r(i) {
                            if (n > 0 && o(i, e.coordinates[n - 1]))
                                return t.events.changeMode(a.modes.SIMPLE_SELECT, {
                                    featureIds: [e.id]
                                });
                            t.ui.queueMapClasses({
                                mouse: a.cursors.ADD
                            }),
                            e.updateCoordinate(n, i.lngLat.lng, i.lngLat.lat),
                            n++
                        }
                        function u() {
                            return t.events.changeMode(a.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }
                        t.store.clearSelected(),
                        s.disable(t),
                        t.ui.queueMapClasses({
                            mouse: a.cursors.ADD
                        }),
                        t.ui.setActiveButton(a.types.LINE),
                        this.on("mousemove", i.true, function(r) {
                            e.updateCoordinate(n, r.lngLat.lng, r.lngLat.lat),
                            i.isVertex(r) && t.ui.queueMapClasses({
                                mouse: a.cursors.POINTER
                            })
                        }),
                        this.on("click", i.true, r),
                        this.on("tap", i.true, r),
                        this.on("click", i.isVertex, u),
                        this.on("tap", i.isVertex, u),
                        this.on("keyup", i.isEscapeKey, function() {
                            t.store.delete([e.id], {
                                silent: !0
                            }),
                            t.events.changeMode(a.modes.SIMPLE_SELECT)
                        }),
                        this.on("keyup", i.isEnterKey, function() {
                            t.events.changeMode(a.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        s.enable(t),
                        t.ui.setActiveButton(),
                        void 0 !== t.store.get(e.id) && (e.removeCoordinate("" + n),
                        e.isValid() ? t.map.fire(a.events.CREATE, {
                            features: [e.toGeoJSON()]
                        }) : (t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(a.modes.SIMPLE_SELECT, {}, {
                            silent: !0
                        })))
                    },
                    render: function(t, n) {
                        var i = t.properties.id === e.id;
                        if (t.properties.active = i ? a.activeStates.ACTIVE : a.activeStates.INACTIVE,
                        !i)
                            return n(t);
                        t.geometry.coordinates.length < 2 || (t.properties.meta = a.meta.FEATURE,
                        t.geometry.coordinates.length >= 3 && n(u(e.id, t.geometry.coordinates[t.geometry.coordinates.length - 2], "" + (t.geometry.coordinates.length - 2), !1)),
                        n(t))
                    },
                    trash: function() {
                        t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(a.modes.SIMPLE_SELECT)
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/line_string": 76,
            "../lib/common_selectors": 83,
            "../lib/create_vertex": 87,
            "../lib/double_click_zoom": 88,
            "../lib/is_event_at_coordinates": 93
        }],
        108: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/point")
              , o = t("../constants");
            e.exports = function(t) {
                function e() {
                    t.events.changeMode(o.modes.SIMPLE_SELECT),
                    t.store.delete([s.id], {
                        silent: !0
                    })
                }
                function n(e) {
                    t.ui.queueMapClasses({
                        mouse: o.cursors.MOVE
                    }),
                    s.updateCoordinate("", e.lngLat.lng, e.lngLat.lat),
                    t.map.fire(o.events.CREATE, {
                        features: [s.toGeoJSON()]
                    }),
                    t.events.changeMode(o.modes.SIMPLE_SELECT, {
                        featureIds: [s.id]
                    })
                }
                var s = new r(t,{
                    type: o.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: o.geojsonTypes.POINT,
                        coordinates: []
                    }
                });
                return t._test && (t._test.point = s),
                t.store.add(s),
                {
                    start: function() {
                        t.store.clearSelected(),
                        t.ui.queueMapClasses({
                            mouse: o.cursors.ADD
                        }),
                        t.ui.setActiveButton(o.types.POINT),
                        this.on("click", i.true, n),
                        this.on("tap", i.true, n),
                        this.on("keyup", i.isEscapeKey, e),
                        this.on("keyup", i.isEnterKey, e),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        t.ui.setActiveButton(),
                        s.getCoordinate().length || t.store.delete([s.id], {
                            silent: !0
                        })
                    },
                    render: function(t, e) {
                        var n = t.properties.id === s.id;
                        if (t.properties.active = n ? o.activeStates.ACTIVE : o.activeStates.INACTIVE,
                        !n)
                            return e(t)
                    },
                    trash: function() {
                        e()
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/point": 78,
            "../lib/common_selectors": 83
        }],
        109: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/polygon")
              , o = t("../lib/double_click_zoom")
              , s = t("../constants")
              , a = t("../lib/is_event_at_coordinates")
              , u = t("../lib/create_vertex");
            e.exports = function(t) {
                var e = new r(t,{
                    type: s.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: s.geojsonTypes.POLYGON,
                        coordinates: [[]]
                    }
                })
                  , n = 0;
                return t._test && (t._test.polygon = e),
                t.store.add(e),
                {
                    start: function() {
                        function r(i) {
                            if (n > 0 && a(i, e.coordinates[0][n - 1]))
                                return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                    featureIds: [e.id]
                                });
                            t.ui.queueMapClasses({
                                mouse: s.cursors.ADD
                            }),
                            e.updateCoordinate("0." + n, i.lngLat.lng, i.lngLat.lat),
                            n++
                        }
                        function u() {
                            return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }
                        t.store.clearSelected(),
                        o.disable(t),
                        t.ui.queueMapClasses({
                            mouse: s.cursors.ADD
                        }),
                        t.ui.setActiveButton(s.types.POLYGON),
                        this.on("mousemove", i.true, function(r) {
                            e.updateCoordinate("0." + n, r.lngLat.lng, r.lngLat.lat),
                            i.isVertex(r) && t.ui.queueMapClasses({
                                mouse: s.cursors.POINTER
                            })
                        }),
                        this.on("click", i.true, r),
                        this.on("click", i.isVertex, u),
                        this.on("tap", i.true, r),
                        this.on("tap", i.isVertex, u),
                        this.on("keyup", i.isEscapeKey, function() {
                            t.store.delete([e.id], {
                                silent: !0
                            }),
                            t.events.changeMode(s.modes.SIMPLE_SELECT)
                        }),
                        this.on("keyup", i.isEnterKey, function() {
                            t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        t.ui.queueMapClasses({
                            mouse: s.cursors.NONE
                        }),
                        o.enable(t),
                        t.ui.setActiveButton(),
                        void 0 !== t.store.get(e.id) && (e.removeCoordinate("0." + n),
                        e.isValid() ? t.map.fire(s.events.CREATE, {
                            features: [e.toGeoJSON()]
                        }) : (t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT, {}, {
                            silent: !0
                        })))
                    },
                    render: function(t, n) {
                        var i = t.properties.id === e.id;
                        if (t.properties.active = i ? s.activeStates.ACTIVE : s.activeStates.INACTIVE,
                        !i)
                            return n(t);
                        if (0 !== t.geometry.coordinates.length) {
                            var r = t.geometry.coordinates[0].length;
                            if (!(r < 3)) {
                                if (t.properties.meta = s.meta.FEATURE,
                                r > 4) {
                                    n(u(e.id, t.geometry.coordinates[0][0], "0.0", !1));
                                    var o = t.geometry.coordinates[0].length - 3;
                                    n(u(e.id, t.geometry.coordinates[0][o], "0." + o, !1))
                                }
                                if (r > 3)
                                    return n(t);
                                var a = [[t.geometry.coordinates[0][0][0], t.geometry.coordinates[0][0][1]], [t.geometry.coordinates[0][1][0], t.geometry.coordinates[0][1][1]]];
                                return n({
                                    type: s.geojsonTypes.FEATURE,
                                    properties: t.properties,
                                    geometry: {
                                        coordinates: a,
                                        type: s.geojsonTypes.LINE_STRING
                                    }
                                })
                            }
                        }
                    },
                    trash: function() {
                        t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT)
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/polygon": 79,
            "../lib/common_selectors": 83,
            "../lib/create_vertex": 87,
            "../lib/double_click_zoom": 88,
            "../lib/is_event_at_coordinates": 93
        }],
        110: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/rectangle")
              , o = t("../lib/double_click_zoom")
              , s = t("../constants")
              , a = (t("../lib/is_event_at_coordinates"),
            t("../lib/create_vertex"));
            e.exports = function(t) {
                var e = new r(t,{
                    type: s.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: s.geojsonTypes.POLYGON,
                        coordinates: [[]]
                    }
                })
                  , n = 0;
                return t._test && (t._test.polygon = e),
                t.store.add(e),
                {
                    start: function() {
                        function r(i) {
                            if (n > 0)
                                return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                    featureIds: [e.id]
                                });
                            t.ui.queueMapClasses({
                                mouse: s.cursors.ADD
                            }),
                            e.updateCoordinate("0." + n, i.lngLat.lng, i.lngLat.lat),
                            ++n >= 1 && (n = 1)
                        }
                        function a() {
                            return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }
                        t.store.clearSelected(),
                        o.disable(t),
                        t.ui.queueMapClasses({
                            mouse: s.cursors.ADD
                        }),
                        t.ui.setActiveButton(s.types.POLYGON),
                        this.on("mousemove", i.true, function(r) {
                            e.updateCoordinate("0." + n, r.lngLat.lng, r.lngLat.lat),
                            i.isVertex(r) && t.ui.queueMapClasses({
                                mouse: s.cursors.POINTER
                            })
                        }),
                        this.on("click", i.true, r),
                        this.on("click", i.isVertex, a),
                        this.on("tap", i.true, r),
                        this.on("tap", i.isVertex, a),
                        this.on("keyup", i.isEscapeKey, function() {
                            t.store.delete([e.id], {
                                silent: !0
                            }),
                            t.events.changeMode(s.modes.SIMPLE_SELECT)
                        }),
                        this.on("keyup", i.isEnterKey, function() {
                            t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        t.ui.queueMapClasses({
                            mouse: s.cursors.NONE
                        }),
                        o.enable(t),
                        t.ui.setActiveButton(),
                        void 0 !== t.store.get(e.id) && (e.isValid() ? t.map.fire(s.events.CREATE, {
                            features: [e.toGeoJSON()]
                        }) : (t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT, {}, {
                            silent: !0
                        })))
                    },
                    render: function(t, n) {
                        var i = t.properties.id === e.id;
                        if (t.properties.active = i ? s.activeStates.ACTIVE : s.activeStates.INACTIVE,
                        !i)
                            return n(t);
                        if (0 !== t.geometry.coordinates.length) {
                            var r = t.geometry.coordinates[0].length;
                            if (!(r < 2)) {
                                if (t.properties.meta = s.meta.FEATURE,
                                r > 4) {
                                    n(a(e.id, t.geometry.coordinates[0][0], "0.0", !1));
                                    var o = t.geometry.coordinates[0].length - 1;
                                    n(a(e.id, t.geometry.coordinates[0][o], "0." + o, !1))
                                }
                                if (r > 3)
                                    return n(t);
                                var u = [[t.geometry.coordinates[0][0][0], t.geometry.coordinates[0][0][1]], [t.geometry.coordinates[0][1][0], t.geometry.coordinates[0][1][1]]];
                                return n({
                                    type: s.geojsonTypes.FEATURE,
                                    properties: t.properties,
                                    geometry: {
                                        coordinates: u,
                                        type: s.geojsonTypes.LINE_STRING
                                    }
                                })
                            }
                        }
                    },
                    trash: function() {
                        t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT)
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/rectangle": 80,
            "../lib/common_selectors": 83,
            "../lib/create_vertex": 87,
            "../lib/double_click_zoom": 88,
            "../lib/is_event_at_coordinates": 93
        }],
        111: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/sector")
              , o = t("../lib/double_click_zoom")
              , s = t("../constants")
              , a = (t("../lib/is_event_at_coordinates"),
            t("../lib/create_vertex"));
            e.exports = function(t) {
                var e = new r(t,{
                    type: s.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: s.geojsonTypes.POLYGON,
                        coordinates: [[]]
                    }
                })
                  , n = 0;
                return t._test && (t._test.polygon = e),
                t.store.add(e),
                {
                    start: function() {
                        function r(i) {
                            if (n > 1)
                                return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                    featureIds: [e.id]
                                });
                            t.ui.queueMapClasses({
                                mouse: s.cursors.ADD
                            }),
                            e.updateCoordinate("0." + n, i.lngLat.lng, i.lngLat.lat),
                            n++
                        }
                        function a() {
                            return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }
                        t.store.clearSelected(),
                        o.disable(t),
                        t.ui.queueMapClasses({
                            mouse: s.cursors.ADD
                        }),
                        t.ui.setActiveButton(s.types.POLYGON),
                        this.on("mousemove", i.true, function(r) {
                            e.updateCoordinate("0." + n, r.lngLat.lng, r.lngLat.lat),
                            i.isVertex(r) && t.ui.queueMapClasses({
                                mouse: s.cursors.POINTER
                            })
                        }),
                        this.on("click", i.true, r),
                        this.on("click", i.isVertex, a),
                        this.on("tap", i.true, r),
                        this.on("tap", i.isVertex, a),
                        this.on("keyup", i.isEscapeKey, function() {
                            t.store.delete([e.id], {
                                silent: !0
                            }),
                            t.events.changeMode(s.modes.SIMPLE_SELECT)
                        }),
                        this.on("keyup", i.isEnterKey, function() {
                            t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        t.ui.queueMapClasses({
                            mouse: s.cursors.NONE
                        }),
                        o.enable(t),
                        t.ui.setActiveButton(),
                        void 0 !== t.store.get(e.id) && (e.isValid() ? t.map.fire(s.events.CREATE, {
                            features: [e.toGeoJSON()]
                        }) : (t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT, {}, {
                            silent: !0
                        })))
                    },
                    render: function(t, n) {
                        var i = t.properties.id === e.id;
                        if (t.properties.active = i ? s.activeStates.ACTIVE : s.activeStates.INACTIVE,
                        !i)
                            return n(t);
                        if (0 !== t.geometry.coordinates.length) {
                            var r = t.geometry.coordinates[0].length;
                            if (!(r < 2)) {
                                if (t.properties.meta = s.meta.FEATURE,
                                r > 4) {
                                    n(a(e.id, t.geometry.coordinates[0][0], "0.0", !1));
                                    var o = t.geometry.coordinates[0].length - 1;
                                    n(a(e.id, t.geometry.coordinates[0][o], "0." + o, !1))
                                }
                                if (r > 3)
                                    return n(t);
                                var u = [[t.geometry.coordinates[0][0][0], t.geometry.coordinates[0][0][1]], [t.geometry.coordinates[0][1][0], t.geometry.coordinates[0][1][1]]];
                                return n({
                                    type: s.geojsonTypes.FEATURE,
                                    properties: t.properties,
                                    geometry: {
                                        coordinates: u,
                                        type: s.geojsonTypes.LINE_STRING
                                    }
                                })
                            }
                        }
                    },
                    trash: function() {
                        t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT)
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/sector": 81,
            "../lib/common_selectors": 83,
            "../lib/create_vertex": 87,
            "../lib/double_click_zoom": 88,
            "../lib/is_event_at_coordinates": 93
        }],
        112: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/triangle")
              , o = t("../lib/double_click_zoom")
              , s = t("../constants")
              , a = (t("../lib/is_event_at_coordinates"),
            t("../lib/create_vertex"));
            e.exports = function(t) {
                var e = new r(t,{
                    type: s.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: s.geojsonTypes.POLYGON,
                        coordinates: [[]]
                    }
                })
                  , n = 0;
                return t._test && (t._test.polygon = e),
                t.store.add(e),
                {
                    start: function() {
                        function r(i) {
                            if (n > 1)
                                return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                    featureIds: [e.id]
                                });
                            t.ui.queueMapClasses({
                                mouse: s.cursors.ADD
                            }),
                            e.updateCoordinate("0." + n, i.lngLat.lng, i.lngLat.lat),
                            n++
                        }
                        function a() {
                            return t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }
                        t.store.clearSelected(),
                        o.disable(t),
                        t.ui.queueMapClasses({
                            mouse: s.cursors.ADD
                        }),
                        t.ui.setActiveButton(s.types.POLYGON),
                        this.on("mousemove", i.true, function(r) {
                            e.updateCoordinate("0." + n, r.lngLat.lng, r.lngLat.lat),
                            i.isVertex(r) && t.ui.queueMapClasses({
                                mouse: s.cursors.POINTER
                            })
                        }),
                        this.on("click", i.true, r),
                        this.on("click", i.isVertex, a),
                        this.on("tap", i.true, r),
                        this.on("tap", i.isVertex, a),
                        this.on("keyup", i.isEscapeKey, function() {
                            t.store.delete([e.id], {
                                silent: !0
                            }),
                            t.events.changeMode(s.modes.SIMPLE_SELECT)
                        }),
                        this.on("keyup", i.isEnterKey, function() {
                            t.events.changeMode(s.modes.SIMPLE_SELECT, {
                                featureIds: [e.id]
                            })
                        }),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        t.ui.queueMapClasses({
                            mouse: s.cursors.NONE
                        }),
                        o.enable(t),
                        t.ui.setActiveButton(),
                        void 0 !== t.store.get(e.id) && (e.isValid() ? t.map.fire(s.events.CREATE, {
                            features: [e.toGeoJSON()]
                        }) : (t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT, {}, {
                            silent: !0
                        })))
                    },
                    render: function(t, n) {
                        var i = t.properties.id === e.id;
                        if (t.properties.active = i ? s.activeStates.ACTIVE : s.activeStates.INACTIVE,
                        !i)
                            return n(t);
                        if (0 !== t.geometry.coordinates.length) {
                            var r = t.geometry.coordinates[0].length;
                            if (!(r < 2)) {
                                if (t.properties.meta = s.meta.FEATURE,
                                r > 4) {
                                    n(a(e.id, t.geometry.coordinates[0][0], "0.0", !1));
                                    var o = t.geometry.coordinates[0].length - 1;
                                    n(a(e.id, t.geometry.coordinates[0][o], "0." + o, !1))
                                }
                                if (r > 3)
                                    return n(t);
                                var u = [[t.geometry.coordinates[0][0][0], t.geometry.coordinates[0][0][1]], [t.geometry.coordinates[0][1][0], t.geometry.coordinates[0][1][1]]];
                                return n({
                                    type: s.geojsonTypes.FEATURE,
                                    properties: t.properties,
                                    geometry: {
                                        coordinates: u,
                                        type: s.geojsonTypes.LINE_STRING
                                    }
                                })
                            }
                        }
                    },
                    trash: function() {
                        t.store.delete([e.id], {
                            silent: !0
                        }),
                        t.events.changeMode(s.modes.SIMPLE_SELECT)
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../feature_types/triangle": 82,
            "../lib/common_selectors": 83,
            "../lib/create_vertex": 87,
            "../lib/double_click_zoom": 88,
            "../lib/is_event_at_coordinates": 93
        }],
        113: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../lib/mouse_event_point")
              , o = t("../lib/features_at")
              , s = t("../lib/create_supplementary_points")
              , a = t("../lib/string_set")
              , u = t("../lib/double_click_zoom")
              , l = t("../lib/move_features")
              , c = t("../constants")
              , h = t("../feature_types/multi_feature")
              , f = t("../feature_types/polygon")
              , d = t("../feature_types/line_string")
              , g = t("@turf/intersect")
              , p = t("@turf/line-intersect")
              , m = t("@turf/union")
              , y = t("@turf/bezier")
              , v = t("@turf/polygon-to-linestring")
              , E = t("@turf/linestring-to-polygon")
              , x = t("../edit/util/is_same_point");
            e.exports = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                  , n = null
                  , I = null
                  , N = void 0
                  , C = !1
                  , w = !1
                  , _ = !1
                  , S = !1
                  , b = e.featureIds || []
                  , L = []
                  , T = function() {
                    for (var e = {
                        action: c.updateActions.MOVE,
                        prevFeatures: L,
                        features: t.store.getSelected().map(function(t) {
                            return t.toGeoJSON()
                        })
                    }, n = 0; n < e.prevFeatures.length; n++) {
                        var i = e.prevFeatures[n];
                        if ("Feature" === i.type && i.properties.hasOwnProperty("center")) {
                            var r = e.features[n]
                              , o = r.geometry.coordinates[0][0][0] - i.geometry.coordinates[0][0][0]
                              , s = r.geometry.coordinates[0][0][1] - i.geometry.coordinates[0][0][1];
                            r.properties.center[0] += o,
                            r.properties.center[1] += s
                        }
                    }
                    t.map.fire(c.events.UPDATE, e),
                    L = t.store.getSelected().map(function(t) {
                        return t.toGeoJSON()
                    })
                }
                  , R = function() {
                    var e = t.store.getSelected()
                      , n = e.filter(function(t) {
                        return t instanceof h
                    })
                      , i = !1;
                    if (e.length > 1) {
                        i = !0;
                        var r = e[0].type.replace("Multi", "");
                        e.forEach(function(t) {
                            t.type.replace("Multi", "") !== r && (i = !1)
                        })
                    }
                    var o = n.length > 0
                      , s = e.length > 0;
                    t.events.actionable({
                        combineFeatures: i,
                        uncombineFeatures: o,
                        trash: s
                    })
                }
                  , O = function(t) {
                    return t.length ? t.map(function(t) {
                        return t.properties.id
                    }).filter(function(t) {
                        return void 0 !== t
                    }).reduce(function(t, e) {
                        return t.add(e),
                        t
                    }, new a).values() : []
                }
                  , P = function() {
                    N && (N.parentNode && N.parentNode.removeChild(N),
                    N = null),
                    t.map.dragPan.enable(),
                    C = !1,
                    w = !1,
                    _ = !1,
                    S = !1
                }
                  , M = function(t, e) {
                    if (0 == e.length)
                        return !0;
                    var n = e[e.length - 1];
                    return t[0] != n[0] || t[1] != n[1]
                }
                  , A = function(t, e) {
                    var n = v(t)
                      , i = v(e)
                      , r = n.geometry.coordinates
                      , o = i.geometry.coordinates
                      , s = [];
                    r.map(function(t, e) {
                        o.some(function(e) {
                            return t[0] == e[0] && t[1] == e[1]
                        }) && s.push(e)
                    });
                    for (var a = !1, u = 0, l = 0, c = 0; c < s.length - 1; c++)
                        1 != Math.abs(s[c + 1] - s[c]) && (a = !0,
                        u = s[c],
                        l = s[c + 1],
                        u > l && (u = s[c + 1],
                        l = s[c]));
                    a || (u = s[0],
                    l = s[s.length - 1],
                    u > l && (u = s[s.length - 1],
                    l = s[0]));
                    var h = [];
                    return a ? r.map(function(t, e) {
                        e >= u && e <= l && h.push(t)
                    }) : (r.map(function(t, e) {
                        e >= l && e < r.length && h.push(t)
                    }),
                    r.map(function(t, e) {
                        e >= 0 && e <= u && M(t, h) && h.push(t)
                    })),
                    h
                }
                  , D = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1]
                };
                return {
                    stop: function() {
                        u.enable(t)
                    },
                    start: function() {
                        function e() {
                            var e = this
                              , n = t.store.getSelectedIds();
                            n.length && (t.store.clearSelected(),
                            n.forEach(function(t) {
                                return e.render(t)
                            })),
                            u.enable(t),
                            P()
                        }
                        function s(e) {
                            t.events.changeMode(c.modes.DIRECT_SELECT, {
                                featureId: e.featureTarget.properties.parent,
                                coordPath: e.featureTarget.properties.coord_path,
                                startPos: e.lngLat
                            }),
                            t.ui.queueMapClasses({
                                mouse: c.cursors.MOVE
                            })
                        }
                        function a(e) {
                            P(),
                            t.map.dragPan.disable(),
                            this.render(e.featureTarget.properties.id),
                            S = !0,
                            n = e.lngLat,
                            L = t.store.getSelected().map(function(t) {
                                return t.toGeoJSON()
                            })
                        }
                        function h(e) {
                            u.disable(t),
                            P();
                            var n = i.isShiftDown(e)
                              , r = t.store.getSelectedIds()
                              , o = e.featureTarget.properties.id
                              , s = t.store.isSelected(o);
                            if (!n && s && t.store.get(o).type !== c.geojsonTypes.POINT)
                                return t.events.changeMode(c.modes.DIRECT_SELECT, {
                                    featureId: o
                                });
                            s && n ? (t.store.deselect(o),
                            t.ui.queueMapClasses({
                                mouse: c.cursors.POINTER
                            }),
                            1 === r.length && u.enable(t)) : !s && n ? (t.store.select(o),
                            t.ui.queueMapClasses({
                                mouse: c.cursors.MOVE
                            })) : s || n || (r.forEach(this.render),
                            t.store.setSelected(o),
                            t.ui.queueMapClasses({
                                mouse: c.cursors.MOVE
                            })),
                            t.map.fire(c.events.SELECTED, {
                                featureIds: t.store.getSelectedIds()
                            }),
                            this.render(o)
                        }
                        t.store && (t.store.setSelected(b.filter(function(e) {
                            return void 0 !== t.store.get(e)
                        })),
                        L = t.store.getSelected().map(function(t) {
                            return t.toGeoJSON()
                        }),
                        R()),
                        this.on("mouseup", i.true, P),
                        this.on("mousemove", i.true, P),
                        this.on("mouseout", function() {
                            return _
                        }, T),
                        this.on("click", i.noTarget, e),
                        this.on("tap", i.noTarget, e),
                        this.on("click", i.isOfMetaType(c.meta.VERTEX), s),
                        this.on("tap", i.isOfMetaType(c.meta.VERTEX), s),
                        this.on("mousedown", i.isActiveFeature, a),
                        this.on("touchstart", i.isActiveFeature, a),
                        this.on("click", i.isFeature, h),
                        this.on("tap", i.isFeature, h),
                        this.on("drag", function() {
                            return S
                        }, function(e) {
                            _ = !0,
                            e.originalEvent.stopPropagation();
                            var i = {
                                lng: e.lngLat.lng - n.lng,
                                lat: e.lngLat.lat - n.lat
                            };
                            l(t.store.getSelected(), i),
                            n = e.lngLat
                        }),
                        this.on("mouseup", i.true, function(e) {
                            if (_)
                                T();
                            else if (C) {
                                var n = [I, r(e.originalEvent, t.container)]
                                  , i = o.click(null, n, t)
                                  , s = O(i).filter(function(e) {
                                    return !t.store.isSelected(e)
                                });
                                s.length && (t.store.select(s),
                                s.forEach(this.render),
                                t.ui.queueMapClasses({
                                    mouse: c.cursors.MOVE
                                })),
                                t.map.fire(c.events.SELECTED, {
                                    featureIds: t.store.getSelectedIds()
                                })
                            }
                            P()
                        }),
                        t.options.boxSelect && (this.on("mousedown", i.isShiftMousedown, function(e) {
                            P(),
                            t.map.dragPan.disable(),
                            I = r(e.originalEvent, t.container),
                            w = !0
                        }),
                        this.on("drag", function() {
                            return w
                        }, function(e) {
                            C = !0,
                            t.ui.queueMapClasses({
                                mouse: c.cursors.ADD
                            }),
                            N || (N = document.createElement("div"),
                            N.classList.add(c.classes.BOX_SELECT),
                            t.container.appendChild(N));
                            var n = r(e.originalEvent, t.container)
                              , i = Math.min(I.x, n.x)
                              , o = Math.max(I.x, n.x)
                              , s = Math.min(I.y, n.y)
                              , a = Math.max(I.y, n.y)
                              , u = "translate(" + i + "px, " + s + "px)";
                            N.style.transform = u,
                            N.style.WebkitTransform = u,
                            N.style.width = o - i + "px",
                            N.style.height = a - s + "px"
                        }))
                    },
                    render: function(e, n) {
                        e.properties.active = t.store.isSelected(e.properties.id) ? c.activeStates.ACTIVE : c.activeStates.INACTIVE,
                        n(e),
                        R(),
                        e.properties.active === c.activeStates.ACTIVE && e.geometry.type !== c.geojsonTypes.POINT && s(e).forEach(n)
                    },
                    trash: function() {
                        t.store.delete(t.store.getSelectedIds()),
                        R()
                    },
                    combineFeatures: function() {
                        var e = t.store.getSelected();
                        if (!(0 === e.length || e.length < 2)) {
                            for (var n = [], i = [], r = e[0].type.replace("Multi", ""), o = 0; o < e.length; o++) {
                                var s = e[o];
                                if (s.type.replace("Multi", "") !== r)
                                    return;
                                s.type.includes("Multi") ? s.getCoordinates().forEach(function(t) {
                                    n.push(t)
                                }) : n.push(s.getCoordinates()),
                                i.push(s.toGeoJSON())
                            }
                            if (i.length > 1) {
                                var a = new h(t,{
                                    type: c.geojsonTypes.FEATURE,
                                    properties: i[0].properties,
                                    geometry: {
                                        type: "Multi" + r,
                                        coordinates: n
                                    }
                                });
                                t.store.add(a),
                                t.store.delete(t.store.getSelectedIds(), {
                                    silent: !0
                                }),
                                t.store.setSelected([a.id]),
                                t.map.fire(c.events.COMBINE_FEATURES, {
                                    createdFeatures: [a.toGeoJSON()],
                                    deletedFeatures: i
                                })
                            }
                            R()
                        }
                    },
                    uncombineFeatures: function() {
                        var e = t.store.getSelected();
                        if (0 !== e.length) {
                            for (var n = [], i = [], r = 0; r < e.length; r++)
                                !function(r) {
                                    var o = e[r];
                                    o instanceof h && (o.getFeatures().forEach(function(e) {
                                        t.store.add(e),
                                        e.properties = o.properties,
                                        n.push(e.toGeoJSON()),
                                        t.store.select([e.id])
                                    }),
                                    t.store.delete(o.id, {
                                        silent: !0
                                    }),
                                    i.push(o.toGeoJSON()))
                                }(r);
                            n.length > 1 && t.map.fire(c.events.UNCOMBINE_FEATURES, {
                                createdFeatures: n,
                                deletedFeatures: i
                            }),
                            R()
                        }
                    },
                    unionPolygon: function() {
                        var e = t.store.getSelected();
                        if (2 != e.length)
                            throw new Error("您需要且只需选择两个面");
                        for (var n = 0; n < e.length; n++) {
                            if (e[n].type !== c.geojsonTypes.POLYGON)
                                throw new Error("您选择的必须是面")
                        }
                        var i = null
                          , r = e[0].toGeoJSON()
                          , o = e[1].toGeoJSON();
                        try {
                            i = g(r, o)
                        } catch (t) {
                            i = p(r, o)
                        }
                        if (!i)
                            throw new Error("您选择的面没有交集，不能合并");
                        var s = null;
                        try {
                            s = m(r, o)
                        } catch (t) {
                            var a = A(r, o)
                              , u = A(o, r)
                              , l = a[0]
                              , h = a[a.length - 1]
                              , d = u[0]
                              , y = u[u.length - 1];
                            if (D(h, d) && D(l, y) || D(h, y) && D(l, d))
                                ;
                            else if (D(h, d) && !D(l, y)) {
                                var v = -1
                                  , x = -1;
                                a.map(function(t, e) {
                                    D(t, y) && (v = e)
                                }),
                                u.map(function(t, e) {
                                    D(t, l) && (x = e)
                                }),
                                x > -1 ? a = a.slice(x, a.length) : v > -1 && (u = u.slice(0, v + 1))
                            } else if (D(h, y) && !D(l, d)) {
                                var I = -1
                                  , N = -1;
                                a.map(function(t, e) {
                                    D(t, d) && (N = e)
                                }),
                                u.map(function(t, e) {
                                    D(t, l) && (I = e)
                                }),
                                I > -1 ? u = u.slice(I, u.length) : N > -1 && (a = a.slice(N, a.length))
                            } else {
                                var C = -1
                                  , w = -1
                                  , _ = -1
                                  , S = -1;
                                a.map(function(t, e) {
                                    D(t, d) && (_ = e),
                                    D(t, y) && (S = e)
                                }),
                                u.map(function(t, e) {
                                    D(t, l) && (C = e),
                                    D(t, h) && (w = e)
                                }),
                                C > -1 && w > -1 ? u = u.slice(Math.min(C, w), Math.max(C, w) + 1) : _ > -1 && S > -1 && (a = a.slice(Math.min(_, S), Math.max(_, S) + 1))
                            }
                            var b = [];
                            if (a.map(function(t) {
                                b.push(t)
                            }),
                            D(h, d))
                                u.map(function(t) {
                                    M(t, b) && b.push(t)
                                });
                            else if (D(h, y))
                                for (var L = u.length - 1; L >= 0; L--)
                                    M(u[L], b) && b.push(u[L]);
                            else
                                u.map(function(t) {
                                    M(t, b) && b.push(t)
                                });
                            M(l, b) && b.push(l),
                            s = E({
                                type: c.geojsonTypes.FEATURE,
                                properties: {},
                                geometry: {
                                    type: c.geojsonTypes.LINE_STRING,
                                    coordinates: b
                                }
                            })
                        }
                        if (s) {
                            var T = new f(t,{
                                type: c.geojsonTypes.FEATURE,
                                properties: s.properties,
                                geometry: {
                                    type: c.geojsonTypes.POLYGON,
                                    coordinates: s.geometry.coordinates
                                }
                            });
                            t.store.add(T),
                            t.store.delete(t.store.getSelectedIds(), {
                                silent: !0
                            }),
                            t.store.setSelected([T.id]),
                            t.map.fire(c.events.REPLACE, {
                                createdFeatures: [T.toGeoJSON()],
                                deletedFeatures: [r, o]
                            })
                        }
                        R()
                    },
                    unionLine: function() {
                        var e = t.store.getSelected();
                        if (2 != e.length)
                            throw new Error("您需要且只需选择两条线");
                        for (var n = 0; n < e.length; n++) {
                            if (e[n].type !== c.geojsonTypes.LINE_STRING)
                                throw new Error("您选择的必须是线")
                        }
                        var i = e[0].coordinates[0]
                          , r = e[0].coordinates[e[0].coordinates.length - 1]
                          , o = e[1].coordinates[0]
                          , s = e[1].coordinates[e[1].coordinates.length - 1]
                          , a = [];
                        if (x(i, o)) {
                            for (var u = e[0].coordinates.length - 1; u >= 0; u--)
                                a.push(e[0].coordinates[u]);
                            for (var l = 0; l < e[1].coordinates.length; l++)
                                a.push(e[1].coordinates[l])
                        } else if (x(i, s)) {
                            for (var h = e[0].coordinates.length - 1; h >= 0; h--)
                                a.push(e[0].coordinates[h]);
                            for (var f = e[1].coordinates.length - 1; f >= 0; f--)
                                a.push(e[1].coordinates[f])
                        } else if (x(r, o)) {
                            for (var g = 0; g < e[0].coordinates.length; g++)
                                a.push(e[0].coordinates[g]);
                            for (var p = 0; p < e[1].coordinates.length; p++)
                                a.push(e[1].coordinates[p])
                        } else {
                            if (!x(r, s))
                                throw new Error("您选择的线的两段没有交集");
                            for (var m = 0; m < e[0].coordinates.length; m++)
                                a.push(e[0].coordinates[m]);
                            for (var y = e[1].coordinates.length - 1; y >= 0; y--)
                                a.push(e[1].coordinates[y])
                        }
                        if (a.length > 0) {
                            var v = new d(t,{
                                type: c.geojsonTypes.FEATURE,
                                properties: e[0].properties,
                                geometry: {
                                    type: c.geojsonTypes.LINE_STRING,
                                    coordinates: a
                                }
                            });
                            t.store.add(v),
                            t.store.delete(t.store.getSelectedIds(), {
                                silent: !0
                            }),
                            t.store.setSelected([v.id]),
                            t.map.fire(c.events.REPLACE, {
                                createdFeatures: [v.toGeoJSON()],
                                deletedFeatures: [e[0].toGeoJSON(), e[1].toGeoJSON()]
                            })
                        }
                        R()
                    },
                    curveLine: function() {
                        var e = t.store.getSelected();
                        if (1 != e.length)
                            throw new Error("您需要且只需选择一条线");
                        if (e[0].type !== c.geojsonTypes.LINE_STRING)
                            throw new Error("您选择的必须是线");
                        var n = y(e[0].toGeoJSON())
                          , i = new d(t,Object.assign({}, n, {
                            id: e[0].id
                        }));
                        t.store.delete(t.store.getSelectedIds(), {
                            silent: !0
                        }),
                        t.store.add(i),
                        t.store.setSelected([i.id]),
                        t.map.fire(c.events.UPDATE, {
                            action: c.updateActions.CHANGE_COORDINATES,
                            prevFeatures: [e[0].toGeoJSON()],
                            features: [i.toGeoJSON()]
                        }),
                        R()
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../edit/util/is_same_point": 72,
            "../feature_types/line_string": 76,
            "../feature_types/multi_feature": 77,
            "../feature_types/polygon": 79,
            "../lib/common_selectors": 83,
            "../lib/create_supplementary_points": 86,
            "../lib/double_click_zoom": 88,
            "../lib/features_at": 90,
            "../lib/mouse_event_point": 97,
            "../lib/move_features": 98,
            "../lib/string_set": 100,
            "@turf/bezier": 10,
            "@turf/intersect": 20,
            "@turf/line-intersect": 27,
            "@turf/linestring-to-polygon": 30,
            "@turf/polygon-to-linestring": 34,
            "@turf/union": 39
        }],
        114: [function(t, e, n) {
            "use strict";
            var i = t("../lib/common_selectors")
              , r = t("../feature_types/line_string")
              , o = t("../lib/is_event_at_coordinates")
              , s = t("../lib/double_click_zoom")
              , a = t("../constants")
              , u = t("../lib/create_vertex")
              , l = t("../feature_types/polygon")
              , c = t("@turf/polygon-to-linestring")
              , h = t("@turf/linestring-to-polygon")
              , f = t("@turf/line-intersect")
              , d = t("@turf/point-on-line");
            t("../edit/util/is_same_point");
            e.exports = function(t) {
                var e = t.store.getSelected();
                if (0 == e.length)
                    throw new Error("请先选取一个多边形");
                if (e.length > 1)
                    throw new Error("只能选取一个多边形");
                var n = e[0];
                if (n.type != a.geojsonTypes.POLYGON)
                    throw new Error("请先选取一个多边形");
                var g = n.id
                  , p = new r(t,{
                    type: a.geojsonTypes.FEATURE,
                    properties: {},
                    geometry: {
                        type: a.geojsonTypes.LINE_STRING,
                        coordinates: []
                    }
                })
                  , m = 0;
                t._test && (t._test.line = p),
                t.store.add(p);
                var y = function(t, e) {
                    if (0 == e.length)
                        return !0;
                    var n = e[e.length - 1];
                    return t[0] != n[0] || t[1] != n[1]
                }
                  , v = function() {
                    var e = p.toGeoJSON()
                      , i = n.toGeoJSON()
                      , r = f(i, e);
                    if (2 != r.features.length)
                        throw t.store.delete([p.id], {
                            silent: !0
                        }),
                        t.events.changeMode(a.modes.SIMPLE_SELECT, {
                            featureIds: [g]
                        }),
                        new Error("您所画的线与面需要切仅需两个交点");
                    var o = c(i)
                      , s = d(e, r.features[0], "miles")
                      , u = d(e, r.features[1], "miles")
                      , m = d(o, r.features[0], "miles")
                      , v = d(o, r.features[1], "miles");
                    s.geometry.coordinates = r.features[0].geometry.coordinates,
                    u.geometry.coordinates = r.features[1].geometry.coordinates,
                    m.geometry.coordinates = r.features[0].geometry.coordinates,
                    v.geometry.coordinates = r.features[1].geometry.coordinates;
                    var E = o.geometry.coordinates
                      , x = e.geometry.coordinates
                      , I = []
                      , N = [];
                    if (I.push(m.geometry.coordinates),
                    m.properties.index <= v.properties.index)
                        for (var C = m.properties.index + 1; C < v.properties.index + 1; C++)
                            y(E[C], I) && I.push(E[C]);
                    else
                        for (var w = m.properties.index; w > v.properties.index; w--)
                            y(E[w], I) && I.push(E[w]);
                    if (y(v.geometry.coordinates, I) && I.push(v.geometry.coordinates),
                    y(u.geometry.coordinates, I) && I.push(u.geometry.coordinates),
                    s.properties.index <= u.properties.index)
                        for (var _ = u.properties.index; _ > s.properties.index; _--)
                            y(x[_], I) && I.push(x[_]);
                    else
                        for (var S = u.properties.index + 1; S < s.properties.index + 1; S++)
                            y(x[S], I) && I.push(x[S]);
                    if (y(s.geometry.coordinates, I) && I.push(s.geometry.coordinates),
                    y(m.geometry.coordinates, I) && I.push(m.geometry.coordinates),
                    N.push(s.geometry.coordinates),
                    s.properties.index <= u.properties.index)
                        for (var b = s.properties.index + 1; b < u.properties.index + 1; b++)
                            y(x[b], N) && N.push(x[b]);
                    else
                        for (var L = s.properties.index; L > u.properties.index; L--)
                            y(x[L], N) && N.push(x[L]);
                    if (y(u.geometry.coordinates, N) && N.push(u.geometry.coordinates),
                    y(v.geometry.coordinates, N) && N.push(v.geometry.coordinates),
                    m.properties.index <= v.properties.index) {
                        for (var T = v.properties.index + 1; T < E.length; T++)
                            y(E[T], N) && N.push(E[T]);
                        for (var R = 0; R < m.properties.index + 1; R++)
                            y(E[R], N) && N.push(E[R])
                    } else {
                        for (var O = v.properties.index; O >= 0; O--)
                            y(E[O], N) && N.push(E[O]);
                        for (var P = E.length - 1; P > m.properties.index; P--)
                            y(E[P], N) && N.push(E[P])
                    }
                    y(m.geometry.coordinates, N) && N.push(m.geometry.coordinates),
                    y(s.geometry.coordinates, N) && N.push(s.geometry.coordinates);
                    var M = h({
                        type: a.geojsonTypes.FEATURE,
                        properties: {},
                        geometry: {
                            type: a.geojsonTypes.LINE_STRING,
                            coordinates: I
                        }
                    })
                      , A = h({
                        type: a.geojsonTypes.FEATURE,
                        properties: {},
                        geometry: {
                            type: a.geojsonTypes.LINE_STRING,
                            coordinates: N
                        }
                    })
                      , D = new l(t,Object.assign({}, {
                        geometry: M.geometry
                    }, {
                        properties: n.properties
                    }))
                      , F = new l(t,Object.assign({}, {
                        geometry: A.geometry
                    }, {
                        properties: n.properties
                    }));
                    t.store.add(D),
                    t.store.add(F),
                    t.store.delete(n.id, {
                        silent: !0
                    }),
                    t.store.delete([p.id], {
                        silent: !0
                    }),
                    t.map.fire(a.events.REPLACE, {
                        createdFeatures: [D.toGeoJSON(), F.toGeoJSON()],
                        deletedFeatures: [n.toGeoJSON()]
                    }),
                    t.events.changeMode(a.modes.SIMPLE_SELECT, {
                        featureIds: [D.id, F.id]
                    })
                };
                return {
                    start: function() {
                        function e(e) {
                            if (m > 0 && o(e, p.coordinates[m - 1]))
                                return void v();
                            t.store.setSelected([g]),
                            t.ui.queueMapClasses({
                                mouse: a.cursors.ADD
                            }),
                            p.updateCoordinate(m, e.lngLat.lng, e.lngLat.lat),
                            m++
                        }
                        function n() {
                            v()
                        }
                        t.store.setSelected([g]),
                        s.disable(t),
                        t.ui.queueMapClasses({
                            mouse: a.cursors.ADD
                        }),
                        this.on("mousemove", i.true, function(e) {
                            p.updateCoordinate(m, e.lngLat.lng, e.lngLat.lat),
                            t.ui.queueMapClasses({
                                mouse: a.cursors.ADD
                            })
                        }),
                        this.on("click", i.true, e),
                        this.on("tap", i.true, e),
                        this.on("click", i.isVertex, n),
                        this.on("tap", i.isVertex, n),
                        this.on("keyup", i.isEscapeKey, function() {
                            t.store.delete([p.id], {
                                silent: !0
                            }),
                            t.events.changeMode(a.modes.SIMPLE_SELECT, {
                                featureIds: [g]
                            })
                        }),
                        this.on("keyup", i.isEnterKey, function() {
                            v()
                        }),
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !0
                        })
                    },
                    stop: function() {
                        t.ui.queueMapClasses({
                            mouse: a.cursors.NONE
                        }),
                        s.enable(t),
                        void 0 !== t.store.get(p.id) && (p.removeCoordinate("" + m),
                        p.isValid() ? v() : (t.store.delete([p.id], {
                            silent: !0
                        }),
                        t.events.changeMode(a.modes.SIMPLE_SELECT, {
                            featureIds: [g]
                        })))
                    },
                    render: function(e, n) {
                        if (t.store.isSelected(e.properties.id) && e.geometry.type === a.geojsonTypes.POLYGON)
                            return e.properties.active = a.activeStates.ACTIVE,
                            n(e);
                        var i = e.properties.id === p.id;
                        if (e.properties.active = i ? a.activeStates.ACTIVE : a.activeStates.INACTIVE,
                        !i)
                            return n(e);
                        e.geometry.coordinates.length < 2 || (e.properties.meta = a.meta.FEATURE,
                        e.geometry.coordinates.length >= 3 && n(u(p.id, e.geometry.coordinates[e.geometry.coordinates.length - 2], "" + (e.geometry.coordinates.length - 2), !1)),
                        n(e))
                    },
                    trash: function() {
                        t.store.delete([p.id], {
                            silent: !0
                        }),
                        t.events.changeMode(a.modes.SIMPLE_SELECT, {
                            featureIds: [g]
                        })
                    }
                }
            }
        }
        , {
            "../constants": 63,
            "../edit/util/is_same_point": 72,
            "../feature_types/line_string": 76,
            "../feature_types/polygon": 79,
            "../lib/common_selectors": 83,
            "../lib/create_vertex": 87,
            "../lib/double_click_zoom": 88,
            "../lib/is_event_at_coordinates": 93,
            "@turf/line-intersect": 27,
            "@turf/linestring-to-polygon": 30,
            "@turf/point-on-line": 33,
            "@turf/polygon-to-linestring": 34
        }],
        115: [function(t, e, n) {
            "use strict";
            e.exports = function(t) {
                return {
                    stop: function() {},
                    start: function() {
                        t.events.actionable({
                            combineFeatures: !1,
                            uncombineFeatures: !1,
                            trash: !1
                        })
                    },
                    render: function(t, e) {
                        e(t)
                    }
                }
            }
        }
        , {}],
        116: [function(t, e, n) {
            "use strict";
            function i(t, e) {
                return t.map(function(t) {
                    return t.source ? t : r(t, {
                        id: t.id + "." + e,
                        source: "hot" === e ? o.sources.HOT : o.sources.COLD
                    })
                })
            }
            var r = t("xtend")
              , o = t("./constants")
              , s = {
                defaultMode: o.modes.SIMPLE_SELECT,
                keybindings: !0,
                touchEnabled: !0,
                clickBuffer: 2,
                touchBuffer: 25,
                boxSelect: !0,
                displayControlsDefault: !0,
                styles: t("./lib/theme"),
                controls: {},
                userProperties: !1,
                showButtons: !0
            }
              , a = {
                point: !0,
                line_string: !0,
                polygon: !0,
                circle: !0,
                trash: !0,
                combine_features: !0,
                uncombine_features: !0
            }
              , u = {
                point: !1,
                line_string: !1,
                polygon: !1,
                circle: !1,
                trash: !1,
                combine_features: !1,
                uncombine_features: !1
            };
            e.exports = function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                  , e = r(t);
                return t.controls || (e.controls = {}),
                !1 === t.displayControlsDefault ? e.controls = r(u, t.controls) : e.controls = r(a, t.controls),
                e = r(s, e),
                e.styles = i(e.styles, "cold").concat(i(e.styles, "hot")),
                e
            }
        }
        , {
            "./constants": 63,
            "./lib/theme": 102,
            xtend: 61
        }],
        117: [function(t, e, n) {
            "use strict";
            var i = t("./constants");
            e.exports = function() {
                function t(t, e) {
                    var i = n.get(t)
                      , o = i.internal(r);
                    n.ctx.events.currentModeRender(o, function(t) {
                        n.sources[e].push(t)
                    })
                }
                function e() {
                    n.isDirty = !1,
                    n.clearChangedIds()
                }
                var n = this;
                if (!n.ctx.map || void 0 === n.ctx.map.getSource(i.sources.HOT))
                    return e();
                var r = n.ctx.events.currentModeName();
                n.ctx.ui.queueMapClasses({
                    mode: r
                });
                var o = []
                  , s = [];
                n.isDirty ? s = n.getAllIds() : (o = n.getChangedIds().filter(function(t) {
                    return void 0 !== n.get(t)
                }),
                s = n.sources.hot.filter(function(t) {
                    return t.properties.id && -1 === o.indexOf(t.properties.id) && void 0 !== n.get(t.properties.id)
                }).map(function(t) {
                    return t.properties.id
                })),
                n.sources.hot = [];
                var a = n.sources.cold.length;
                n.sources.cold = n.isDirty ? [] : n.sources.cold.filter(function(t) {
                    var e = t.properties.id || t.properties.parent;
                    return -1 === o.indexOf(e)
                });
                var u = a !== n.sources.cold.length || s.length > 0;
                if (o.forEach(function(e) {
                    return t(e, "hot")
                }),
                s.forEach(function(e) {
                    return t(e, "cold")
                }),
                u && n.ctx.map.getSource(i.sources.COLD).setData({
                    type: i.geojsonTypes.FEATURE_COLLECTION,
                    features: n.sources.cold
                }),
                n.ctx.map.getSource(i.sources.HOT).setData({
                    type: i.geojsonTypes.FEATURE_COLLECTION,
                    features: n.sources.hot
                }),
                n._emitSelectionChange && (n.ctx.map.fire(i.events.SELECTION_CHANGE, {
                    features: n.getSelected().map(function(t) {
                        return t.toGeoJSON()
                    }),
                    points: n.getSelectedCoordinates().map(function(t) {
                        return {
                            type: i.geojsonTypes.FEATURE,
                            properties: {},
                            geometry: {
                                type: i.geojsonTypes.POINT,
                                coordinates: t.coordinates
                            }
                        }
                    })
                }),
                n._emitSelectionChange = !1),
                n._deletedFeaturesToEmit.length) {
                    var l = n._deletedFeaturesToEmit.map(function(t) {
                        return t.toGeoJSON()
                    });
                    n._deletedFeaturesToEmit = [],
                    n.ctx.map.fire(i.events.DELETE, {
                        features: l
                    })
                }
                n.ctx.map.fire(i.events.RENDER, {}),
                e()
            }
        }
        , {
            "./constants": 63
        }],
        118: [function(t, e, n) {
            "use strict";
            var i = t("./events")
              , r = t("./store")
              , o = t("./ui")
              , s = t("./constants");
            e.exports = function(t) {
                t.events = i(t),
                t.map = null,
                t.container = null,
                t.store = null,
                t.ui = o(t);
                var e = null
                  , n = {
                    onRemove: function() {
                        return n.removeLayers(),
                        t.ui.removeButtons(),
                        t.events.removeEventListeners(),
                        t.map = null,
                        t.container = null,
                        t.store = null,
                        e && e.parentNode && e.parentNode.removeChild(e),
                        e = null,
                        this
                    },
                    onAdd: function(i) {
                        t.map = i,
                        t.container = i.getContainer(),
                        t.store = new r(t),
                        e = t.ui.addButtons(),
                        t.options.boxSelect && (i.boxZoom.disable(),
                        i.dragPan.disable(),
                        i.dragPan.enable());
                        var o = null
                          , s = function e() {
                            i.off("load", e),
                            clearInterval(o),
                            n.addLayers(),
                            t.events.addEventListeners()
                        };
                        return i.loaded() ? s() : (i.on("load", s),
                        o = setInterval(function() {
                            i.loaded() && s()
                        }, 16)),
                        e
                    },
                    addLayers: function() {
                        t.map.addSource(s.sources.COLD, {
                            data: {
                                type: s.geojsonTypes.FEATURE_COLLECTION,
                                features: []
                            },
                            type: "geojson"
                        }),
                        t.map.addSource(s.sources.HOT, {
                            data: {
                                type: s.geojsonTypes.FEATURE_COLLECTION,
                                features: []
                            },
                            type: "geojson"
                        }),
                        t.options.styles.forEach(function(e) {
                            t.map.addLayer(e)
                        }),
                        t.store.render()
                    },
                    removeLayers: function() {
                        t.options.styles.forEach(function(e) {
                            t.map.removeLayer(e.id)
                        }),
                        t.map.removeSource(s.sources.COLD),
                        t.map.removeSource(s.sources.HOT)
                    }
                };
                return t.setup = n,
                n
            }
        }
        , {
            "./constants": 63,
            "./events": 73,
            "./store": 119,
            "./ui": 120
        }],
        119: [function(t, e, n) {
            "use strict";
            function i(t) {
                var e = this
                  , n = this._selectedCoordinates.filter(function(t) {
                    return e._selectedFeatureIds.has(t.feature_id)
                });
                this._selectedCoordinates.length === n.length || t.silent || (this._emitSelectionChange = !0),
                this._selectedCoordinates = n
            }
            var r = t("./lib/throttle")
              , o = t("./lib/to_dense_array")
              , s = t("./lib/string_set")
              , a = t("./render")
              , u = e.exports = function(t) {
                this._features = {},
                this._featureIds = new s,
                this._selectedFeatureIds = new s,
                this._selectedCoordinates = [],
                this._changedFeatureIds = new s,
                this._deletedFeaturesToEmit = [],
                this._emitSelectionChange = !1,
                this.ctx = t,
                this.sources = {
                    hot: [],
                    cold: []
                },
                this.render = r(a, 16, this),
                this.isDirty = !1
            }
            ;
            u.prototype.createRenderBatch = function() {
                var t = this
                  , e = this.render
                  , n = 0;
                return this.render = function() {
                    n++
                }
                ,
                function() {
                    t.render = e,
                    n > 0 && t.render()
                }
            }
            ,
            u.prototype.setDirty = function() {
                return this.isDirty = !0,
                this
            }
            ,
            u.prototype.featureChanged = function(t) {
                return this._changedFeatureIds.add(t),
                this
            }
            ,
            u.prototype.getChangedIds = function() {
                return this._changedFeatureIds.values()
            }
            ,
            u.prototype.clearChangedIds = function() {
                return this._changedFeatureIds.clear(),
                this
            }
            ,
            u.prototype.getAllIds = function() {
                return this._featureIds.values()
            }
            ,
            u.prototype.add = function(t) {
                return this.featureChanged(t.id),
                this._features[t.id] = t,
                this._featureIds.add(t.id),
                this
            }
            ,
            u.prototype.delete = function(t) {
                var e = this
                  , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return o(t).forEach(function(t) {
                    e._featureIds.has(t) && (e._featureIds.delete(t),
                    e._selectedFeatureIds.delete(t),
                    n.silent || -1 === e._deletedFeaturesToEmit.indexOf(e._features[t]) && e._deletedFeaturesToEmit.push(e._features[t]),
                    delete e._features[t],
                    e.isDirty = !0)
                }),
                i.call(this, n),
                this
            }
            ,
            u.prototype.get = function(t) {
                return this._features[t]
            }
            ,
            u.prototype.getAll = function() {
                var t = this;
                return Object.keys(this._features).map(function(e) {
                    return t._features[e]
                })
            }
            ,
            u.prototype.select = function(t) {
                var e = this
                  , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return o(t).forEach(function(t) {
                    e._selectedFeatureIds.has(t) || (e._selectedFeatureIds.add(t),
                    e._changedFeatureIds.add(t),
                    n.silent || (e._emitSelectionChange = !0))
                }),
                this
            }
            ,
            u.prototype.deselect = function(t) {
                var e = this
                  , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return o(t).forEach(function(t) {
                    e._selectedFeatureIds.has(t) && (e._selectedFeatureIds.delete(t),
                    e._changedFeatureIds.add(t),
                    n.silent || (e._emitSelectionChange = !0))
                }),
                i.call(this, n),
                this
            }
            ,
            u.prototype.clearSelected = function() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return this.deselect(this._selectedFeatureIds.values(), {
                    silent: t.silent
                }),
                this
            }
            ,
            u.prototype.setSelected = function(t) {
                var e = this
                  , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return t = o(t),
                this.deselect(this._selectedFeatureIds.values().filter(function(e) {
                    return -1 === t.indexOf(e)
                }), {
                    silent: n.silent
                }),
                this.select(t.filter(function(t) {
                    return !e._selectedFeatureIds.has(t)
                }), {
                    silent: n.silent
                }),
                this
            }
            ,
            u.prototype.setSelectedCoordinates = function(t) {
                return this._selectedCoordinates = t,
                this._emitSelectionChange = !0,
                this
            }
            ,
            u.prototype.clearSelectedCoordinates = function() {
                return this._selectedCoordinates = [],
                this._emitSelectionChange = !0,
                this
            }
            ,
            u.prototype.getSelectedIds = function() {
                return this._selectedFeatureIds.values()
            }
            ,
            u.prototype.getSelected = function() {
                var t = this;
                return this._selectedFeatureIds.values().map(function(e) {
                    return t.get(e)
                })
            }
            ,
            u.prototype.getSelectedCoordinates = function() {
                return this._selectedCoordinates
            }
            ,
            u.prototype.isSelected = function(t) {
                return this._selectedFeatureIds.has(t)
            }
            ,
            u.prototype.setFeatureProperty = function(t, e, n) {
                this.get(t).setProperty(e, n),
                this.featureChanged(t)
            }
        }
        , {
            "./lib/string_set": 100,
            "./lib/throttle": 103,
            "./lib/to_dense_array": 104,
            "./render": 117
        }],
        120: [function(t, e, n) {
            "use strict";
            var i = t("xtend")
              , r = t("./constants")
              , o = ["mode", "feature", "mouse"];
            e.exports = function(t) {
                function e(t) {
                    g = i(g, t)
                }
                function n() {
                    if (t.container) {
                        var e = []
                          , n = [];
                        o.forEach(function(t) {
                            g[t] !== d[t] && (e.push(t + "-" + d[t]),
                            null !== g[t] && n.push(t + "-" + g[t]))
                        }),
                        e.length > 0 && t.container.classList.remove.apply(t.container.classList, e),
                        n.length > 0 && t.container.classList.add.apply(t.container.classList, n),
                        d = i(d, g)
                    }
                }
                function s(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                      , n = document.createElement("button");
                    return n.className = r.classes.CONTROL_BUTTON + " " + e.className,
                    n.setAttribute("title", e.title),
                    e.container.appendChild(n),
                    n.addEventListener("click", function(n) {
                        if (n.preventDefault(),
                        n.stopPropagation(),
                        n.target === f)
                            return void a();
                        u(t),
                        e.onActivate()
                    }, !0),
                    n
                }
                function a() {
                    f && (f.classList.remove(r.classes.ACTIVE_BUTTON),
                    f = null)
                }
                function u(t) {
                    a();
                    var e = h[t];
                    e && e && "trash" !== t && (e.classList.add(r.classes.ACTIVE_BUTTON),
                    f = e)
                }
                function l() {
                    var e = t.options.controls
                      , n = document.createElement("div");
                    return t.options.showButtons || (n.style.visibility = "hidden"),
                    n.className = r.classes.CONTROL_GROUP + " " + r.classes.CONTROL_BASE,
                    e ? (e[r.types.LINE] && (h[r.types.LINE] = s(r.types.LINE, {
                        container: n,
                        className: r.classes.CONTROL_BUTTON_LINE,
                        title: "画线工具 " + (t.options.keybindings && "(l)"),
                        onActivate: function() {
                            return t.events.changeMode(r.modes.DRAW_LINE_STRING)
                        }
                    })),
                    e[r.types.POLYGON] && (h[r.types.POLYGON] = s(r.types.POLYGON, {
                        container: n,
                        className: r.classes.CONTROL_BUTTON_POLYGON,
                        title: "多边形工具 " + (t.options.keybindings && "(p)"),
                        onActivate: function() {
                            return t.events.changeMode(r.modes.DRAW_POLYGON)
                        }
                    })),
                    e[r.types.CIRCLE] && (h[r.types.CIRCLE] = s(r.types.CIRCLE, {
                        container: n,
                        className: r.classes.CONTROL_BUTTON_CIRCLE,
                        title: "画圆工具 " + (t.options.keybindings && "(q)"),
                        onActivate: function() {
                            return t.events.changeMode(r.modes.DRAW_CIRCLE)
                        }
                    })),
                    e[r.types.POINT] && (h[r.types.POINT] = s(r.types.POINT, {
                        container: n,
                        className: r.classes.CONTROL_BUTTON_POINT,
                        title: "点工具 " + (t.options.keybindings && "(m)"),
                        onActivate: function() {
                            return t.events.changeMode(r.modes.DRAW_POINT)
                        }
                    })),
                    e.trash && (h.trash = s("trash", {
                        container: n,
                        className: r.classes.CONTROL_BUTTON_TRASH,
                        title: "删除",
                        onActivate: function() {
                            t.events.trash()
                        }
                    })),
                    e.combine_features && (h.combine_features = s("combineFeatures", {
                        container: n,
                        className: r.classes.CONTROL_BUTTON_COMBINE_FEATURES,
                        title: "组合多边形",
                        onActivate: function() {
                            t.events.combineFeatures()
                        }
                    })),
                    e.uncombine_features && (h.uncombine_features = s("uncombineFeatures", {
                        container: n,
                        className: r.classes.CONTROL_BUTTON_UNCOMBINE_FEATURES,
                        title: "拆分多边形",
                        onActivate: function() {
                            t.events.uncombineFeatures()
                        }
                    })),
                    n) : n
                }
                function c() {
                    Object.keys(h).forEach(function(t) {
                        var e = h[t];
                        e.parentNode && e.parentNode.removeChild(e),
                        delete h[t]
                    })
                }
                var h = {}
                  , f = null
                  , d = {
                    mode: null,
                    feature: null,
                    mouse: null
                }
                  , g = {
                    mode: null,
                    feature: null,
                    mouse: null
                };
                return {
                    setActiveButton: u,
                    queueMapClasses: e,
                    updateMapClasses: n,
                    addButtons: l,
                    removeButtons: c
                }
            }
        }
        , {
            "./constants": 63,
            xtend: 61
        }]
    }, {}, [70])(70)
});

//////////////////
// WEBPACK FOOTER
// ./kmap/map-service/mine-map/minemap-edit.js
// module id = 331
// module chunks = 62
